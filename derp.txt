diff --git a/Documentation/DocBook/dvb/dvbstb.pdf b/Documentation/DocBook/dvb/dvbstb.pdf
deleted file mode 100644
index 0fa75d9..0000000
Binary files a/Documentation/DocBook/dvb/dvbstb.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/bayer.pdf b/Documentation/DocBook/v4l/bayer.pdf
deleted file mode 100644
index 905e60e..0000000
Binary files a/Documentation/DocBook/v4l/bayer.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/crop.pdf b/Documentation/DocBook/v4l/crop.pdf
deleted file mode 100644
index c9fb81c..0000000
Binary files a/Documentation/DocBook/v4l/crop.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/fieldseq_bt.pdf b/Documentation/DocBook/v4l/fieldseq_bt.pdf
deleted file mode 100644
index 26598b2..0000000
Binary files a/Documentation/DocBook/v4l/fieldseq_bt.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/fieldseq_tb.pdf b/Documentation/DocBook/v4l/fieldseq_tb.pdf
deleted file mode 100644
index 4965b22..0000000
Binary files a/Documentation/DocBook/v4l/fieldseq_tb.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/pipeline.pdf b/Documentation/DocBook/v4l/pipeline.pdf
deleted file mode 100644
index ee3e37f..0000000
Binary files a/Documentation/DocBook/v4l/pipeline.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/vbi_525.pdf b/Documentation/DocBook/v4l/vbi_525.pdf
deleted file mode 100644
index 9e72c25..0000000
Binary files a/Documentation/DocBook/v4l/vbi_525.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/vbi_625.pdf b/Documentation/DocBook/v4l/vbi_625.pdf
deleted file mode 100644
index 765235e..0000000
Binary files a/Documentation/DocBook/v4l/vbi_625.pdf and /dev/null differ
diff --git a/Documentation/DocBook/v4l/vbi_hsync.pdf b/Documentation/DocBook/v4l/vbi_hsync.pdf
deleted file mode 100644
index 200b668..0000000
Binary files a/Documentation/DocBook/v4l/vbi_hsync.pdf and /dev/null differ
diff --git a/arch/arm/configs/bravo_defconfig b/arch/arm/configs/bravo_defconfig
index 593bf55..ec10e28 100644
--- a/arch/arm/configs/bravo_defconfig
+++ b/arch/arm/configs/bravo_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated make config: don't edit
-# Linux/arm 3.0.37 Kernel Configuration
+# Linux/arm 3.0.16 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -16,7 +16,7 @@ CONFIG_LOCKDEP_SUPPORT=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_ARCH_HAS_CPUFREQ=y
 CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
 CONFIG_GENERIC_HWEIGHT=y
@@ -35,14 +35,16 @@ CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_CROSS_COMPILE=""
-CONFIG_LOCALVERSION="-k3wip"
-# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
 CONFIG_HAVE_KERNEL_LZO=y
-CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_GZIP is not set
 # CONFIG_KERNEL_LZMA is not set
 # CONFIG_KERNEL_LZO is not set
+CONFIG_KERNEL_XZ=y
 CONFIG_DEFAULT_HOSTNAME="(none)"
 CONFIG_SWAP=y
 # CONFIG_SYSVIPC is not set
@@ -64,15 +66,15 @@ CONFIG_GENERIC_IRQ_SHOW=y
 #
 # RCU Subsystem
 #
-# CONFIG_TREE_PREEMPT_RCU is not set
+CONFIG_TREE_PREEMPT_RCU=y
 # CONFIG_TINY_RCU is not set
-CONFIG_TINY_PREEMPT_RCU=y
+# CONFIG_TINY_PREEMPT_RCU is not set
 CONFIG_PREEMPT_RCU=y
 # CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
 # CONFIG_TREE_RCU_TRACE is not set
-CONFIG_RCU_BOOST=y
-CONFIG_RCU_BOOST_PRIO=1
-CONFIG_RCU_BOOST_DELAY=500
+# CONFIG_RCU_BOOST is not set
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=17
@@ -89,9 +91,9 @@ CONFIG_FAIR_GROUP_SCHED=y
 CONFIG_RT_GROUP_SCHED=y
 # CONFIG_BLK_CGROUP is not set
 # CONFIG_NAMESPACES is not set
-CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SCHED_AUTOGROUP is not set
 # CONFIG_SYSFS_DEPRECATED is not set
-CONFIG_RELAY=y
+# CONFIG_RELAY is not set
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_RD_GZIP=y
@@ -106,7 +108,8 @@ CONFIG_PANIC_TIMEOUT=5
 CONFIG_EXPERT=y
 CONFIG_UID16=y
 # CONFIG_SYSCTL_SYSCALL is not set
-# CONFIG_KALLSYMS is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
 CONFIG_HOTPLUG=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
@@ -139,9 +142,7 @@ CONFIG_HAVE_OPROFILE=y
 # CONFIG_KPROBES is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
 CONFIG_HAVE_CLK=y
-CONFIG_HAVE_DMA_API_DEBUG=y
 
 #
 # GCOV-based kernel profiling
@@ -168,10 +169,10 @@ CONFIG_LBDAF=y
 CONFIG_IOSCHED_NOOP=y
 CONFIG_IOSCHED_DEADLINE=y
 CONFIG_IOSCHED_CFQ=y
-# CONFIG_DEFAULT_DEADLINE is not set
-CONFIG_DEFAULT_CFQ=y
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_CFQ is not set
 # CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_DEFAULT_IOSCHED="deadline"
 # CONFIG_INLINE_SPIN_TRYLOCK is not set
 # CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
 # CONFIG_INLINE_SPIN_LOCK is not set
@@ -284,8 +285,9 @@ CONFIG_MSM_VIC=y
 # CONFIG_MSM_RPM is not set
 # CONFIG_MSM_MPM is not set
 CONFIG_MSM_REMOTE_SPINLOCK_LDREX=y
-CONFIG_MSM_MDP31=y
-# CONFIG_PERFLOCK is not set
+CONFIG_PERFLOCK=y
+CONFIG_PERFLOCK_BOOT_LOCK=y
+# CONFIG_PERFLOCK_SCREEN_POLICY is not set
 
 #
 # MSM Board Selection
@@ -295,13 +297,12 @@ CONFIG_MACH_BRAVO=y
 CONFIG_MACH_QSD8X50_SURF=y
 # CONFIG_MACH_QSD8X50_FFA is not set
 CONFIG_MSM_STACKED_MEMORY=y
-CONFIG_PHYS_OFFSET=0x20000000
-# CONFIG_VERY_EARLY_CONSOLE is not set
+CONFIG_PHYS_OFFSET=0x11808000
 CONFIG_PMEM_GPU0=y
-CONFIG_MSM_AMSS_VERSION=6225
+CONFIG_MSM_AMSS_VERSION=1550
 # CONFIG_MSM_AMSS_VERSION_6210 is not set
 # CONFIG_MSM_AMSS_VERSION_6220 is not set
-CONFIG_MSM_AMSS_VERSION_6225=y
+# CONFIG_MSM_AMSS_VERSION_6225 is not set
 # CONFIG_MSM_AMSS_VERSION_6350 is not set
 # CONFIG_MSM_AMSS_VERSION_6355 is not set
 # CONFIG_MSM_AMSS_VERSION_1355 is not set
@@ -311,7 +312,7 @@ CONFIG_MSM_AMSS_VERSION_6225=y
 # CONFIG_MSM_AMSS_VERSION_3200 is not set
 # CONFIG_MSM_AMSS_VERSION_1170 is not set
 # CONFIG_MSM_AMSS_VERSION_1200 is not set
-# CONFIG_MSM_AMSS_VERSION_1550 is not set
+CONFIG_MSM_AMSS_VERSION_1550=y
 CONFIG_MSM_DEBUG_UART_NONE=y
 # CONFIG_MSM_DEBUG_UART1 is not set
 # CONFIG_MSM_DEBUG_UART2 is not set
@@ -327,13 +328,13 @@ CONFIG_MSM7X00A_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
 # CONFIG_MSM7X00A_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
 # CONFIG_MSM7X00A_SLEEP_WAIT_FOR_INTERRUPT is not set
 CONFIG_MSM7X00A_SLEEP_MODE=0
-# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE=y
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE_SUSPEND=y
+# CONFIG_MSM7X00A_IDLE_SLEEP_MODE_POWER_COLLAPSE is not set
 # CONFIG_MSM7X00A_IDLE_SLEEP_MODE_APPS_SLEEP is not set
 # CONFIG_MSM7X00A_IDLE_SLEEP_MODE_RAMP_DOWN_AND_WAIT_FOR_INTERRUPT is not set
 # CONFIG_MSM7X00A_IDLE_SLEEP_WAIT_FOR_INTERRUPT is not set
-CONFIG_MSM7X00A_IDLE_SLEEP_MODE=1
-CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=50000000
+CONFIG_MSM7X00A_IDLE_SLEEP_MODE=0
+CONFIG_MSM7X00A_IDLE_SLEEP_MIN_TIME=20000000
 CONFIG_MSM7X00A_IDLE_SPIN_TIME=80000
 CONFIG_MSM_IDLE_STATS=y
 CONFIG_MSM_IDLE_STATS_FIRST_BUCKET=62500
@@ -342,8 +343,9 @@ CONFIG_MSM_IDLE_STATS_BUCKET_COUNT=10
 CONFIG_MSM_SUSPEND_STATS_FIRST_BUCKET=1000000000
 # CONFIG_CPU_HAS_L2_PMU is not set
 # CONFIG_HTC_HEADSET is not set
-# CONFIG_HTC_BATTCHG is not set
+CONFIG_HTC_BATTCHG=y
 # CONFIG_HTC_BATTCHG_MAX8957 is not set
+CONFIG_HTC_BATTCHG_SMEM=y
 # CONFIG_HTC_PWRSINK is not set
 # CONFIG_BUILD_OMA_DM is not set
 CONFIG_QSD_SVS=y
@@ -352,13 +354,13 @@ CONFIG_MSM_FIQ_SUPPORT=y
 # CONFIG_MSM_SERIAL_DEBUGGER is not set
 CONFIG_MSM_PROC_COMM=y
 CONFIG_MSM_SMD=y
-# CONFIG_MSM_SMD_PKG3 is not set
-CONFIG_MSM_SMD_PKG4=y
+CONFIG_MSM_SMD_PKG3=y
+# CONFIG_MSM_SMD_PKG4 is not set
 CONFIG_MSM_SMD0_WQ=y
 CONFIG_MSM_SMD_DEBUG=y
 CONFIG_MSM_N_WAY_SMD=y
 CONFIG_MSM_N_WAY_SMSM=y
-CONFIG_MSM_RESET_MODEM=y
+# CONFIG_MSM_RESET_MODEM is not set
 CONFIG_MSM_SMD_LOGGING=y
 CONFIG_MSM_SMD_NMEA=y
 CONFIG_MSM_SMD_TTY=y
@@ -375,15 +377,13 @@ CONFIG_MSM_RPC_PING=y
 CONFIG_MSM_RPC_PROC_COMM_TEST=y
 CONFIG_MSM_RPC_OEM_RAPI=y
 CONFIG_MSM_RPCSERVER_HANDSET=y
-# CONFIG_MSM_RMT_STORAGE_CLIENT is not set
+CONFIG_MSM_RMT_STORAGE_CLIENT=y
+# CONFIG_MSM_RMT_STORAGE_CLIENT_STATS is not set
 CONFIG_MSM_DALRPC=y
 # CONFIG_MSM_DALRPC_TEST is not set
-CONFIG_MSM_CPU_FREQ_SET_MIN_MAX=y
-CONFIG_MSM_CPU_FREQ_MAX=998400
-CONFIG_MSM_CPU_FREQ_MIN=245000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=384000
-CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245760
-# CONFIG_MSM_CPU_AVS is not set
+# CONFIG_MSM_CPU_FREQ_SET_MIN_MAX is not set
+CONFIG_MSM_CPU_FREQ_ONDEMAND_MAX=998400
+CONFIG_MSM_CPU_FREQ_ONDEMAND_MIN=245000
 # CONFIG_MSM_AVS_HW is not set
 # CONFIG_MSM_HW3D is not set
 CONFIG_AMSS_7X25_VERSION_2009=y
@@ -391,27 +391,37 @@ CONFIG_AMSS_7X25_VERSION_2009=y
 CONFIG_MSM_QDSP6=y
 CONFIG_RTAC=y
 # CONFIG_MSM_VREG_SWITCH_INVERTED is not set
-CONFIG_MSM_DMA_TEST=y
+# CONFIG_MSM_DMA_TEST is not set
 CONFIG_WIFI_CONTROL_FUNC=y
-# CONFIG_WIFI_MEM_PREALLOC is not set
-# CONFIG_WIFI_NVS_PROC_CREATE is not set
-# CONFIG_ARCH_MSM_FLASHLIGHT is not set
-CONFIG_QSD_AUDIO=y
-CONFIG_AUDIO_AAC_PLUS=y
-CONFIG_AUDIO_ENHANCED_AAC_PLUS=y
-CONFIG_SURF_FFA_GPIO_KEYPAD=y
+CONFIG_WIFI_MEM_PREALLOC=y
+CONFIG_WIFI_NVS_PROC_CREATE=y
+CONFIG_ARCH_MSM_FLASHLIGHT=y
+# CONFIG_QSD_AUDIO is not set
+# CONFIG_SURF_FFA_GPIO_KEYPAD is not set
 CONFIG_MSM_SLEEP_TIME_OVERRIDE=y
 # CONFIG_HTC_OFFMODE_ALARM is not set
 # CONFIG_HTC_QUICKBOOT_OFFMODE_ALARM is not set
-# CONFIG_MSM_MEMORY_LOW_POWER_MODE is not set
+CONFIG_MSM_MEMORY_LOW_POWER_MODE=y
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE_IDLE_ACTIVE is not set
+CONFIG_MSM_MEMORY_LOW_POWER_MODE_IDLE_RETENTION=y
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE_IDLE_DEEP_POWER_DOWN is not set
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE_SUSPEND_ACTIVE is not set
+# CONFIG_MSM_MEMORY_LOW_POWER_MODE_SUSPEND_RETENTION is not set
+CONFIG_MSM_MEMORY_LOW_POWER_MODE_SUSPEND_DEEP_POWER_DOWN=y
 CONFIG_MSM_PM_TIMEOUT_HALT=y
 # CONFIG_MSM_PM_TIMEOUT_RESET_MODEM is not set
 # CONFIG_MSM_PM_TIMEOUT_RESET_CHIP is not set
-CONFIG_MSM_IDLE_WAIT_ON_MODEM=0
-# CONFIG_HTC_HEADSET_MGR is not set
-# CONFIG_HTC_ONMODE_CHARGING is not set
-CONFIG_SMD_OFFSET_TCXO_STAT=0x0
-CONFIG_SMD_OFFSET_NEGATE_CLIENT_STAT=0x0
+CONFIG_MSM_IDLE_WAIT_ON_MODEM=2000
+CONFIG_HTC_HEADSET_MGR=y
+# CONFIG_HTC_HEADSET_H2W is not set
+CONFIG_HTC_HEADSET_GPIO=y
+# CONFIG_HTC_HEADSET_PMIC is not set
+# CONFIG_HTC_HEADSET_MAX8957 is not set
+# CONFIG_HTC_HEADSET_MISC is not set
+# CONFIG_HTC_HEADSET_8X60 is not set
+CONFIG_HTC_ONMODE_CHARGING=y
+CONFIG_SMD_OFFSET_TCXO_STAT=0xFC2A0
+CONFIG_SMD_OFFSET_NEGATE_CLIENT_STAT=0xFC124
 # CONFIG_MSM_SCM is not set
 # CONFIG_MSM_RPM_LOG is not set
 # CONFIG_MSM_DIRECT_SCLK_ACCESS is not set
@@ -423,13 +433,14 @@ CONFIG_MSM_JTAG_V7=y
 # CONFIG_MSM_TRACE_ACROSS_PC is not set
 # CONFIG_MSM_STANDALONE_POWER_COLLAPSE is not set
 # CONFIG_MSM_GSBI9_UART is not set
-# CONFIG_SUPPORT_DQ_BATTERY is not set
+CONFIG_MSM_SHOW_RESUME_IRQ=y
+CONFIG_SUPPORT_DQ_BATTERY=y
 # CONFIG_MSM_FAKE_BATTERY is not set
 # CONFIG_MSM_QDSP6_APR is not set
 # CONFIG_MSM_AUDIO_QDSP6 is not set
 # CONFIG_MSM_RPC_VIBRATOR is not set
 # CONFIG_RPC_VER_60001 is not set
-# CONFIG_MSM_SPM_V1 is not set
+CONFIG_MSM_SPM_V1=y
 # CONFIG_MSM_SPM_V2 is not set
 
 #
@@ -478,10 +489,10 @@ CONFIG_ARM_DMA_MEM_BUFFERABLE=y
 # CONFIG_STRICT_MEMORY_RWX is not set
 # CONFIG_RESERVE_FIRST_PAGE is not set
 CONFIG_CPU_HAS_PMU=y
-CONFIG_ARM_ERRATA_430973=y
-CONFIG_ARM_ERRATA_458693=y
-CONFIG_ARM_ERRATA_460075=y
-CONFIG_ARM_ERRATA_743622=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_743622 is not set
 # CONFIG_ARM_ERRATA_754322 is not set
 # CONFIG_KSAPI is not set
 # CONFIG_FIQ_DEBUGGER is not set
@@ -524,7 +535,8 @@ CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_HAVE_MEMBLOCK=y
 CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=4
-# CONFIG_COMPACTION is not set
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
 # CONFIG_PHYS_ADDR_T_64BIT is not set
 CONFIG_ZONE_DMA_FLAG=0
 CONFIG_VIRT_TO_BUS=y
@@ -532,11 +544,6 @@ CONFIG_KSM=y
 CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
 CONFIG_NEED_PER_CPU_KM=y
 # CONFIG_CLEANCACHE is not set
-# CONFIG_ARCH_MEMORY_PROBE is not set
-# CONFIG_ARCH_MEMORY_REMOVE is not set
-# CONFIG_ARCH_POPULATES_NODE_MAP is not set
-# CONFIG_ENABLE_DMM is not set
-# CONFIG_FIX_MOVABLE_ZONE is not set
 # CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG is not set
 # CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE is not set
 CONFIG_FORCE_MAX_ZONEORDER=11
@@ -546,7 +553,7 @@ CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_CC_STACKPROTECTOR is not set
 # CONFIG_DEPRECATED_PARAM_STRUCT is not set
 # CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
-# CONFIG_CP_ACCESS is not set
+CONFIG_CP_ACCESS=m
 
 #
 # Boot options
@@ -572,8 +579,7 @@ CONFIG_CMDLINE_FROM_BOOTLOADER=y
 #
 CONFIG_CPU_FREQ=y
 CONFIG_CPU_FREQ_TABLE=y
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_STAT is not set
 # CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
 # CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
 # CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
@@ -581,12 +587,12 @@ CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
 # CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
 # CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
 CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE=y
-CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND_2_PHASE is not set
+# CONFIG_CPU_FREQ_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
 # CONFIG_CPU_IDLE is not set
 CONFIG_CPU_FREQ_MSM=y
 
@@ -621,13 +627,15 @@ CONFIG_WAKELOCK=y
 CONFIG_WAKELOCK_STAT=y
 CONFIG_USER_WAKELOCK=y
 CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_SUSPEND is not set
 # CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
 CONFIG_FB_EARLYSUSPEND=y
 CONFIG_PM_SLEEP=y
-# CONFIG_PM_RUNTIME is not set
+CONFIG_PM_RUNTIME=y
 CONFIG_PM=y
 # CONFIG_PM_DEBUG is not set
 # CONFIG_APM_EMULATION is not set
+CONFIG_PM_RUNTIME_CLK=y
 # CONFIG_SUSPEND_TIME is not set
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
@@ -638,7 +646,7 @@ CONFIG_NET=y
 CONFIG_PACKET=y
 CONFIG_UNIX=y
 CONFIG_XFRM=y
-# CONFIG_XFRM_USER is not set
+CONFIG_XFRM_USER=y
 # CONFIG_XFRM_SUB_POLICY is not set
 # CONFIG_XFRM_MIGRATE is not set
 # CONFIG_XFRM_STATISTICS is not set
@@ -646,23 +654,26 @@ CONFIG_XFRM_IPCOMP=y
 CONFIG_NET_KEY=y
 # CONFIG_NET_KEY_MIGRATE is not set
 CONFIG_INET=y
-# CONFIG_IP_MULTICAST is not set
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+CONFIG_IP_ROUTE_VERBOSE=y
+# CONFIG_IP_PNP is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_LARGE_TCP_INITIAL_BUFFER=y
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
+CONFIG_INET_AH=y
 CONFIG_INET_ESP=y
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_XFRM_TUNNEL is not set
 CONFIG_INET_TUNNEL=y
 CONFIG_INET_XFRM_MODE_TRANSPORT=y
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TUNNEL=y
 # CONFIG_INET_XFRM_MODE_BEET is not set
 # CONFIG_INET_LRO is not set
 CONFIG_INET_DIAG=y
@@ -700,7 +711,6 @@ CONFIG_NET_ACTIVITY_STATS=y
 CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
 CONFIG_NETFILTER_ADVANCED=y
-CONFIG_BRIDGE_NETFILTER=y
 
 #
 # Core Netfilter Configuration
@@ -751,12 +761,12 @@ CONFIG_NETFILTER_XT_TARGET_LED=y
 CONFIG_NETFILTER_XT_TARGET_MARK=y
 # CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
 CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
-CONFIG_NETFILTER_XT_TARGET_NOTRACK=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
 # CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
 # CONFIG_NETFILTER_XT_TARGET_TEE is not set
 # CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
-CONFIG_NETFILTER_XT_TARGET_TRACE=y
-# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
 # CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
 
 #
@@ -773,7 +783,7 @@ CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
 # CONFIG_NETFILTER_XT_MATCH_DCCP is not set
 # CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
 # CONFIG_NETFILTER_XT_MATCH_DSCP is not set
-# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_ESP=y
 CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
 CONFIG_NETFILTER_XT_MATCH_HELPER=y
 CONFIG_NETFILTER_XT_MATCH_HL=y
@@ -782,11 +792,10 @@ CONFIG_NETFILTER_XT_MATCH_LENGTH=y
 CONFIG_NETFILTER_XT_MATCH_LIMIT=y
 CONFIG_NETFILTER_XT_MATCH_MAC=y
 CONFIG_NETFILTER_XT_MATCH_MARK=y
-# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
 # CONFIG_NETFILTER_XT_MATCH_OSF is not set
 # CONFIG_NETFILTER_XT_MATCH_OWNER is not set
 CONFIG_NETFILTER_XT_MATCH_POLICY=y
-# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
 CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
 CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
 CONFIG_NETFILTER_XT_MATCH_QUOTA=y
@@ -800,7 +809,7 @@ CONFIG_NETFILTER_XT_MATCH_SOCKET=y
 CONFIG_NETFILTER_XT_MATCH_STATE=y
 CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
 CONFIG_NETFILTER_XT_MATCH_STRING=y
-# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
 CONFIG_NETFILTER_XT_MATCH_TIME=y
 CONFIG_NETFILTER_XT_MATCH_U32=y
 # CONFIG_IP_SET is not set
@@ -868,21 +877,17 @@ CONFIG_IP6_NF_FILTER=y
 CONFIG_IP6_NF_TARGET_REJECT=y
 # CONFIG_IP6_NF_TARGET_REJECT_SKERR is not set
 CONFIG_IP6_NF_MANGLE=y
-# CONFIG_IP6_NF_RAW is not set
-# CONFIG_BRIDGE_NF_EBTABLES is not set
+CONFIG_IP6_NF_RAW=y
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
 # CONFIG_L2TP is not set
-CONFIG_STP=y
-CONFIG_BRIDGE=y
-CONFIG_BRIDGE_IGMP_SNOOPING=y
+# CONFIG_BRIDGE is not set
 # CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
-CONFIG_LLC=y
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
@@ -920,8 +925,8 @@ CONFIG_NET_SCH_INGRESS=y
 # Classification
 #
 CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_BASIC is not set
-# CONFIG_NET_CLS_TCINDEX is not set
+CONFIG_NET_CLS_BASIC=y
+CONFIG_NET_CLS_TCINDEX=y
 # CONFIG_NET_CLS_ROUTE4 is not set
 # CONFIG_NET_CLS_FW is not set
 CONFIG_NET_CLS_U32=y
@@ -952,6 +957,7 @@ CONFIG_NET_ACT_MIRRED=y
 # CONFIG_NET_CLS_IND is not set
 CONFIG_NET_SCH_FIFO=y
 # CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
 # CONFIG_BATMAN_ADV is not set
 
 #
@@ -1020,27 +1026,13 @@ CONFIG_RFKILL_LEDS=y
 # CONFIG_CEPH_LIB is not set
 
 #
-# CFG80211 needs to be enabled for MAC80211
-#
-# CONFIG_WIMAX is not set
-CONFIG_RFKILL=y
-# CONFIG_RFKILL_PM is not set
-CONFIG_RFKILL_LEDS=y
-# CONFIG_RFKILL_INPUT is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_RFKILL_GPIO is not set
-# CONFIG_NET_9P is not set
-# CONFIG_CAIF is not set
-# CONFIG_CEPH_LIB is not set
-
-#
 # Device Drivers
 #
 
 #
 # Generic Driver Options
 #
-CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 # CONFIG_DEVTMPFS is not set
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
@@ -1104,8 +1096,10 @@ CONFIG_MTD_CFI_I2=y
 #
 # Self-contained MTD device drivers
 #
-CONFIG_MTD_MSM_NAND=y
-CONFIG_MTD_HTCLEO_NAND=y
+# CONFIG_MTD_MSM_NAND is not set
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_PHRAM is not set
 # CONFIG_MTD_MTDRAM is not set
@@ -1130,12 +1124,13 @@ CONFIG_MTD_NAND_IDS=y
 CONFIG_BLK_DEV=y
 # CONFIG_BLK_DEV_COW_COMMON is not set
 CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_CRYPTOLOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
 
 #
 # DRBD disabled because PROC_FS, INET or CONNECTOR not selected
 #
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
 # CONFIG_BLK_DEV_RAM is not set
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
@@ -1156,25 +1151,35 @@ CONFIG_ANDROID_PMEM=y
 # CONFIG_SENSORS_BH1770 is not set
 # CONFIG_SENSORS_APDS990X is not set
 # CONFIG_HMC6352 is not set
-CONFIG_SENSORS_AKM8973=y
 # CONFIG_SENSORS_AK8975 is not set
 # CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
 CONFIG_UID_STAT=y
 # CONFIG_BMP085 is not set
 # CONFIG_WL127X_RFKILL is not set
 # CONFIG_APANIC is not set
 # CONFIG_TSIF is not set
-# CONFIG_TSPP is not set
-# CONFIG_HAPTIC_ISA1200 is not set
+CONFIG_HAPTIC_ISA1200=y
+CONFIG_PMIC8058_PWM=y
+# CONFIG_PMIC8058_VIBRATOR is not set
+CONFIG_PMIC8XXX_VIBRATOR=y
+# CONFIG_PMIC8XXX_NFC is not set
+CONFIG_PMIC8XXX_UPL=y
+# CONFIG_PMIC8058_XOADC is not set
+# CONFIG_PMIC8058_MISC is not set
+# CONFIG_PMIC8058_BATTALARM is not set
 # CONFIG_TZCOM is not set
-# CONFIG_QSEECOM is not set
 # CONFIG_QFP_FUSE is not set
+# CONFIG_CABLE_DETECT_8X55 is not set
+# CONFIG_CABLE_DETECT_ACCESSORY is not set
+# CONFIG_CABLE_DETECT_ACCESSORY_BY_ADC is not set
 # CONFIG_C2PORT is not set
 
 #
 # EEPROM support
 #
 # CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
 # CONFIG_EEPROM_LEGACY is not set
 # CONFIG_EEPROM_MAX6875 is not set
 # CONFIG_EEPROM_93CX6 is not set
@@ -1184,7 +1189,15 @@ CONFIG_UID_STAT=y
 # Texas Instruments shared transport line discipline
 #
 # CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
 # CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_MPU_SENSORS_MPU3050 is not set
+# CONFIG_MPU_SENSORS_TIMERIRQ is not set
+
+#
+# Motorola TS 27.010 Mux driver over UART
+#
+# CONFIG_MOT_FEAT_TS27010MUX_UART is not set
 CONFIG_HAVE_IDE=y
 # CONFIG_IDE is not set
 
@@ -1246,6 +1259,17 @@ CONFIG_BCMDHD_NVRAM_PATH="/etc/calibration"
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
 #
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
 # CONFIG_WAN is not set
 
 #
@@ -1254,7 +1278,7 @@ CONFIG_BCMDHD_NVRAM_PATH="/etc/calibration"
 CONFIG_PPP=y
 # CONFIG_PPP_MULTILINK is not set
 # CONFIG_PPP_FILTER is not set
-CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_ASYNC is not set
 # CONFIG_PPP_SYNC_TTY is not set
 CONFIG_PPP_DEFLATE=y
 CONFIG_PPP_BSDCOMP=y
@@ -1269,6 +1293,8 @@ CONFIG_MSM_RMNET=y
 # CONFIG_MSM_RMNET_DEBUG is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HTC_NETWORK_MODIFY is not set
+CONFIG_KINETO_GAN=m
 # CONFIG_ISDN is not set
 # CONFIG_PHONE is not set
 
@@ -1293,15 +1319,27 @@ CONFIG_INPUT_KEYRESET=y
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_KEYBOARD_PMIC8058 is not set
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
 CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ATMEL_DETECT_CABLE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_DETECT_USB is not set
+# CONFIG_TOUCHSCREEN_ATMEL_DETECT_USB_VBUS is not set
+# CONFIG_TOUCHSCREEN_ATMEL_WLS is not set
+# CONFIG_TOUCHSCREEN_ATMEL is not set
+# CONFIG_TOUCHSCREEN_ATMEL_224E is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_ATMEL_MAXTOUCH is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_TMA is not set
+CONFIG_TOUCHSCREEN_COMPATIBLE_REPORT=y
 # CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
 # CONFIG_TOUCHSCREEN_BU21013 is not set
 # CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_CS is not set
 # CONFIG_TOUCHSCREEN_DYNAPRO is not set
 # CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
 # CONFIG_TOUCHSCREEN_EETI is not set
@@ -1315,12 +1353,13 @@ CONFIG_INPUT_TOUCHSCREEN=y
 # CONFIG_TOUCHSCREEN_INEXIO is not set
 # CONFIG_TOUCHSCREEN_MK712 is not set
 # CONFIG_TOUCHSCREEN_PENMOUNT is not set
-# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI=y
-# CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_3K is not set
 # CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
 # CONFIG_TOUCHSCREEN_MSM_LEGACY is not set
 # CONFIG_TOUCHSCREEN_W90X900 is not set
@@ -1328,7 +1367,9 @@ CONFIG_INPUT_TOUCHSCREEN=y
 # CONFIG_TOUCHSCREEN_TPS6507X is not set
 # CONFIG_TOUCHSCREEN_CY8C_TS is not set
 # CONFIG_TOUCHSCREEN_CYTTSP_I2C is not set
-# CONFIG_TOUCHSCREEN_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_HIMAX is not set
+# CONFIG_TOUCHSCREEN_HIMAX_SH is not set
+# CONFIG_TOUCHSCREEN_HIMAX_SH2 is not set
 CONFIG_INPUT_MISC=y
 # CONFIG_INPUT_AD714X is not set
 # CONFIG_INPUT_ATI_REMOTE is not set
@@ -1342,12 +1383,15 @@ CONFIG_INPUT_UINPUT=y
 CONFIG_INPUT_GPIO=y
 # CONFIG_INPUT_ISA1200_FF_MEMLESS is not set
 # CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PMIC8XXX_PWRKEY is not set
 # CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
 # CONFIG_INPUT_ADXL34X is not set
 # CONFIG_INPUT_CMA3000 is not set
+# CONFIG_PMIC8058_PWRKEY is not set
+# CONFIG_PMIC8058_OTHC is not set
 # CONFIG_BOSCH_BMA150 is not set
-CONFIG_INPUT_CAPELLA_CM3602_HTC=y
-# CONFIG_INPUT_OPTICALJOYSTICK is not set
+CONFIG_INPUT_DUMMY_KEYPAD=y
+CONFIG_POWER_KEY_LED=y
 
 #
 # Hardware I/O ports
@@ -1376,37 +1420,39 @@ CONFIG_UNIX98_PTYS=y
 #
 # Non-8250 serial port support
 #
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_SERIAL_MSM=y
 CONFIG_SERIAL_MSM_CONSOLE=y
 CONFIG_SERIAL_MSM_HS=y
 # CONFIG_SERIAL_MSM_HS_IMC is not set
-# CONFIG_SERIAL_MSM_CLOCK_CONTROL is not set
+CONFIG_SERIAL_MSM_CLOCK_CONTROL=y
+# CONFIG_SERIAL_MSM_RX_WAKEUP is not set
 # CONFIG_SERIAL_MSM_HSL is not set
 CONFIG_SERIAL_BCM_BT_LPM=y
 # CONFIG_SERIAL_TIMBERDALE is not set
 # CONFIG_SERIAL_ALTERA_JTAGUART is not set
 # CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
 # CONFIG_SERIAL_MSM_SMD is not set
 # CONFIG_SERIAL_XILINX_PS_UART is not set
 
 #
 # Diag Support
 #
+# CONFIG_DIAG_CHAR is not set
 
 #
 # DIAG traffic over USB
 #
-CONFIG_DIAG_OVER_USB=y
+# CONFIG_DIAG_OVER_USB is not set
+# CONFIG_MODEM_DIAG_MASTER is not set
 
 #
 # SDIO support for DIAG
 #
-
-#
-# HSIC support for DIAG
-#
 # CONFIG_TTY_PRINTK is not set
 # CONFIG_HVC_DCC is not set
 # CONFIG_IPMI_HANDLER is not set
@@ -1431,7 +1477,7 @@ CONFIG_I2C_COMPAT=y
 # CONFIG_SENSORS_AKM8975 is not set
 # CONFIG_SENSORS_AKM8975_PANA_GYRO is not set
 # CONFIG_SENSORS_PANASONIC_GYRO is not set
-# CONFIG_TPS65200 is not set
+CONFIG_TPS65200=y
 # CONFIG_SENSORS_BMA250 is not set
 # CONFIG_SENSORS_NFC_PN544 is not set
 # CONFIG_INPUT_CAPELLA_CM3628 is not set
@@ -1441,6 +1487,7 @@ CONFIG_I2C_COMPAT=y
 # CONFIG_AMP_TPA2051D3 is not set
 # CONFIG_INPUT_ISL29028 is not set
 # CONFIG_INPUT_ISL29029 is not set
+# CONFIG_AMP_TPA2051D3_ON_GPIO is not set
 # CONFIG_CODEC_AIC3254 is not set
 # CONFIG_CODEC_AIC3008 is not set
 CONFIG_I2C_HELPER_AUTO=y
@@ -1455,7 +1502,7 @@ CONFIG_I2C_HELPER_AUTO=y
 # CONFIG_I2C_DESIGNWARE is not set
 # CONFIG_I2C_GPIO is not set
 CONFIG_I2C_MSM=y
-# CONFIG_I2C_QUP is not set
+CONFIG_I2C_QUP=y
 # CONFIG_I2C_OCORES is not set
 # CONFIG_I2C_PCA_PLATFORM is not set
 # CONFIG_I2C_PXA_PCI is not set
@@ -1465,8 +1512,10 @@ CONFIG_I2C_MSM=y
 #
 # External I2C/SMBus adapter drivers
 #
+# CONFIG_I2C_DIOLAN_U2C is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
 
 #
 # Other I2C/SMBus bus drivers
@@ -1475,8 +1524,28 @@ CONFIG_I2C_MSM=y
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
 # CONFIG_I2C_DEBUG_BUS is not set
-# CONFIG_SPI is not set
-# CONFIG_SPMI is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+CONFIG_SPI_QSD=y
+# CONFIG_SPI_DISPLAY is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
 # CONFIG_SLIMBUS is not set
 
 #
@@ -1522,6 +1591,10 @@ CONFIG_GPIOLIB=y
 #
 # SPI GPIO expanders:
 #
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
 
 #
 # AC97 GPIO expanders:
@@ -1530,13 +1603,16 @@ CONFIG_GPIOLIB=y
 #
 # MODULbus GPIO expanders:
 #
+CONFIG_GPIO_PM8XXX=y
+CONFIG_GPIO_PM8XXX_MPP=y
 # CONFIG_GPIO_PM8XXX_RPC is not set
 CONFIG_W1=y
 
 #
 # 1-wire Bus Masters
 #
-CONFIG_W1_MASTER_DS2482=y
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
 # CONFIG_W1_MASTER_DS1WM is not set
 # CONFIG_W1_MASTER_GPIO is not set
 
@@ -1556,24 +1632,115 @@ CONFIG_POWER_SUPPLY=y
 # CONFIG_POWER_SUPPLY_DEBUG is not set
 # CONFIG_PDA_POWER is not set
 # CONFIG_TEST_POWER is not set
+CONFIG_BATTERY_DS2784=y
 # CONFIG_BATTERY_DS2780 is not set
 # CONFIG_BATTERY_DS2782 is not set
-CONFIG_BATTERY_DS2784=y
+# CONFIG_BATTERY_DS2746 is not set
 # CONFIG_BATTERY_BQ20Z75 is not set
 # CONFIG_BATTERY_BQ27x00 is not set
 # CONFIG_BATTERY_MAX17040 is not set
 # CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
 # CONFIG_CHARGER_MAX8903 is not set
 # CONFIG_CHARGER_GPIO is not set
 # CONFIG_BATTERY_MSM is not set
 # CONFIG_BATTERY_MSM8X60 is not set
 # CONFIG_SMB137B_CHARGER is not set
-# CONFIG_SMB349_CHARGER is not set
-# CONFIG_BATTERY_MSM_FAKE is not set
+# CONFIG_PM8058_FIX_USB is not set
 # CONFIG_BATTERY_BQ27520 is not set
 # CONFIG_BATTERY_BQ27541 is not set
-# CONFIG_LTC4088_CHARGER is not set
 # CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_WPCE775X is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
 # CONFIG_THERMAL is not set
 # CONFIG_WATCHDOG is not set
 CONFIG_SSB_POSSIBLE=y
@@ -1589,7 +1756,7 @@ CONFIG_BCMA_POSSIBLE=y
 #
 # CONFIG_BCMA is not set
 CONFIG_MFD_SUPPORT=y
-# CONFIG_MFD_CORE is not set
+CONFIG_MFD_CORE=y
 # CONFIG_MFD_88PM860X is not set
 # CONFIG_MFD_SM501 is not set
 # CONFIG_MFD_ASIC3 is not set
@@ -1599,6 +1766,7 @@ CONFIG_MFD_SUPPORT=y
 # CONFIG_TPS6105X is not set
 # CONFIG_TPS65010 is not set
 CONFIG_TPS65023=y
+CONFIG_PMIC8058=y
 # CONFIG_TPS6507X is not set
 # CONFIG_MFD_TPS6586X is not set
 # CONFIG_TWL4030_CORE is not set
@@ -1615,13 +1783,24 @@ CONFIG_TPS65023=y
 # CONFIG_MFD_MAX8998 is not set
 # CONFIG_MFD_WM8400 is not set
 # CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
 # CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
 # CONFIG_MFD_WL1273_CORE is not set
+CONFIG_MFD_PM8XXX=y
+# CONFIG_MFD_PM8921_CORE is not set
+# CONFIG_MFD_PM8821_CORE is not set
+# CONFIG_MFD_PM8018_CORE is not set
+CONFIG_MFD_PM8XXX_IRQ=y
 # CONFIG_MFD_TPS65910 is not set
-# CONFIG_WCD9304_CODEC is not set
+# CONFIG_MFD_PM8XXX_DEBUG is not set
+# CONFIG_MFD_PM8XXX_PWM is not set
+# CONFIG_MFD_PM8XXX_MISC is not set
+# CONFIG_MFD_PM8XXX_BATT_ALARM is not set
 # CONFIG_WCD9310_CODEC is not set
 CONFIG_REGULATOR=y
 CONFIG_REGULATOR_DEBUG=y
@@ -1636,12 +1815,13 @@ CONFIG_REGULATOR_DEBUG=y
 # CONFIG_REGULATOR_MAX8952 is not set
 # CONFIG_REGULATOR_LP3971 is not set
 # CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
+CONFIG_REGULATOR_TPS65023=y
 # CONFIG_REGULATOR_TPS6507X is not set
 # CONFIG_REGULATOR_ISL6271A is not set
 # CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
 # CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_STUB is not set
+# CONFIG_REGULATOR_PM8058_XO is not set
 CONFIG_MEDIA_SUPPORT=y
 
 #
@@ -1655,41 +1835,54 @@ CONFIG_MEDIA_SUPPORT=y
 #
 # Multimedia drivers
 #
-CONFIG_RC_CORE=y
-CONFIG_LIRC=y
-CONFIG_RC_MAP=y
-CONFIG_IR_NEC_DECODER=y
-CONFIG_IR_RC5_DECODER=y
-CONFIG_IR_RC6_DECODER=y
-CONFIG_IR_JVC_DECODER=y
-CONFIG_IR_SONY_DECODER=y
-CONFIG_IR_RC5_SZ_DECODER=y
-CONFIG_IR_LIRC_CODEC=y
-# CONFIG_IR_IMON is not set
-# CONFIG_IR_MCEUSB is not set
-# CONFIG_IR_REDRAT3 is not set
-# CONFIG_IR_STREAMZAP is not set
-# CONFIG_RC_LOOPBACK is not set
-# CONFIG_IR_GPIO_CIR is not set
+# CONFIG_RC_CORE is not set
+
+#
+# Qualcomm MSM Camera And Video
+#
+CONFIG_MSM_CAMERA=y
+CONFIG_720P_CAMERA=y
+# CONFIG_MSM_CAMERA_DEBUG is not set
+# CONFIG_MSM_CAMERA_V4L2 is not set
+# CONFIG_MSM_CAMERA_LEGACY is not set
+# CONFIG_MSM_CAMERA_8X60 is not set
+# CONFIG_FLASH_BACKLIGHT_OFF is not set
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_MT9T013 is not set
+# CONFIG_MT9D112 is not set
+# CONFIG_MT9P012 is not set
+# CONFIG_MT9P012_KM is not set
+CONFIG_S5K3E2FX=y
+# CONFIG_S5K4E1 is not set
+# CONFIG_S5K4E5YX is not set
+# CONFIG_S5K3H1GX is not set
+# CONFIG_MSM_CAMERA_FLASH_SC628A is not set
+# CONFIG_IMX072 is not set
+# CONFIG_QS_MT9P017 is not set
+# CONFIG_VB6801 is not set
+# CONFIG_MSM_CAMERA_FLASH is not set
+# CONFIG_MSM_CAMERA_SENSOR is not set
+# CONFIG_MSM_ACTUATOR is not set
+CONFIG_RAWCHIP=y
+CONFIG_QUP_EXCLUSIVE_TO_CAMERA=y
+# CONFIG_S5K3H2YX is not set
+# CONFIG_S5K3H2YX_ACT is not set
+# CONFIG_S5K4E5YX_ACT is not set
+# CONFIG_MT9V113 is not set
+# CONFIG_S5K6A1GX is not set
+# CONFIG_S5K6AAFX is not set
+# CONFIG_OV8830 is not set
 
 #
 # Graphics support
 #
 # CONFIG_DRM is not set
 # CONFIG_ION is not set
-CONFIG_MSM_KGSL=y
-# CONFIG_MSM_KGSL_CFF_DUMP is not set
-# CONFIG_MSM_KGSL_PSTMRTMDMP_CP_STAT_NO_DETAIL is not set
-# CONFIG_MSM_KGSL_PSTMRTMDMP_NO_IB_DUMP is not set
-# CONFIG_MSM_KGSL_PSTMRTMDMP_RB_HEX is not set
-CONFIG_MSM_KGSL_GPUMMU=y
-CONFIG_MSM_KGSL_MMU=y
-# CONFIG_KGSL_PER_PROCESS_PAGE_TABLE is not set
-CONFIG_MSM_KGSL_PAGE_TABLE_SIZE=0xFFF0000
-CONFIG_MSM_KGSL_MMU_PAGE_FAULT=y
-# CONFIG_MSM_KGSL_DISABLE_SHADOW_WRITES is not set
 # CONFIG_VGASTATE is not set
-CONFIG_VIDEO_OUTPUT_CONTROL=y
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
 # CONFIG_FIRMWARE_EDID is not set
 # CONFIG_FB_DDC is not set
@@ -1706,7 +1899,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 # CONFIG_FB_WMT_GE_ROPS is not set
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
-# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_BACKLIGHT=y
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 
@@ -1714,57 +1907,337 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 # Frame buffer hardware drivers
 #
 # CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_UDL is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_BROADSHEET is not set
 CONFIG_FB_MSM=y
-CONFIG_FB_MSM_MDP_PPP=y
+CONFIG_FB_MSM_TRIPLE_BUFFER=y
+CONFIG_FB_MSM_LCDC_HW=y
 CONFIG_FB_MSM_LCDC=y
-# CONFIG_FB_MSM_MDDI is not set
-CONFIG_FB_MSM_LEGACY_MDP=y
-# CONFIG_MSM_HDMI is not set
+CONFIG_FB_MSM_LCDC_PANEL=y
+# CONFIG_FB_MSM_TVOUT is not set
+# CONFIG_FB_MSM_EXT_INTERFACE_COMMON is not set
+# CONFIG_FB_MSM_HDMI_COMMON is not set
+# CONFIG_FB_MSM_HDMI_3D is not set
+# CONFIG_FB_MSM_MIPI_DSI is not set
+# CONFIG_FB_MSM_MIPI_DSI_TOSHIBA is not set
+# CONFIG_FB_MSM_MIPI_DSI_RENESAS is not set
+# CONFIG_FB_MSM_MIPI_DSI_NOVATEK is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA is not set
+# CONFIG_FB_MSM_LCDC_AUO_WVGA is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT is not set
+# CONFIG_FB_MSM_MIPI_PANEL_DETECT is not set
+CONFIG_FB_MSM_BACKLIGHT=y
 CONFIG_FB_MSM_LOGO=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_FB_MSM_MDP22 is not set
+# CONFIG_FB_MSM_MDP30 is not set
+CONFIG_FB_MSM_MDP31=y
+# CONFIG_FB_MSM_MDP40 is not set
+# CONFIG_FB_MSM_EBI2 is not set
+# CONFIG_FB_MSM_MDDI is not set
+# CONFIG_FB_MSM_EXTMDDI is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_COMMON_VGA is not set
+# CONFIG_FB_MSM_MDDI_ORISE is not set
+# CONFIG_FB_MSM_MDDI_QUICKVX is not set
+# CONFIG_FB_MSM_MDDI_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_AUTO_DETECT is not set
+# CONFIG_FB_MSM_MIPI_DSI_SIMULATOR is not set
+# CONFIG_FB_MSM_LCDC_ST15_WXGA is not set
+# CONFIG_FB_MSM_LCDC_ST15_PANEL is not set
+CONFIG_FB_MSM_LCDC_PRISM_WVGA=y
+# CONFIG_FB_MSM_LCDC_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_LCDC_GORDON_VGA is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT is not set
+# CONFIG_FB_MSM_LCDC_NT35582_WVGA is not set
+# CONFIG_FB_MSM_LCDC_WXGA is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WXGA is not set
+# CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO is not set
+CONFIG_FB_MSM_LCDC_PRISM_WVGA_PANEL=y
+# CONFIG_FB_MSM_LCDC_SAMSUNG_WSVGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_CHIMEI_WXGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_GORDON_VGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_WVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_TOSHIBA_FWVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SHARP_WVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_LCDC_AUO_WVGA_PANEL is not set
+# CONFIG_FB_MSM_LCDC_NT35582_PANEL is not set
+# CONFIG_FB_MSM_LCDC_SAMSUNG_OLED_PT_PANEL is not set
+# CONFIG_FB_MSM_TRY_MDDI_CATCH_LCDC_PRISM is not set
+# CONFIG_FB_MSM_MDDI_PANEL_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_PANEL_AUTO_DETECT is not set
+# CONFIG_FB_MSM_LCDC_MIPI_PANEL_AUTO_DETECT is not set
+# CONFIG_FB_MSM_MDDI_PRISM_WVGA is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_WVGA_PORTRAIT is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_VGA is not set
+# CONFIG_FB_MSM_MDDI_TOSHIBA_WVGA is not set
+# CONFIG_FB_MSM_MDDI_SHARP_QVGA_128x128 is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_TOSHIBA_VIDEO_WSVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_VIDEO_QHD_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_NOVATEK_CMD_QHD_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_VIDEO_FWVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_RENESAS_CMD_FWVGA_PT_PANEL is not set
+# CONFIG_FB_MSM_MIPI_CHIMEI_WXGA_PANEL is not set
+# CONFIG_FB_MSM_MIPI_SIMULATOR_VIDEO_PANEL is not set
+# CONFIG_FB_MSM_EBI2_TMD_QVGA_EPSON_QCIF is not set
+# CONFIG_FB_MSM_HDMI_AS_PRIMARY is not set
+# CONFIG_FB_MSM_PANEL_NONE is not set
+# CONFIG_FB_MSM_LCDC_EXTERNAL_WXGA is not set
+# CONFIG_FB_MSM_HDMI_SII_EXTERNAL_720P is not set
+CONFIG_FB_MSM_SECONDARY_PANEL_NONE=y
+# CONFIG_FB_MSM_TVOUT_NTSC_M is not set
+# CONFIG_FB_MSM_TVOUT_NTSC_J is not set
+# CONFIG_FB_MSM_TVOUT_PAL_BDGHIN is not set
+# CONFIG_FB_MSM_TVOUT_PAL_M is not set
+# CONFIG_FB_MSM_TVOUT_PAL_N is not set
+CONFIG_FB_MSM_TVOUT_NONE=y
+CONFIG_FB_MSM_DEFAULT_DEPTH_RGB565=y
+# CONFIG_FB_MSM_DEFAULT_DEPTH_ARGB8888 is not set
+# CONFIG_FB_MSM_DEFAULT_DEPTH_RGBA8888 is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
 
 #
 # Display device support
 #
 # CONFIG_DISPLAY_SUPPORT is not set
 # CONFIG_LOGO is not set
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+
+#
+# MSM SoC Audio support
+#
+# CONFIG_SND_SOC_QDSP6 is not set
+# CONFIG_SND_SOC_I2C_AND_SPI is not set
+# CONFIG_SND_SOC_ALL_CODECS is not set
+# CONFIG_SOUND_PRIME is not set
 CONFIG_HID_SUPPORT=y
 CONFIG_HID=y
 # CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
 # CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
 
 #
 # Special HID drivers
 #
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
 CONFIG_USB_SUPPORT=y
 CONFIG_USB_ARCH_HAS_HCD=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 CONFIG_USB_ARCH_HAS_EHCI=y
-# CONFIG_USB is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
 # CONFIG_USB_OTG_WHITELIST is not set
 # CONFIG_USB_OTG_BLACKLIST_HUB is not set
-# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_EHSET=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_MSM=y
+# CONFIG_USB_EHCI_MSM_HSIC is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_PEHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
 
 #
 # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
 #
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_QCOM_DIAG_BRIDGE is not set
+# CONFIG_USB_QCOM_MDM_BRIDGE is not set
 CONFIG_USB_GADGET=y
 # CONFIG_USB_GADGET_DEBUG is not set
 # CONFIG_USB_GADGET_DEBUG_FILES is not set
 # CONFIG_USB_GADGET_DEBUG_FS is not set
-CONFIG_USB_GADGET_VBUS_DRAW=500
-# CONFIG_USB_FUSB300 is not set
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_M66592 is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_CI13XXX_MSM is not set
 # CONFIG_USB_CI13XXX_MSM is not set
-# CONFIG_USB_CI13XXX_MSM_HSIC is not set
+CONFIG_USB_GADGET_MSM_72K=y
 CONFIG_USB_MSM_72K=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
 CONFIG_USB_GADGET_DUALSPEED=y
 # CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
 # CONFIG_USB_ETH is not set
 # CONFIG_USB_G_NCM is not set
 # CONFIG_USB_GADGETFS is not set
@@ -1772,28 +2245,53 @@ CONFIG_USB_GADGET_DUALSPEED=y
 # CONFIG_USB_FILE_STORAGE is not set
 # CONFIG_USB_MASS_STORAGE is not set
 # CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
 # CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_G_ANDROID=y
+# CONFIG_USB_ANDROID_ACM is not set
+CONFIG_USB_ANDROID_ADB=y
+CONFIG_USB_ANDROID_DIAG=y
+# CONFIG_USB_ANDROID_MDM9K_DIAG is not set
+# CONFIG_USB_ANDROID_MDM9K_MODEM is not set
+CONFIG_USB_ANDROID_MASS_STORAGE=y
+CONFIG_USB_ANDROID_MTP=y
+CONFIG_USB_ANDROID_RNDIS=y
+# CONFIG_USB_ANDROID_RMNET is not set
+CONFIG_RMNET_SMD_CTL_CHANNEL=""
+CONFIG_RMNET_SMD_DATA_CHANNEL=""
+# CONFIG_USB_ANDROID_RMNET_CTRL_SMD is not set
+# CONFIG_USB_F_SERIAL is not set
+CONFIG_MODEM_SUPPORT=y
+CONFIG_USB_ANDROID_SERIAL=y
+CONFIG_USB_ANDROID_PROJECTOR=y
+# CONFIG_USB_ANDROID_ECM is not set
+# CONFIG_USB_F_SERIAL_SMD is not set
+# CONFIG_USB_ANDROID_USBNET is not set
 # CONFIG_USB_CDC_COMPOSITE is not set
 # CONFIG_USB_G_MULTI is not set
 # CONFIG_USB_G_HID is not set
 # CONFIG_USB_G_DBGP is not set
-CONFIG_USB_CSW_HACK=y
-# CONFIG_USB_MSC_PROFILING is not set
-# CONFIG_USB_ANDROID_RMNET_CTRL_SMD is not set
+CONFIG_USB_ACCESSORY_DETECT_BY_ADC=y
+# CONFIG_USB_CSW_HACK is not set
+# CONFIG_USB_HUB is not set
+CONFIG_USB_GADGET_VERIZON_PRODUCT_ID=y
 
 #
 # OTG and related infrastructure
 #
+CONFIG_USB_OTG_UTILS=y
 # CONFIG_USB_OTG_WAKELOCK is not set
 # CONFIG_USB_GPIO_VBUS is not set
 # CONFIG_USB_ULPI is not set
-# CONFIG_USB_MSM_OTG_72K is not set
+CONFIG_USB_MSM_OTG_72K=y
 # CONFIG_NOP_USB_XCEIV is not set
-# CONFIG_USB_MSM_OTG is not set
+CONFIG_USB_MSM_OTG=y
+# CONFIG_USB_MSM_ACA is not set
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
-# CONFIG_MMC_PERF_PROFILING is not set
-CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_PERF_PROFILING=y
+CONFIG_ZIMMER=y
+# CONFIG_MMC_UNSAFE_RESUME is not set
 # CONFIG_MMC_CLKGATE is not set
 CONFIG_MMC_EMBEDDED_SDIO=y
 CONFIG_MMC_PARANOID_SD_INIT=y
@@ -1802,27 +2300,34 @@ CONFIG_MMC_PARANOID_SD_INIT=y
 # MMC/SD/SDIO Card Drivers
 #
 CONFIG_MMC_BLOCK=y
-CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_MINORS=64
 # CONFIG_MMC_BLOCK_BOUNCE is not set
 CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
 # CONFIG_SDIO_UART is not set
 # CONFIG_MMC_TEST is not set
+# CONFIG_MMC_TI_SDIO_ADAPT is not set
 
 #
 # MMC/SD/SDIO Host Controller Drivers
 #
 # CONFIG_MMC_SDHCI is not set
 CONFIG_MMC_MSM=y
-# CONFIG_MMC_MSM_SDIO_SUPPORT is not set
-# CONFIG_MMC_MSM_CARD_HW_DETECTION is not set
-CONFIG_MMC_MSM_SDC1_SUPPORT=y
-# CONFIG_MMC_MSM_SDC1_8_BIT_SUPPORT is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_MSM_SDIO_SUPPORT=y
+CONFIG_MMC_MSM_CARD_HW_DETECTION=y
+# CONFIG_MMC_MSM_SDC1_SUPPORT is not set
 CONFIG_MMC_MSM_SDC2_SUPPORT=y
-# CONFIG_MMC_MSM_SDC2_8_BIT_SUPPORT is not set
-# CONFIG_MMC_MSM_SDC3_SUPPORT is not set
-# CONFIG_MMC_MSM_SDC4_SUPPORT is not set
+CONFIG_MMC_MSM_SDC2_8_BIT_SUPPORT=y
+CONFIG_MMC_MSM_SDC3_SUPPORT=y
+# CONFIG_MMC_MSM_SDC3_8_BIT_SUPPORT is not set
+# CONFIG_MMC_MSM_SDC3_WP_SUPPORT is not set
+CONFIG_MMC_MSM_SDC4_SUPPORT=y
+# CONFIG_MMC_MSM_SDC4_8_BIT_SUPPORT is not set
 # CONFIG_MMC_MSM_SDC5_SUPPORT is not set
 # CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_ATHEROS_SDIO is not set
 # CONFIG_MEMSTICK is not set
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
@@ -1830,18 +2335,26 @@ CONFIG_LEDS_CLASS=y
 #
 # LED drivers
 #
+# CONFIG_LEDS_LM3530 is not set
 # CONFIG_LEDS_PCA9532 is not set
 CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_MSM_PDM is not set
 CONFIG_LEDS_GPIO_PLATFORM=y
 # CONFIG_LEDS_LP3944 is not set
+CONFIG_LEDS_CPLD=y
 # CONFIG_LEDS_LP5521 is not set
 # CONFIG_LEDS_LP5523 is not set
-CONFIG_LEDS_CPLD=y
 # CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PM8XXX is not set
+# CONFIG_LEDS_DAC124S085 is not set
 # CONFIG_LEDS_REGULATOR is not set
 # CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_MSM_PMIC is not set
+# CONFIG_LEDS_PMIC8058 is not set
 # CONFIG_LEDS_LT3593 is not set
 CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_PM8029 is not set
+CONFIG_LEDS_PM8058=y
 
 #
 # LED Triggers
@@ -1869,11 +2382,13 @@ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
 #
 # RTC interfaces
 #
-# CONFIG_RTC_INTF_SYSFS is not set
-# CONFIG_RTC_INTF_PROC is not set
-# CONFIG_RTC_INTF_DEV is not set
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
 CONFIG_RTC_INTF_ALARM=y
 CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_ANDROID_RTC_CHANGE_WAIT is not set
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
 # CONFIG_RTC_DRV_TEST is not set
 
 #
@@ -1902,6 +2417,15 @@ CONFIG_RTC_INTF_ALARM_DEV=y
 #
 # SPI RTC drivers
 #
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
 
 #
 # Platform RTC drivers
@@ -1927,12 +2451,19 @@ CONFIG_RTC_DRV_MSM=y
 CONFIG_RTC_SECURE_TIME_SUPPORT=y
 # CONFIG_RTC_ASYNC_MODEM_SUPPORT is not set
 CONFIG_RTC_DRV_MSM7X00A=y
+# CONFIG_RTC_PM8058 is not set
+# CONFIG_RTC_DRV_PM8XXX is not set
 # CONFIG_DMADEVICES is not set
 # CONFIG_AUXDISPLAY is not set
 # CONFIG_UIO is not set
 CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
 # CONFIG_ECHO is not set
 # CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
 
 #
 # Android
@@ -1947,18 +2478,25 @@ CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_DATA_SIZE=128
 CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_ECC_SIZE=16
 CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_SYMBOL_SIZE=8
 CONFIG_ANDROID_RAM_CONSOLE_ERROR_CORRECTION_POLYNOMIAL=0x11d
+# CONFIG_MDM9K_ERROR_CORRECTION is not set
 # CONFIG_ANDROID_RAM_CONSOLE_EARLY_INIT is not set
 CONFIG_ANDROID_TIMED_OUTPUT=y
 CONFIG_ANDROID_TIMED_GPIO=y
 CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_ANDROID_RADIO_LOG_SIZE=256
+CONFIG_ANDROID_DEVICE_LOG_SIZE=256
+CONFIG_ANDROID_SYSTEM_LOG_SIZE=256
+CONFIG_ANDROID_EVENTS_LOG_SIZE=256
 # CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
 # CONFIG_IIO is not set
-CONFIG_XVMALLOC=y
-CONFIG_ZRAM=y
-# CONFIG_ZRAM_DEBUG is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
 # CONFIG_FB_SM7XX is not set
-# CONFIG_LIRC_STAGING is not set
 CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_BCM_WIMAX is not set
 # CONFIG_FT1000 is not set
 
 #
@@ -1981,15 +2519,24 @@ CONFIG_CLKDEV_LOOKUP=y
 #
 # File systems
 #
-# CONFIG_EXT2_FS is not set
-# CONFIG_EXT3_FS is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
 CONFIG_EXT4_FS=y
-CONFIG_EXT4_USE_FOR_EXT23=y
 CONFIG_EXT4_FS_XATTR=y
 # CONFIG_EXT4_FS_POSIX_ACL is not set
 # CONFIG_EXT4_FS_SECURITY is not set
 # CONFIG_EXT4_DEBUG is not set
-# CONFIG_EXT4_E2FSCK_RECOVER is not set
+CONFIG_EXT4_E2FSCK_RECOVER=y
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
 CONFIG_JBD2=y
 # CONFIG_JBD2_DEBUG is not set
 CONFIG_FS_MBCACHE=y
@@ -1999,7 +2546,7 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_GFS2_FS is not set
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FS_POSIX_ACL=y
 CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 # CONFIG_DNOTIFY is not set
@@ -2041,11 +2588,9 @@ CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
 # CONFIG_TMPFS_POSIX_ACL is not set
-# CONFIG_TMPFS_XATTR is not set
 # CONFIG_HUGETLB_PAGE is not set
 # CONFIG_CONFIGFS_FS is not set
 CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
 # CONFIG_AFFS_FS is not set
 # CONFIG_HFS_FS is not set
 # CONFIG_HFSPLUS_FS is not set
@@ -2071,12 +2616,9 @@ CONFIG_YAFFS_XATTR=y
 # CONFIG_VXFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_ROMFS_FS is not set
-# CONFIG_PSTORE is not set
 # CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
 # CONFIG_NFS_FS is not set
 # CONFIG_NFSD is not set
@@ -2087,6 +2629,8 @@ CONFIG_CIFS_WEAK_PW_HASH=y
 CONFIG_CIFS_XATTR=y
 CONFIG_CIFS_POSIX=y
 # CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_ACL is not set
+# CONFIG_CIFS_EXPERIMENTAL is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
 # CONFIG_AFS_FS is not set
@@ -2136,7 +2680,6 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 CONFIG_NLS_UTF8=y
-
 #
 # Kernel hacking
 #
@@ -2150,18 +2693,17 @@ CONFIG_MAGIC_SYSRQ=y
 # CONFIG_UNUSED_SYMBOLS is not set
 CONFIG_DEBUG_FS=y
 # CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_SECTION_MISMATCH=y
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_LOCKUP_DETECTOR is not set
 # CONFIG_HARDLOCKUP_DETECTOR is not set
-CONFIG_BOOTPARAM_HARDLOCKUP_PANIC=y
-CONFIG_BOOTPARAM_HARDLOCKUP_PANIC_VALUE=1
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
-# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
 # CONFIG_SCHED_DEBUG is not set
-CONFIG_SCHEDSTATS=y
+# CONFIG_SCHEDSTATS is not set
 CONFIG_TIMER_STATS=y
 # CONFIG_DEBUG_OBJECTS is not set
 # CONFIG_DEBUG_SLAB is not set
@@ -2175,7 +2717,7 @@ CONFIG_TIMER_STATS=y
 # CONFIG_PROVE_LOCKING is not set
 # CONFIG_SPARSE_RCU_POINTER is not set
 # CONFIG_LOCK_STAT is not set
-# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+CONFIG_DEBUG_SPINLOCK_SLEEP=y
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 CONFIG_STACKTRACE=y
 # CONFIG_DEBUG_STACK_USAGE is not set
@@ -2191,9 +2733,10 @@ CONFIG_DEBUG_INFO=y
 # CONFIG_DEBUG_SG is not set
 # CONFIG_DEBUG_NOTIFIERS is not set
 # CONFIG_DEBUG_CREDENTIALS is not set
-CONFIG_FRAME_POINTER=y
 # CONFIG_BOOT_PRINTK_DELAY is not set
 # CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
 # CONFIG_BACKTRACE_SELF_TEST is not set
 # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
 # CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
@@ -2203,30 +2746,25 @@ CONFIG_FRAME_POINTER=y
 # CONFIG_SYSCTL_SYSCALL_CHECK is not set
 # CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_TRACING_SUPPORT=y
 # CONFIG_FTRACE is not set
 # CONFIG_DYNAMIC_DEBUG is not set
-# CONFIG_DMA_API_DEBUG is not set
 # CONFIG_ATOMIC64_SELFTEST is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
 # CONFIG_KGDB is not set
 # CONFIG_TEST_KSTRTOX is not set
 # CONFIG_STRICT_DEVMEM is not set
-# CONFIG_ARM_UNWIND is not set
+CONFIG_ARM_UNWIND=y
 # CONFIG_DEBUG_USER is not set
 # CONFIG_DEBUG_LL is not set
 # CONFIG_OC_ETM is not set
-# CONFIG_PID_IN_CONTEXTIDR is not set
 
 #
 # Security options
 #
-# CONFIG_KEYS is not set
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
 # CONFIG_SECURITY_DMESG_RESTRICT is not set
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
@@ -2245,6 +2783,7 @@ CONFIG_CRYPTO_BLKCIPHER=y
 CONFIG_CRYPTO_BLKCIPHER2=y
 CONFIG_CRYPTO_HASH=y
 CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
 CONFIG_CRYPTO_RNG2=y
 CONFIG_CRYPTO_PCOMP2=y
 CONFIG_CRYPTO_MANAGER=y
@@ -2287,7 +2826,7 @@ CONFIG_CRYPTO_HMAC=y
 #
 CONFIG_CRYPTO_CRC32C=y
 # CONFIG_CRYPTO_GHASH is not set
-CONFIG_CRYPTO_MD4=y
+# CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
 # CONFIG_CRYPTO_RMD128 is not set
@@ -2295,7 +2834,7 @@ CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_RMD256 is not set
 # CONFIG_CRYPTO_RMD320 is not set
 CONFIG_CRYPTO_SHA1=y
-# CONFIG_CRYPTO_SHA256 is not set
+CONFIG_CRYPTO_SHA256=y
 # CONFIG_CRYPTO_SHA512 is not set
 # CONFIG_CRYPTO_TGR192 is not set
 # CONFIG_CRYPTO_WP512 is not set
@@ -2334,11 +2873,8 @@ CONFIG_CRYPTO_DEFLATE=y
 # CONFIG_CRYPTO_USER_API_HASH is not set
 # CONFIG_CRYPTO_USER_API_SKCIPHER is not set
 CONFIG_CRYPTO_HW=y
-# CONFIG_CRYPTO_DEV_QCRYPTO is not set
-# CONFIG_CRYPTO_DEV_QCE is not set
-# CONFIG_CRYPTO_DEV_QCEDEV is not set
-# CONFIG_CRYPTO_DEV_OTA_CRYPTO is not set
-# CONFIG_BINARY_PRINTF is not set
+CONFIG_BINARY_PRINTF=y
+
 
 #
 # Library routines
diff --git a/arch/arm/mach-msm/Kconfig b/arch/arm/mach-msm/Kconfig
index dd0ae09..0fcaef6 100644
--- a/arch/arm/mach-msm/Kconfig
+++ b/arch/arm/mach-msm/Kconfig
@@ -1219,13 +1219,6 @@ config HTC_BATTCHG_SMEM
         default n
         bool "Read Battery Info via SMEM"
 
-config HTC_PWRSPLY
-	depends on MSM_ONCRPCROUTER && POWER_SUPPLY && !TROUT_BATTCHG
-	default y
-	bool "HTC Power supply driver"
-	help
-	  Used by HTC devices with a dedicated battery gauge"
-
 config HTC_PWRSINK
 	depends on MSM_SMD
 	default n
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index 8b0d999..6cd86c2 100644
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -174,6 +174,7 @@ obj-$(CONFIG_MSM7KV2_AUDIO) += htc_acoustic_7x30.o htc_acdb_7x30.o
 ifndef CONFIG_MACH_HTCLEO
 obj-$(CONFIG_MSM_QDSP6) += qdsp6/
 else
+obj-y += dex_comm.o
 obj-$(CONFIG_MSM_QDSP6) += qdsp6_1550/
 endif
 obj-$(CONFIG_MSM8X60_AUDIO) += qdsp6v2_1x/
@@ -321,9 +322,9 @@ obj-$(CONFIG_MACH_BRAVO) += board-bravo-keypad.o board-bravo-mmc.o
 obj-$(CONFIG_MACH_BRAVO) += board-bravo-rfkill.o htc_wifi_nvs.o htc_awb_cal.o
 obj-$(CONFIG_MACH_BRAVO) += board-bravo-wifi.o board-bravo-audio.o
 obj-$(CONFIG_MACH_BRAVO) += msm_vibrator.o devices_htc.o htc_35mm_jack.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo-microp.o htc_acoustic_qsd.o
+obj-$(CONFIG_MACH_BRAVO) += board-bravo-microp.o htc_acoustic_qsd.o htc_power_supply.o htc_set_perflock.o
 obj-$(CONFIG_MACH_BRAVO) += board-bravo-tpa2018d1.o msm_flashlight.o
-obj-$(CONFIG_MACH_BRAVO) += board-bravo-smb329.o
+obj-$(CONFIG_MACH_BRAVO) += board-bravo-smb329.o dex_comm.o
 
 ifeq ($(CONFIG_ARCH_MSM8X60_LTE),y)
 obj-$(CONFIG_ARCH_MSM8X60_LTE) += 8x60-lte/
@@ -542,7 +543,7 @@ obj-$(CONFIG_ARCH_FSM9XXX) += board-fsm9xxx.o
 obj-$(CONFIG_HTC_BATTCHG) += htc_battery.o
 obj-$(CONFIG_HTC_BATT_CORE) += htc_battery_core.o
 obj-$(CONFIG_HTC_BATT8x60) += htc_battery_8x60.o
-obj-$(CONFIG_HTC_PWRSPLY) += htc_power_supply.o
+
 obj-$(CONFIG_HTC_PWRSINK) += htc_pwrsink.o
 obj-$(CONFIG_HTC_HEADSET_MGR) += htc_headset_mgr.o
 obj-$(CONFIG_HTC_HEADSET_H2W) += htc_headset_h2w.o
diff --git a/arch/arm/mach-msm/board-bravo-audio.c b/arch/arm/mach-msm/board-bravo-audio.c
index 4eac04e..0cc046d 100644
--- a/arch/arm/mach-msm/board-bravo-audio.c
+++ b/arch/arm/mach-msm/board-bravo-audio.c
@@ -25,7 +25,7 @@
 #include "board-bravo-tpa2018d1.h"
 
 #include "dex_comm.h"
-
+/*
 static void config_gpio_table(uint32_t *table, int len)
 {
 	int n, rc;
@@ -37,8 +37,8 @@ static void config_gpio_table(uint32_t *table, int len)
 			break;
 		}
 	}
-}
-
+}	
+*/
 #if 0
 #define D(fmt, args...) printk(KERN_INFO "Audio: "fmt, ##args)
 #else
diff --git a/arch/arm/mach-msm/board-bravo-mmc.c b/arch/arm/mach-msm/board-bravo-mmc.c
index 5a023b9..3f4c5ce 100644
--- a/arch/arm/mach-msm/board-bravo-mmc.c
+++ b/arch/arm/mach-msm/board-bravo-mmc.c
@@ -35,7 +35,7 @@
 #include "proc_comm.h"
 
 #undef BRAVO_DEBUG_MMC
-
+/*
 static void config_gpio_table(uint32_t *table, int len)
 {
 	int n, rc;
@@ -47,8 +47,8 @@ static void config_gpio_table(uint32_t *table, int len)
 			break;
 		}
 	}
-}
-
+}	
+*/
 static bool opt_disable_sdcard;
 static int __init bravo_disablesdcard_setup(char *str)
 {
diff --git a/arch/arm/mach-msm/board-bravo-rfkill.c b/arch/arm/mach-msm/board-bravo-rfkill.c
index f8f24f4..9b36514 100644
--- a/arch/arm/mach-msm/board-bravo-rfkill.c
+++ b/arch/arm/mach-msm/board-bravo-rfkill.c
@@ -89,7 +89,6 @@ static int bravo_rfkill_remove(struct platform_device *dev)
 	rfkill_destroy(bt_rfk);
 	gpio_free(BRAVO_GPIO_BT_SHUTDOWN_N);
 	gpio_free(BRAVO_GPIO_BT_RESET_N);
-
 	return 0;
 }
 
diff --git a/arch/arm/mach-msm/board-bravo.c b/arch/arm/mach-msm/board-bravo.c
old mode 100644
new mode 100755
index 15600a7..dcccaec
--- a/arch/arm/mach-msm/board-bravo.c
+++ b/arch/arm/mach-msm/board-bravo.c
@@ -88,10 +88,10 @@
 #ifdef CONFIG_OPTICALJOYSTICK_CRUCIAL
 #include <linux/curcial_oj.h>
 #endif
-
+/*
 #define SMEM_SPINLOCK_I2C	"S:6"
 
-/* Kernel 3 stuff by shaky */
+/* Kernel 3 stuff by shaky 
 
 #define GPIO_ENABLE	0
 #define GPIO_DISABLE	1
@@ -119,7 +119,7 @@
 		(((dir) & 0x1) << 14)		| \
 		(((pull) & 0x3) << 15)		| \
 		(((drvstr) & 0xF) << 17))
-
+/*
 static void config_gpio_table(uint32_t *table, int len)
 {
 	int n, rc;
@@ -145,6 +145,11 @@ extern void __init bravo_audio_init(void);
 extern int microp_headset_has_mic(void);
 static unsigned int engineerid;
 
+
+///////////////////////////////////////////////////////////////////////
+// KGSL (HW3D support)#include <linux/android_pmem.h>
+///////////////////////////////////////////////////////////////////////
+
 /* start kgsl */
 static struct resource kgsl_3d0_resources[] = {
 	{
@@ -199,103 +204,108 @@ struct platform_device msm_kgsl_3d0 = {
 struct platform_device *msm_footswitch_devices[] = {
 	FS_PCOM(FS_GFX3D,  "fs_gfx3d"),
 };
-
 unsigned msm_num_footswitch_devices = ARRAY_SIZE(msm_footswitch_devices);
 /* end footswitch regulator */
 
-#define MSM_PMEM_SF_SIZE  0x1700000
-#define MSM_AUDIO_SIZE    0x80000
+///////////////////////////////////////////////////////////////////////
+// Memory
+///////////////////////////////////////////////////////////////////////
+
+#define MSM_PMEM_SF_SIZE	0x1700000
+#define MSM_AUDIO_SIZE		0x80000
 
 static struct android_pmem_platform_data android_pmem_kernel_ebi1_pdata = {
-  .name = PMEM_KERNEL_EBI1_DATA_NAME,
-  /* if no allocator_type, defaults to PMEM_ALLOCATORTYPE_BITMAP,
-   * the only valid choice at this time. The board structure is
-   * set to all zeros by the C runtime initialization and that is now
-   * the enum value of PMEM_ALLOCATORTYPE_BITMAP, now forced to 0 in
-   * include/linux/android_pmem.h.
-   */
-  .cached = 0,
+	.name = PMEM_KERNEL_EBI1_DATA_NAME,
+	/* if no allocator_type, defaults to PMEM_ALLOCATORTYPE_BITMAP,
+	 * the only valid choice at this time. The board structure is
+	 * set to all zeros by the C runtime initialization and that is now
+	 * the enum value of PMEM_ALLOCATORTYPE_BITMAP, now forced to 0 in
+	 * include/linux/android_pmem.h.
+	 */
+	.cached = 0,
 };
 
 #ifdef CONFIG_KERNEL_PMEM_SMI_REGION
 
 static struct android_pmem_platform_data android_pmem_kernel_smi_pdata = {
-  .name = PMEM_KERNEL_SMI_DATA_NAME,
-  /* if no allocator_type, defaults to PMEM_ALLOCATORTYPE_BITMAP,
-   * the only valid choice at this time. The board structure is
-   * set to all zeros by the C runtime initialization and that is now
-   * the enum value of PMEM_ALLOCATORTYPE_BITMAP, now forced to 0 in
-   * include/linux/android_pmem.h.
-   */
-  .cached = 0,
+	.name = PMEM_KERNEL_SMI_DATA_NAME,
+	/* if no allocator_type, defaults to PMEM_ALLOCATORTYPE_BITMAP,
+	 * the only valid choice at this time. The board structure is
+	 * set to all zeros by the C runtime initialization and that is now
+	 * the enum value of PMEM_ALLOCATORTYPE_BITMAP, now forced to 0 in
+	 * include/linux/android_pmem.h.
+	 */
+	.cached = 0,
 };
 
 #endif
 
 static struct android_pmem_platform_data android_pmem_pdata = {
-    .name = "pmem",
-    .allocator_type = PMEM_ALLOCATORTYPE_ALLORNOTHING,
-    .cached = 1,
-    .memory_type = MEMTYPE_EBI1,
+	.name = "pmem",
+	.allocator_type = PMEM_ALLOCATORTYPE_ALLORNOTHING,
+	.cached = 1,
+	.memory_type = MEMTYPE_EBI1,
 };
 
 static struct android_pmem_platform_data android_pmem_adsp_pdata = {
-	.name		= "pmem_adsp",
+	.name = "pmem_adsp",
 	.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
-	.cached		= 1,
-    .memory_type    = MEMTYPE_EBI1,
+	.cached = 1,
+	.memory_type = MEMTYPE_EBI1,
 };
 
 static struct android_pmem_platform_data android_pmem_venc_pdata = {
-	.name		= "pmem_venc",
+	.name = "pmem_venc",
 	.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
-	.cached		= 1,
-    .memory_type = MEMTYPE_EBI1,
+	.cached = 1,
+	.memory_type = MEMTYPE_EBI1,
 };
 
 static struct android_pmem_platform_data android_pmem_audio_pdata = {
-    .name = "pmem_audio",
-    .allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
-    .cached = 0,
-    .memory_type = MEMTYPE_EBI1,
+	.name = "pmem_audio",
+	.allocator_type = PMEM_ALLOCATORTYPE_BITMAP,
+	.cached = 0,
+	.memory_type = MEMTYPE_EBI1,
 };
 
+
 static struct platform_device android_pmem_device = {
-    .name = "android_pmem",
-    .id = 0,
-    .dev = { .platform_data = &android_pmem_pdata },
+	.name = "android_pmem",
+	.id = 0,
+	.dev = { .platform_data = &android_pmem_pdata },
 };
 
 static struct platform_device android_pmem_adsp_device = {
-    .name = "android_pmem",
-    .id = 1,
-    .dev = { .platform_data = &android_pmem_adsp_pdata },
+	.name = "android_pmem",
+	.id = 1,
+	.dev = { .platform_data = &android_pmem_adsp_pdata },
 };
 
 static struct platform_device android_pmem_audio_device = {
-    .name = "android_pmem",
-    .id = 2,
-    .dev = { .platform_data = &android_pmem_audio_pdata },
+	.name = "android_pmem",
+	.id = 2,
+	.dev = { .platform_data = &android_pmem_audio_pdata },
 };
 /*
 static struct platform_device android_pmem_kernel_ebi1_device = {
-    .name = "android_pmem",
-    .id = 3,
-    .dev = { .platform_data = &android_pmem_kernel_ebi1_pdata },
+	.name = "android_pmem",
+	.id = 3,
+	.dev = { .platform_data = &android_pmem_kernel_ebi1_pdata },
 };
 */
+
 #ifdef CONFIG_KERNEL_PMEM_SMI_REGION
 static struct platform_device android_pmem_kernel_smi_device = {
-    .name = "android_pmem",
-    .id = 4,
-    .dev = { .platform_data = &android_pmem_kernel_smi_pdata },
+	.name = "android_pmem",
+	.id = 4,
+	.dev = { .platform_data = &android_pmem_kernel_smi_pdata },
 };
 #endif
 
 static struct platform_device android_pmem_venc_device = {
-    .name = "android_pmem",
-    .id = 5,
-    .dev = { .platform_data = &android_pmem_venc_pdata },
+	.name = "android_pmem",
+	.id = 5,
+	.dev = { .platform_data = &android_pmem_venc_pdata },
 };
 
 static unsigned pmem_kernel_ebi1_size = PMEM_KERNEL_EBI1_SIZE;
@@ -421,6 +431,14 @@ static void __init qsd8x50_reserve(void)
 	msm_reserve();
 }
 
+///////////////////////////////////////////////////////////////////////
+// Real Time Clock
+///////////////////////////////////////////////////////////////////////
+
+struct platform_device msm_device_rtc = {
+	.name = "msm_rtc",
+	.id = -1,
+};
 
 static int bravo_phy_init_seq[] = {
 	0x0C, 0x31,
@@ -1010,6 +1028,34 @@ static struct platform_device bravo_flashlight_device = {
 	},
 };
 
+
+static struct timed_gpio timed_gpios[] = {
+	{
+		.name = "vibrator",
+		.gpio = BRAVO_GPIO_VIBRATOR_ON,
+		.max_timeout = 15000,
+	},
+};
+
+static struct timed_gpio_platform_data timed_gpio_data = {
+	.num_gpios	= ARRAY_SIZE(timed_gpios),
+	.gpios		= timed_gpios,
+};
+
+static struct platform_device bravo_timed_gpios = {
+	.name		= "timed-gpio",
+	.id		= -1,
+	.dev		= {
+		.platform_data = &timed_gpio_data,
+	},
+};
+
+static struct msm_serial_hs_platform_data msm_uart_dm1_pdata = {
+	.rx_wakeup_irq = -1,
+	.inject_rx_on_wakeup = 0,
+	.exit_lpm_cb = bcm_bt_lpm_exit_lpm_locked,
+};
+
 static struct bcm_bt_lpm_platform_data bcm_bt_lpm_pdata = {
 	.gpio_wake = BRAVO_GPIO_BT_WAKE,
 	.gpio_host_wake = BRAVO_GPIO_BT_HOST_WAKE,
@@ -1790,7 +1836,7 @@ static void __init bravo_init(void)
         /* TODO: CDMA version */
 
         msm_gpios_enable(misc_gpio_table, ARRAY_SIZE(misc_gpio_table));
-
+/*
         if (is_cdma_version(system_rev)) {
             //bcm_bt_lpm_pdata.gpio_wake = BRAVO_CDMA_GPIO_BT_WAKE;
             //bravo_flashlight_data.torch = BRAVO_CDMA_GPIO_FLASHLIGHT_TORCH;
@@ -1808,24 +1854,30 @@ static void __init bravo_init(void)
 	gpio_direction_input(BRAVO_GPIO_COMPASS_INT_N);
 
 	gpio_request(BRAVO_GPIO_DS2482_SLP_N, "ds2482_slp_n");
+*/
+        msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
+	msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
 
-        //msm_device_hsusb.dev.platform_data = &msm_hsusb_pdata;
-	//msm_device_uart_dm1.dev.platform_data = &msm_uart_dm1_pdata;
+	config_gpio_table(bt_gpio_table, ARRAY_SIZE(bt_gpio_table));
 
 	platform_add_devices(devices, ARRAY_SIZE(devices));
 
+	platform_add_devices(msm_footswitch_devices,
+			msm_num_footswitch_devices);
+
         msm_device_i2c_init();
 	msm_qsd_spi_init();
-	i2c_register_board_info(0, base_i2c_devices,
-                                ARRAY_SIZE(base_i2c_devices));
-	spi_register_board_info(msm_spi_board_info,
-				ARRAY_SIZE(msm_spi_board_info));
 
+	i2c_register_board_info(0, base_i2c_devices, ARRAY_SIZE(base_i2c_devices));
+	spi_register_board_info(msm_spi_board_info, ARRAY_SIZE(msm_spi_board_info));
+/*
         if (is_cdma_version(system_rev)) {
             i2c_register_board_info(0, rev_CX_i2c_devices,
                                     ARRAY_SIZE(rev_CX_i2c_devices));
 	}
 
+	i2c_register_board_info(0, base_i2c_devices, ARRAY_SIZE(base_i2c_devices));
+*/
 	ret = bravo_init_mmc(system_rev, debug_uart);
 	if (ret != 0)
 		pr_crit("%s: Unable to initialize MMC\n", __func__);
@@ -1834,10 +1886,12 @@ static void __init bravo_init(void)
 	//BUG_ON(msm_pm_boot_init(&msm_pm_boot_pdata));
 	//msm_pm_register_irqs();
 
+	bravo_audio_init();
+
         bravo_headset_init();
 
         ds2784_battery_init();
-        bravo_reset();
+        //bravo_reset();
 }
 
 static void __init bravo_fixup(struct machine_desc *desc, struct tag *tags,
@@ -1875,8 +1929,10 @@ MACHINE_START(BRAVO, "bravo")
 MACHINE_START(BRAVOC, "bravoc")
 #endif
     .boot_params = 0x20000100,
+//    .boot_params = (CONFIG_PHYS_OFFSET + 0x00000100),
     .fixup = bravo_fixup,
     .map_io = bravo_map_io,
+    .reserve	= qsd8x50_reserve,
     .init_irq = bravo_init_irq,
     .init_machine = bravo_init,
     .timer = &msm_timer,
diff --git a/arch/arm/mach-msm/board-mahimahi.h b/arch/arm/mach-msm/board-mahimahi.h
index 9696a47..3d8a364 100644
--- a/arch/arm/mach-msm/board-mahimahi.h
+++ b/arch/arm/mach-msm/board-mahimahi.h
@@ -21,33 +21,30 @@
 #define MSM_SMI_BASE		0x02B00000
 #define MSM_SMI_SIZE		0x01500000
 
+#define MSM_PMEM_VENC_BASE      0x02B00000
+#define MSM_PMEM_VENC_SIZE      0x00800000
+
+#define MSM_GPU_MEM_BASE        0x03300000
+#define MSM_GPU_MEM_SIZE        0x00500000
+
 #define MSM_RAM_CONSOLE_BASE	0x03A00000
 #define MSM_RAM_CONSOLE_SIZE	0x00040000
 
 #define MSM_FB_BASE		0x03B00000
-#define MSM_FB_SIZE		0x00465000
-
-#define MSM_EBI1_BANK0_BASE	0x20000000
-#define MSM_EBI1_BANK0_SIZE	0x0E000000
+#define MSM_FB_SIZE		0x00300000
 
-#define MSM_GPU_MEM_BASE	0x2DB00000
-#define MSM_GPU_MEM_SIZE	0x00500000
+#define MSM_EBI1_BANK0_BASE  0x20000000
+#define MSM_EBI1_BANK0_SIZE  0x0E800000
 
 #define MSM_EBI1_BANK1_BASE	0x30000000
-#define MSM_EBI1_BANK1_SIZE	0x10000000
+#define MSM_EBI1_BANK1_SIZE	0x0B700000
 
-#define MSM_PMEM_MDP_BASE	0x30000000
+#define MSM_PMEM_MDP_BASE	0x3B700000
 #define MSM_PMEM_MDP_SIZE	0x02000000
 
-#define MSM_PMEM_ADSP_BASE	0x32000000
+#define MSM_PMEM_ADSP_BASE	0x3D700000
 #define MSM_PMEM_ADSP_SIZE	0x02900000
 
-#define MSM_PMEM_CAMERA_BASE	0x34900000
-#define MSM_PMEM_CAMERA_SIZE	0x00800000
-
-#define MSM_HIGHMEM_BASE	0x35100000
-#define MSM_HIGHMEM_SIZE	0x0AF00000
-
 #define MAHIMAHI_GPIO_PS_HOLD		25
 
 #define MAHIMAHI_GPIO_UP_INT_N		35
diff --git a/arch/arm/mach-msm/dex_comm.c b/arch/arm/mach-msm/dex_comm.c
index 01a65a6..e1c8f4b 100644
--- a/arch/arm/mach-msm/dex_comm.c
+++ b/arch/arm/mach-msm/dex_comm.c
@@ -28,7 +28,13 @@
 #include <asm/mach-types.h>
 
 #include "dex_comm.h"
-
+static int inited;
+static struct work_struct vbus_work;
+void notify_vbus_change_intr(void)  
+{  
+    if (!inited)    return;  
+    schedule_work(&vbus_work);  
+}
 
 // from board-htcleo-power.c
 void notify_vbus_change_intr(void);
diff --git a/arch/arm/mach-msm/htc_battery.c b/arch/arm/mach-msm/htc_battery.c
index 1e86d59..5571c93 100644
--- a/arch/arm/mach-msm/htc_battery.c
+++ b/arch/arm/mach-msm/htc_battery.c
@@ -48,7 +48,6 @@
 #endif
 
 static struct wake_lock vbus_wake_lock;
-extern void notify_usb_connected(int);
 enum {
 	HTC_BATT_DEBUG_M2A_RPC = 1U << 0,
 	HTC_BATT_DEBUG_A2M_RPC = 1U << 1,
@@ -597,42 +596,6 @@ EXPORT_SYMBOL(htc_get_usb_accessory_adc_level);
 /* A9 reports USB charging when helf AC cable in and China AC charger. */
 /* notify userspace USB charging first,
 and then usb driver will notify AC while D+/D- Line short. */
-void notify_usb_connected(int online)
-{
-#if 1
-	pr_info("batt:online=%d",online);
-	/* TODO: replace charging_source to usb_status */
-	htc_batt_info.rep.charging_source = online;
-	htc_set_smem_cable_type(htc_batt_info.rep.charging_source);
-
-	/* TODO: use power_supply_change to notify battery drivers. */
-	if (htc_batt_info.guage_driver == GUAGE_DS2784 || htc_batt_info.guage_driver == GUAGE_DS2746)
-		blocking_notifier_call_chain(&cable_status_notifier_list,
-			htc_batt_info.rep.charging_source, NULL);
-
-	if (htc_battery_initial) {
-		power_supply_changed(&htc_power_supplies[CHARGER_AC]);
-		power_supply_changed(&htc_power_supplies[CHARGER_USB]);
-		power_supply_changed(&htc_power_supplies[CHARGER_BATTERY]);
-	} else {
-		pr_err("\n\n ### htc_battery_code is not inited yet! ###\n\n");
-	}
-	update_wake_lock(htc_batt_info.rep.charging_source);
-#else
-	mutex_lock(&htc_batt_info.lock);
-	if (htc_batt_debug_mask & HTC_BATT_DEBUG_USB_NOTIFY)
-		BATT_LOG("%s: online=%d, g_usb_online=%d", __func__, online, g_usb_online);
-	if (g_usb_online != online) {
-		g_usb_online = online;
-		if (online == CHARGER_AC && htc_batt_info.rep.charging_source == CHARGER_USB) {
-			mutex_unlock(&htc_batt_info.lock);
-			htc_cable_status_update(CHARGER_AC);
-			mutex_lock(&htc_batt_info.lock);
-		}
-	}
-	mutex_unlock(&htc_batt_info.lock);
-#endif
-}
 
 static int htc_get_batt_info(struct battery_info_reply *buffer)
 {
diff --git a/arch/arm/mach-msm/include/mach/gpio.h b/arch/arm/mach-msm/include/mach/gpio.h
index a0cdb20..9f5d08c 100644
--- a/arch/arm/mach-msm/include/mach/gpio.h
+++ b/arch/arm/mach-msm/include/mach/gpio.h
@@ -30,7 +30,7 @@
  * see /arch/arm/mach-msm/gpio.c for implementation
  * it's not generic_gpio.c as stated in older files
  */
-//extern void config_gpio_table(uint32_t *table, int len);
+extern void config_gpio_table(uint32_t *table, int len);
 extern int gpio_configure(unsigned int gpio, unsigned long flags);
 
 extern struct irq_chip msm_gpio_irq_extn;
diff --git a/arch/arm/mach-msm/include/mach/msm_iomap-8x50.h b/arch/arm/mach-msm/include/mach/msm_iomap-8x50.h
index 639a7f5..bfba69d 100644
--- a/arch/arm/mach-msm/include/mach/msm_iomap-8x50.h
+++ b/arch/arm/mach-msm/include/mach/msm_iomap-8x50.h
@@ -144,9 +144,6 @@
 #define MSM_MDP_PHYS          0xAA200000
 #define MSM_MDP_SIZE          0x000F0000
 
-#define MSM_NAND_PHYS		0xA0A00000
-#define MSM_NAND_SIZE         SZ_4K
-
 #define MSM_MDC_BASE	      IOMEM(0xF8200000)
 #define MSM_MDC_PHYS	      0xAA500000
 #define MSM_MDC_SIZE	      SZ_1M
diff --git a/arch/microblaze/boot/dts/system.dts b/arch/microblaze/boot/dts/system.dts
deleted file mode 120000
index 7cb6578..0000000
--- a/arch/microblaze/boot/dts/system.dts
+++ /dev/null
@@ -1 +0,0 @@
-../../platform/generic/system.dts
\ No newline at end of file
diff --git a/arch/sh/boot/compressed/vmlinux.scr b/arch/sh/boot/compressed/vmlinux.scr
deleted file mode 100644
index 862d748..0000000
--- a/arch/sh/boot/compressed/vmlinux.scr
+++ /dev/null
@@ -1,10 +0,0 @@
-SECTIONS
-{
-  .rodata..compressed : {
-	input_len = .;
-	LONG(input_data_end - input_data) input_data = .;
-	*(.data)
-	output_len = . - 4;
-	input_data_end = .;
-	}
-}
diff --git a/arch/sh/boot/romimage/vmlinux.scr b/arch/sh/boot/romimage/vmlinux.scr
deleted file mode 100644
index 590394e..0000000
--- a/arch/sh/boot/romimage/vmlinux.scr
+++ /dev/null
@@ -1,8 +0,0 @@
-SECTIONS
-{
-  .text : {
-	zero_page_pos = .;
-	*(.data)
-	end_data = .;
-	}
-}
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index ec865ab..a20a056 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -33,3 +33,4 @@ hci_uart-$(CONFIG_BT_HCIUART_IBS)	+= hci_ibs.o
 hci_uart-objs				:= $(hci_uart-y)
 obj-$(CONFIG_BT_MSM_SLEEP)              += msm_bt_sleep.o
 msm_bt_sleep-objs                       := bluesleep.o
+obj-$(CONFIG_MSM_BT_POWER)		+= bluetooth-power.o
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index e2fc2d2..c044060 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff --git a/drivers/i2c/busses/i2c-msm.c b/drivers/i2c/busses/i2c-msm.c
index 4d28543..bf814bb 100644
--- a/drivers/i2c/busses/i2c-msm.c
+++ b/drivers/i2c/busses/i2c-msm.c
@@ -701,7 +701,7 @@ msm_i2c_probe(struct platform_device *pdev)
 //   Change order of operations in this function.
 //
 
-#ifdef CONFIG_MACH_HTCLEO
+#ifdef CONFIG_MACH_BRAVO
 
 	i2c_set_adapdata(&dev->adap_pri, dev);
 	dev->adap_pri.algo = &msm_i2c_algo;
diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index 1b48dae..af65140f 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -59,6 +59,14 @@ config MTD_MSM_NAND
 	help
 	  Support for some NAND chips connected to the MSM NAND controller.
 
+config MTD_HTCLEO_NAND
+	tristate "HTCLEO NAND Device Support"
+	depends on MTD && ARCH_MSM
+	select MTD_NAND_IDS
+	default y
+	help
+	  Support for some NAND chips connected to the HTC LEO NAND controller.
+
 config MTD_DATAFLASH
 	tristate "Support for AT45xxx DataFlash"
 	depends on SPI_MASTER && EXPERIMENTAL
diff --git a/drivers/mtd/devices/msm_nand.c b/drivers/mtd/devices/msm_nand.c
old mode 100644
new mode 100755
index 0e4c0bf..2479a11
--- a/drivers/mtd/devices/msm_nand.c
+++ b/drivers/mtd/devices/msm_nand.c
@@ -1,6 +1,6 @@
-/* drivers/mtd/devices/msm_nand.c
- *
+/*
  * Copyright (C) 2007 Google, Inc.
+ * Copyright (c) 2008-2012, Code Aurora Forum. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -13,17 +13,18 @@
  *
  */
 
+#include <linux/slab.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 #include <linux/platform_device.h>
 #include <linux/sched.h>
-#include <linux/slab.h>
 #include <linux/dma-mapping.h>
 #include <linux/io.h>
-#include <linux/moduleparam.h>
-#include <linux/stat.h>
+#include <linux/crc16.h>
+#include <linux/bitrev.h>
 
 #include <asm/dma.h>
 #include <asm/mach/flash.h>
@@ -32,28 +33,36 @@
 
 #include "msm_nand.h"
 
-#define MSM_NAND_DMA_BUFFER_SIZE SZ_4K
+unsigned long msm_nand_phys;
+unsigned long msm_nandc01_phys;
+unsigned long msm_nandc10_phys;
+unsigned long msm_nandc11_phys;
+unsigned long ebi2_register_base;
+uint32_t dual_nand_ctlr_present;
+uint32_t interleave_enable;
+uint32_t enable_bch_ecc;
+
+#define MSM_NAND_DMA_BUFFER_SIZE SZ_8K
 #define MSM_NAND_DMA_BUFFER_SLOTS \
 	(MSM_NAND_DMA_BUFFER_SIZE / (sizeof(((atomic_t *)0)->counter) * 8))
 
-#define SUPPORT_WRONG_ECC_CONFIG 1
+#define MSM_NAND_CFG0_RAW_ONFI_IDENTIFIER 0x88000800
+#define MSM_NAND_CFG0_RAW_ONFI_PARAM_INFO 0x88040000
+#define MSM_NAND_CFG1_RAW_ONFI_IDENTIFIER 0x0005045d
+#define MSM_NAND_CFG1_RAW_ONFI_PARAM_INFO 0x0005045d
 
-#define MSM_NAND_CFG0_RAW 0xA80420C0
-#define MSM_NAND_CFG1_RAW 0x5045D
+#define ONFI_IDENTIFIER_LENGTH 0x0004
+#define ONFI_PARAM_INFO_LENGTH 0x0200
+#define ONFI_PARAM_PAGE_LENGTH 0x0100
 
-#define VERBOSE 0
+#define ONFI_PARAMETER_PAGE_SIGNATURE 0x49464E4F
 
-static struct nand_hw_info *nand_info;
-struct nand_hw_info {
-	uint32_t flash_id;
-	uint8_t maker_id;
-	uint8_t maker_name[10];
-	uint8_t width;
-	uint32_t size;
-	uint32_t block_count;
-	uint32_t page_count;
-	uint32_t page_size;
-};
+#define FLASH_READ_ONFI_IDENTIFIER_COMMAND 0x90
+#define FLASH_READ_ONFI_IDENTIFIER_ADDRESS 0x20
+#define FLASH_READ_ONFI_PARAMETERS_COMMAND 0xEC
+#define FLASH_READ_ONFI_PARAMETERS_ADDRESS 0x00
+
+#define VERBOSE 0
 
 struct msm_nand_chip {
 	struct device *dev;
@@ -62,28 +71,15 @@ struct msm_nand_chip {
 	unsigned dma_channel;
 	uint8_t *dma_buffer;
 	dma_addr_t dma_addr;
-	unsigned CFG0, CFG1;
-	unsigned page_shift;
-	unsigned last_sector;
-	unsigned last_sectorsz;
-#if SUPPORT_WRONG_ECC_CONFIG
+	unsigned CFG0, CFG1, CFG0_RAW, CFG1_RAW;
 	uint32_t ecc_buf_cfg;
-	uint32_t saved_ecc_buf_cfg;
-#endif
-	struct nand_hw_info dev_info;
+	uint32_t ecc_bch_cfg;
+	uint32_t ecc_parity_bytes;
+	unsigned cw_size;
 };
 
 #define CFG1_WIDE_FLASH (1U << 1)
 
-#ifdef CONFIG_ARCH_MSM7X30
-#define BUF_STAT_UNCORRECTABLE (1U << 8)
-#define BUF_STAT_NUM_ERRS_MASK (0xf)
-#else
-#define BUF_STAT_UNCORRECTABLE (1U << 3)
-#define BUF_STAT_NUM_ERRS_MASK (0x7)
-#endif
-
-
 /* TODO: move datamover code out */
 
 #define SRC_CRCI_NAND_CMD  CMD_SRC_CRCI(DMOV_NAND_CRCI_CMD)
@@ -92,29 +88,135 @@ struct msm_nand_chip {
 #define DST_CRCI_NAND_DATA CMD_DST_CRCI(DMOV_NAND_CRCI_DATA)
 
 #define msm_virt_to_dma(chip, vaddr) \
-	((void)(*(vaddr)), (chip)->dma_addr + \
+	((chip)->dma_addr + \
 	 ((uint8_t *)(vaddr) - (chip)->dma_buffer))
 
 /**
- * msm_nand_oob_64 - oob info for large (2KB) page
+ * msm_nand_oob_64 - oob info for 2KB page
  */
 static struct nand_ecclayout msm_nand_oob_64 = {
+	.eccbytes	= 40,
+	.eccpos		= {
+		0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
+		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+		46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
+		},
 	.oobavail	= 16,
 	.oobfree	= {
 		{30, 16},
 	}
 };
 
-/*
+/**
  * msm_nand_oob_128 - oob info for 4KB page
  */
 static struct nand_ecclayout msm_nand_oob_128 = {
-	.oobavail       = 32,
-	.oobfree        = {
+	.eccbytes	= 80,
+	.eccpos		= {
+		  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
+		 10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
+		 20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+		 30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
+		 40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
+		 50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
+		 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
+		102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
+		},
+	.oobavail	= 32,
+	.oobfree	= {
 		{70, 32},
 	}
 };
 
+/**
+ * msm_nand_oob_224 - oob info for 4KB page 8Bit interface
+ */
+static struct nand_ecclayout msm_nand_oob_224_x8 = {
+	.eccbytes	= 104,
+	.eccpos		= {
+		  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,
+		 13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,
+		 26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,
+		 39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,
+		 52,  53,  54,  55,  56,  57,  58,  59,	 60,  61,  62,  63,  64,
+		 65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,
+		 78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,
+		123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,
+		},
+	.oobavail	= 32,
+	.oobfree	= {
+		{91, 32},
+	}
+};
+
+/**
+ * msm_nand_oob_224 - oob info for 4KB page 16Bit interface
+ */
+static struct nand_ecclayout msm_nand_oob_224_x16 = {
+	.eccbytes	= 112,
+	.eccpos		= {
+	  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,
+	 14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,
+	 28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,
+	 42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,
+	 56,  57,  58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
+	 70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  81,  82,  83,
+	 84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95,  96,  97,
+	130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
+	},
+	.oobavail	= 32,
+	.oobfree	= {
+		{98, 32},
+	}
+};
+
+/**
+ * msm_nand_oob_256 - oob info for 8KB page
+ */
+static struct nand_ecclayout msm_nand_oob_256 = {
+	.eccbytes 	= 160,
+	.eccpos 	= {
+		  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
+		 10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
+		 20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+		 30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
+		 40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
+		 50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
+		 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
+		 70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
+		 80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
+		 90,  91,  92,  93,  94,  96,  97,  98 , 99, 100,
+		101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
+		111, 112, 113, 114, 115, 116, 117, 118, 119, 120,
+		121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
+		131, 132, 133, 134, 135, 136, 137, 138, 139, 140,
+		141, 142, 143, 144, 145, 146, 147, 148, 149, 150,
+		215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
+		},
+	.oobavail	= 64,
+	.oobfree	= {
+		{151, 64},
+	}
+};
+
+/**
+ * msm_onenand_oob_64 - oob info for large (2KB) page
+ */
+static struct nand_ecclayout msm_onenand_oob_64 = {
+	.eccbytes	= 20,
+	.eccpos		= {
+		8, 9, 10, 11, 12,
+		24, 25, 26, 27, 28,
+		40, 41, 42, 43, 44,
+		56, 57, 58, 59, 60,
+		},
+	.oobavail	= 20,
+	.oobfree	= {
+		{2, 3}, {14, 2}, {18, 3}, {30, 2},
+		{34, 3}, {46, 2}, {50, 3}, {62, 2}
+	}
+};
 
 static void *msm_nand_get_dma_buffer(struct msm_nand_chip *chip, size_t size)
 {
@@ -128,6 +230,11 @@ static void *msm_nand_get_dma_buffer(struct msm_nand_chip *chip, size_t size)
 	do {
 		free_index = __ffs(free_bitmask);
 		current_need_mask = need_mask << free_index;
+
+		if (size + free_index * MSM_NAND_DMA_BUFFER_SLOTS >=
+						 MSM_NAND_DMA_BUFFER_SIZE)
+			return NULL;
+
 		if ((bitmask & current_need_mask) == 0) {
 			old_bitmask =
 				atomic_cmpxchg(&chip->dma_buffer_busy,
@@ -161,112 +268,6 @@ static void msm_nand_release_dma_buffer(struct msm_nand_chip *chip,
 	wake_up(&chip->wait_queue);
 }
 
-uint32_t flash_read_id(struct msm_nand_chip *chip)
-{
-	struct {
-		dmov_s cmd[5];
-		unsigned cmdptr;
-		unsigned data[5];
-	} *dma_buffer;
-	uint32_t rv;
-
-	wait_event(chip->wait_queue,
-		   (dma_buffer = msm_nand_get_dma_buffer(
-			    chip, sizeof(*dma_buffer))));
-
-	dma_buffer->data[0] = 0 | 4;
-	dma_buffer->data[1] = MSM_NAND_CMD_FETCH_ID;
-	dma_buffer->data[2] = 1;
-	dma_buffer->data[3] = 0xeeeeeeee;
-	dma_buffer->data[4] = 0xeeeeeeee;
-	BUILD_BUG_ON(4 != ARRAY_SIZE(dma_buffer->data) - 1);
-
-	dma_buffer->cmd[0].cmd = 0 | CMD_OCB;
-	dma_buffer->cmd[0].src = msm_virt_to_dma(chip, &dma_buffer->data[0]);
-	dma_buffer->cmd[0].dst = MSM_NAND_FLASH_CHIP_SELECT;
-	dma_buffer->cmd[0].len = 4;
-
-	dma_buffer->cmd[1].cmd = DST_CRCI_NAND_CMD;
-	dma_buffer->cmd[1].src = msm_virt_to_dma(chip, &dma_buffer->data[1]);
-	dma_buffer->cmd[1].dst = MSM_NAND_FLASH_CMD;
-	dma_buffer->cmd[1].len = 4;
-
-	dma_buffer->cmd[2].cmd = 0;
-	dma_buffer->cmd[2].src = msm_virt_to_dma(chip, &dma_buffer->data[2]);
-	dma_buffer->cmd[2].dst = MSM_NAND_EXEC_CMD;
-	dma_buffer->cmd[2].len = 4;
-
-	dma_buffer->cmd[3].cmd = SRC_CRCI_NAND_DATA;
-	dma_buffer->cmd[3].src = MSM_NAND_FLASH_STATUS;
-	dma_buffer->cmd[3].dst = msm_virt_to_dma(chip, &dma_buffer->data[3]);
-	dma_buffer->cmd[3].len = 4;
-
-	dma_buffer->cmd[4].cmd = CMD_OCU | CMD_LC;
-	dma_buffer->cmd[4].src = MSM_NAND_READ_ID;
-	dma_buffer->cmd[4].dst = msm_virt_to_dma(chip, &dma_buffer->data[4]);
-	dma_buffer->cmd[4].len = 4;
-	BUILD_BUG_ON(4 != ARRAY_SIZE(dma_buffer->cmd) - 1);
-
-	dma_buffer->cmdptr =
-		(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) | CMD_PTR_LP;
-
-	msm_dmov_exec_cmd(
-		chip->dma_channel, DMOV_CMD_PTR_LIST |
-		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
-
-	rv = dma_buffer->data[4];
-	pr_info("msn_nand: nandid %x status %x\n", rv, dma_buffer->data[3]);
-	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
-	return rv;
-}
-
-int flash_read_config(struct msm_nand_chip *chip)
-{
-	struct {
-		dmov_s cmd[2];
-		unsigned cmdptr;
-		unsigned cfg0;
-		unsigned cfg1;
-	} *dma_buffer;
-
-	wait_event(chip->wait_queue,
-		   (dma_buffer = msm_nand_get_dma_buffer(
-			    chip, sizeof(*dma_buffer))));
-	dma_buffer->cfg0 = 0;
-	dma_buffer->cfg1 = 0;
-
-	dma_buffer->cmd[0].cmd = CMD_OCB;
-	dma_buffer->cmd[0].src = MSM_NAND_DEV0_CFG0;
-	dma_buffer->cmd[0].dst = msm_virt_to_dma(chip, &dma_buffer->cfg0);
-	dma_buffer->cmd[0].len = 4;
-
-	dma_buffer->cmd[1].cmd = CMD_OCU | CMD_LC;
-	dma_buffer->cmd[1].src = MSM_NAND_DEV0_CFG1;
-	dma_buffer->cmd[1].dst = msm_virt_to_dma(chip, &dma_buffer->cfg1);
-	dma_buffer->cmd[1].len = 4;
-	BUILD_BUG_ON(1 != ARRAY_SIZE(dma_buffer->cmd) - 1);
-
-	dma_buffer->cmdptr =
-		(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) | CMD_PTR_LP;
-
-	msm_dmov_exec_cmd(
-		chip->dma_channel, DMOV_CMD_PTR_LIST |
-		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
-
-	chip->CFG0 = dma_buffer->cfg0;
-	chip->CFG1 = dma_buffer->cfg1;
-	pr_info("msm_nand: read CFG0 = %x CFG1 = %x\n", chip->CFG0, chip->CFG1);
-	pr_info("msm_nand: CFG0 cw/page=%d ud_sz=%d ecc_sz=%d spare_sz=%d\n",
-		(chip->CFG0 >> 6) & 7, (chip->CFG0 >> 9) & 0x3ff,
-		(chip->CFG0 >> 19) & 15, (chip->CFG0 >> 23) & 15);
-
-	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
-
-	if ((chip->CFG0 == 0) || (chip->CFG1 == 0))
-		return -1;
-
-	return 0;
-}
 
 unsigned flash_rd_reg(struct msm_nand_chip *chip, unsigned addr)
 {
@@ -281,7 +282,7 @@ unsigned flash_rd_reg(struct msm_nand_chip *chip, unsigned addr)
 		   (dma_buffer = msm_nand_get_dma_buffer(
 			    chip, sizeof(*dma_buffer))));
 
-	dma_buffer->cmd.cmd = CMD_LC;
+	dma_buffer->cmd.cmd = CMD_LC | CMD_OCB | CMD_OCU;
 	dma_buffer->cmd.src = addr;
 	dma_buffer->cmd.dst = msm_virt_to_dma(chip, &dma_buffer->data);
 	dma_buffer->cmd.len = 4;
@@ -290,9 +291,12 @@ unsigned flash_rd_reg(struct msm_nand_chip *chip, unsigned addr)
 		(msm_virt_to_dma(chip, &dma_buffer->cmd) >> 3) | CMD_PTR_LP;
 	dma_buffer->data = 0xeeeeeeee;
 
+	mb();
 	msm_dmov_exec_cmd(
 		chip->dma_channel, DMOV_CMD_PTR_LIST |
 		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
+
 	rv = dma_buffer->data;
 
 	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
@@ -312,7 +316,7 @@ void flash_wr_reg(struct msm_nand_chip *chip, unsigned addr, unsigned val)
 		   (dma_buffer = msm_nand_get_dma_buffer(
 			    chip, sizeof(*dma_buffer))));
 
-	dma_buffer->cmd.cmd = CMD_LC;
+	dma_buffer->cmd.cmd = CMD_LC | CMD_OCB | CMD_OCU;
 	dma_buffer->cmd.src = msm_virt_to_dma(chip, &dma_buffer->data);
 	dma_buffer->cmd.dst = addr;
 	dma_buffer->cmd.len = 4;
@@ -321,9 +325,11 @@ void flash_wr_reg(struct msm_nand_chip *chip, unsigned addr, unsigned val)
 		(msm_virt_to_dma(chip, &dma_buffer->cmd) >> 3) | CMD_PTR_LP;
 	dma_buffer->data = val;
 
+	mb();
 	msm_dmov_exec_cmd(
 		chip->dma_channel, DMOV_CMD_PTR_LIST |
 		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
 
 	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
 }
@@ -344,42 +350,428 @@ msm_nand_dma_map(struct device *dev, void *addr, size_t size,
 	return dma_map_page(dev, page, offset, size, dir);
 }
 
-static int msm_nand_check_empty(struct mtd_info *mtd, struct mtd_oob_ops *ops,
-				unsigned long *uncorrected)
+uint32_t flash_read_id(struct msm_nand_chip *chip)
 {
-	unsigned int p, n, end;
-	uint8_t *datbuf = ops->datbuf;
-	uint8_t *oobbuf = ops->oobbuf;
-	size_t oobsize;
-	int page_count;
-
-	if (ops->mode == MTD_OOB_RAW)
-		return false;
-
-	page_count = ops->retlen / mtd->writesize;
-	oobsize = (ops->mode == MTD_OOB_AUTO) ? mtd->oobavail : mtd->oobsize;
-
-	for_each_set_bit(p, uncorrected, page_count) {
-		if (datbuf) {
-			datbuf = ops->datbuf + p * mtd->writesize;
-			for (n = 0; n < mtd->writesize; n++) {
-				/* empty blocks read 0x54 at these offsets */
-				if (datbuf[n] != ((n % 516 == 3) ? 0x54 : 0xff))
-					return false;
-			}
+	struct {
+		dmov_s cmd[7];
+		unsigned cmdptr;
+		unsigned data[7];
+	} *dma_buffer;
+	uint32_t rv;
+
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
+
+	dma_buffer->data[0] = 0 | 4;
+	dma_buffer->data[1] = MSM_NAND_CMD_FETCH_ID;
+	dma_buffer->data[2] = 1;
+	dma_buffer->data[3] = 0xeeeeeeee;
+	dma_buffer->data[4] = 0xeeeeeeee;
+	dma_buffer->data[5] = flash_rd_reg(chip, MSM_NAND_SFLASHC_BURST_CFG);
+	dma_buffer->data[6] = 0x00000000;
+	BUILD_BUG_ON(6 != ARRAY_SIZE(dma_buffer->data) - 1);
+
+	dma_buffer->cmd[0].cmd = 0 | CMD_OCB;
+	dma_buffer->cmd[0].src = msm_virt_to_dma(chip, &dma_buffer->data[6]);
+	dma_buffer->cmd[0].dst = MSM_NAND_SFLASHC_BURST_CFG;
+	dma_buffer->cmd[0].len = 4;
+
+	dma_buffer->cmd[1].cmd = 0;
+	dma_buffer->cmd[1].src = msm_virt_to_dma(chip, &dma_buffer->data[0]);
+	dma_buffer->cmd[1].dst = MSM_NAND_FLASH_CHIP_SELECT;
+	dma_buffer->cmd[1].len = 4;
+
+	dma_buffer->cmd[2].cmd = DST_CRCI_NAND_CMD;
+	dma_buffer->cmd[2].src = msm_virt_to_dma(chip, &dma_buffer->data[1]);
+	dma_buffer->cmd[2].dst = MSM_NAND_FLASH_CMD;
+	dma_buffer->cmd[2].len = 4;
+
+	dma_buffer->cmd[3].cmd = 0;
+	dma_buffer->cmd[3].src = msm_virt_to_dma(chip, &dma_buffer->data[2]);
+	dma_buffer->cmd[3].dst = MSM_NAND_EXEC_CMD;
+	dma_buffer->cmd[3].len = 4;
+
+	dma_buffer->cmd[4].cmd = SRC_CRCI_NAND_DATA;
+	dma_buffer->cmd[4].src = MSM_NAND_FLASH_STATUS;
+	dma_buffer->cmd[4].dst = msm_virt_to_dma(chip, &dma_buffer->data[3]);
+	dma_buffer->cmd[4].len = 4;
+
+	dma_buffer->cmd[5].cmd = 0;
+	dma_buffer->cmd[5].src = MSM_NAND_READ_ID;
+	dma_buffer->cmd[5].dst = msm_virt_to_dma(chip, &dma_buffer->data[4]);
+	dma_buffer->cmd[5].len = 4;
+
+	dma_buffer->cmd[6].cmd = CMD_OCU | CMD_LC;
+	dma_buffer->cmd[6].src = msm_virt_to_dma(chip, &dma_buffer->data[5]);
+	dma_buffer->cmd[6].dst = MSM_NAND_SFLASHC_BURST_CFG;
+	dma_buffer->cmd[6].len = 4;
+
+	BUILD_BUG_ON(6 != ARRAY_SIZE(dma_buffer->cmd) - 1);
+
+	dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd) >> 3
+			) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST |
+		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
+
+	pr_info("status: %x\n", dma_buffer->data[3]);
+	pr_info("nandid: %x maker %02x device %02x\n",
+	       dma_buffer->data[4], dma_buffer->data[4] & 0xff,
+	       (dma_buffer->data[4] >> 8) & 0xff);
+	rv = dma_buffer->data[4];
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+	return rv;
+}
+
+struct flash_identification {
+	uint32_t flash_id;
+	uint32_t density;
+	uint32_t widebus;
+	uint32_t pagesize;
+	uint32_t blksize;
+	uint32_t oobsize;
+	uint32_t ecc_correctability;
+} supported_flash;
+
+uint16_t flash_onfi_crc_check(uint8_t *buffer, uint16_t count)
+{
+	int i;
+	uint16_t result;
+
+	for (i = 0; i < count; i++)
+		buffer[i] = bitrev8(buffer[i]);
+
+	result = bitrev16(crc16(bitrev16(0x4f4e), buffer, count));
+
+	for (i = 0; i < count; i++)
+		buffer[i] = bitrev8(buffer[i]);
+
+	return result;
+}
+
+
+uint32_t flash_onfi_probe(struct msm_nand_chip *chip)
+{
+	struct onfi_param_page {
+		uint32_t parameter_page_signature;
+		uint16_t revision_number;
+		uint16_t features_supported;
+		uint16_t optional_commands_supported;
+		uint8_t  reserved0[22];
+		uint8_t  device_manufacturer[12];
+		uint8_t  device_model[20];
+		uint8_t  jedec_manufacturer_id;
+		uint16_t date_code;
+		uint8_t  reserved1[13];
+		uint32_t number_of_data_bytes_per_page;
+		uint16_t number_of_spare_bytes_per_page;
+		uint32_t number_of_data_bytes_per_partial_page;
+		uint16_t number_of_spare_bytes_per_partial_page;
+		uint32_t number_of_pages_per_block;
+		uint32_t number_of_blocks_per_logical_unit;
+		uint8_t  number_of_logical_units;
+		uint8_t  number_of_address_cycles;
+		uint8_t  number_of_bits_per_cell;
+		uint16_t maximum_bad_blocks_per_logical_unit;
+		uint16_t block_endurance;
+		uint8_t  guaranteed_valid_begin_blocks;
+		uint16_t guaranteed_valid_begin_blocks_endurance;
+		uint8_t  number_of_programs_per_page;
+		uint8_t  partial_program_attributes;
+		uint8_t  number_of_bits_ecc_correctability;
+		uint8_t  number_of_interleaved_address_bits;
+		uint8_t  interleaved_operation_attributes;
+		uint8_t  reserved2[13];
+		uint8_t  io_pin_capacitance;
+		uint16_t timing_mode_support;
+		uint16_t program_cache_timing_mode_support;
+		uint16_t maximum_page_programming_time;
+		uint16_t maximum_block_erase_time;
+		uint16_t maximum_page_read_time;
+		uint16_t maximum_change_column_setup_time;
+		uint8_t  reserved3[23];
+		uint16_t vendor_specific_revision_number;
+		uint8_t  vendor_specific[88];
+		uint16_t integrity_crc;
+
+	} __attribute__((__packed__));
+
+	struct onfi_param_page *onfi_param_page_ptr;
+	uint8_t *onfi_identifier_buf = NULL;
+	uint8_t *onfi_param_info_buf = NULL;
+
+	struct {
+		dmov_s cmd[11];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t exec;
+			uint32_t flash_status;
+			uint32_t devcmd1_orig;
+			uint32_t devcmdvld_orig;
+			uint32_t devcmd1_mod;
+			uint32_t devcmdvld_mod;
+			uint32_t sflash_bcfg_orig;
+			uint32_t sflash_bcfg_mod;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+
+	unsigned page_address = 0;
+	int err = 0;
+	dma_addr_t dma_addr_param_info = 0;
+	dma_addr_t dma_addr_identifier = 0;
+	unsigned cmd_set_count = 2;
+	unsigned crc_chk_count = 0;
+
+	if (msm_nand_data.nr_parts) {
+		page_address = ((msm_nand_data.parts[0]).offset << 6);
+	} else {
+		pr_err("flash_onfi_probe: "
+				"No partition info available\n");
+		err = -EIO;
+		return err;
+	}
+
+	wait_event(chip->wait_queue, (onfi_identifier_buf =
+		msm_nand_get_dma_buffer(chip, ONFI_IDENTIFIER_LENGTH)));
+	dma_addr_identifier = msm_virt_to_dma(chip, onfi_identifier_buf);
+
+	wait_event(chip->wait_queue, (onfi_param_info_buf =
+		msm_nand_get_dma_buffer(chip, ONFI_PARAM_INFO_LENGTH)));
+	dma_addr_param_info = msm_virt_to_dma(chip, onfi_param_info_buf);
+
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
+
+	dma_buffer->data.sflash_bcfg_orig = flash_rd_reg
+				(chip, MSM_NAND_SFLASHC_BURST_CFG);
+	dma_buffer->data.devcmd1_orig = flash_rd_reg(chip, MSM_NAND_DEV_CMD1);
+	dma_buffer->data.devcmdvld_orig = flash_rd_reg(chip,
+						 MSM_NAND_DEV_CMD_VLD);
+
+	while (cmd_set_count-- > 0) {
+		cmd = dma_buffer->cmd;
+
+		dma_buffer->data.devcmd1_mod = (dma_buffer->data.devcmd1_orig &
+				0xFFFFFF00) | (cmd_set_count
+				? FLASH_READ_ONFI_IDENTIFIER_COMMAND
+				: FLASH_READ_ONFI_PARAMETERS_COMMAND);
+		dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ;
+		dma_buffer->data.addr0 = (page_address << 16) | (cmd_set_count
+				? FLASH_READ_ONFI_IDENTIFIER_ADDRESS
+				: FLASH_READ_ONFI_PARAMETERS_ADDRESS);
+		dma_buffer->data.addr1 = (page_address >> 16) & 0xFF;
+		dma_buffer->data.cfg0 =	(cmd_set_count
+				? MSM_NAND_CFG0_RAW_ONFI_IDENTIFIER
+				: MSM_NAND_CFG0_RAW_ONFI_PARAM_INFO);
+		dma_buffer->data.cfg1 =	(cmd_set_count
+				? MSM_NAND_CFG1_RAW_ONFI_IDENTIFIER
+				: MSM_NAND_CFG1_RAW_ONFI_PARAM_INFO);
+		dma_buffer->data.sflash_bcfg_mod = 0x00000000;
+		dma_buffer->data.devcmdvld_mod = (dma_buffer->
+				data.devcmdvld_orig & 0xFFFFFFFE);
+		dma_buffer->data.exec = 1;
+		dma_buffer->data.flash_status = 0xeeeeeeee;
+
+		/* Put the Nand ctlr in Async mode and disable SFlash ctlr */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.sflash_bcfg_mod);
+		cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on cmd ready, & write CMD,ADDR0,ADDR1,CHIPSEL regs */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+		cmd->dst = MSM_NAND_FLASH_CMD;
+		cmd->len = 12;
+		cmd++;
+
+		/* Configure the CFG0 and CFG1 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.cfg0);
+		cmd->dst = MSM_NAND_DEV0_CFG0;
+		cmd->len = 8;
+		cmd++;
+
+		/* Configure the DEV_CMD_VLD register */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.devcmdvld_mod);
+		cmd->dst = MSM_NAND_DEV_CMD_VLD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Configure the DEV_CMD1 register */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.devcmd1_mod);
+		cmd->dst = MSM_NAND_DEV_CMD1;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.exec);
+		cmd->dst = MSM_NAND_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the two status registers */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_FLASH_STATUS;
+		cmd->dst = msm_virt_to_dma(chip,
+				&dma_buffer->data.flash_status);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read data block - valid only if status says success */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_FLASH_BUFFER;
+		cmd->dst = (cmd_set_count ? dma_addr_identifier :
+				dma_addr_param_info);
+		cmd->len = (cmd_set_count ? ONFI_IDENTIFIER_LENGTH :
+				ONFI_PARAM_INFO_LENGTH);
+		cmd++;
+
+		/* Restore the DEV_CMD1 register */
+		cmd->cmd = 0 ;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.devcmd1_orig);
+		cmd->dst = MSM_NAND_DEV_CMD1;
+		cmd->len = 4;
+		cmd++;
+
+		/* Restore the DEV_CMD_VLD register */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.devcmdvld_orig);
+		cmd->dst = MSM_NAND_DEV_CMD_VLD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Restore the SFLASH_BURST_CONFIG register */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.sflash_bcfg_orig);
+		cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+		cmd->len = 4;
+		cmd++;
+
+		BUILD_BUG_ON(11 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+		dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+				>> 3) | CMD_PTR_LP;
+
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+			&dma_buffer->cmdptr)));
+		mb();
+
+		/* Check for errors, protection violations etc */
+		if (dma_buffer->data.flash_status & 0x110) {
+			pr_info("MPU/OP error (0x%x) during "
+					"ONFI probe\n",
+					dma_buffer->data.flash_status);
+			err = -EIO;
+			break;
 		}
-		if (oobbuf) {
-			n = p * oobsize;
-			end = min(n + oobsize, ops->oobretlen);
-			for(; n < end; n++)
-				if (oobbuf[n] != 0xff)
-					return false;
+
+		if (cmd_set_count) {
+			onfi_param_page_ptr = (struct onfi_param_page *)
+				(&(onfi_identifier_buf[0]));
+			if (onfi_param_page_ptr->parameter_page_signature !=
+					ONFI_PARAMETER_PAGE_SIGNATURE) {
+				pr_info("ONFI probe : Found a non"
+						"ONFI Compliant device \n");
+				err = -EIO;
+				break;
+			}
+		} else {
+			for (crc_chk_count = 0; crc_chk_count <
+					ONFI_PARAM_INFO_LENGTH
+					/ ONFI_PARAM_PAGE_LENGTH;
+					crc_chk_count++) {
+				onfi_param_page_ptr =
+					(struct onfi_param_page *)
+					(&(onfi_param_info_buf
+					[ONFI_PARAM_PAGE_LENGTH *
+					crc_chk_count]));
+				if (flash_onfi_crc_check(
+					(uint8_t *)onfi_param_page_ptr,
+					ONFI_PARAM_PAGE_LENGTH - 2) ==
+					onfi_param_page_ptr->integrity_crc) {
+					break;
+				}
+			}
+			if (crc_chk_count >= ONFI_PARAM_INFO_LENGTH
+					/ ONFI_PARAM_PAGE_LENGTH) {
+				pr_info("ONFI probe : CRC Check "
+						"failed on ONFI Parameter "
+						"data \n");
+				err = -EIO;
+				break;
+			} else {
+				supported_flash.flash_id =
+					flash_read_id(chip);
+				supported_flash.widebus  =
+					onfi_param_page_ptr->
+					features_supported & 0x01;
+				supported_flash.pagesize =
+					onfi_param_page_ptr->
+					number_of_data_bytes_per_page;
+				supported_flash.blksize  =
+					onfi_param_page_ptr->
+					number_of_pages_per_block *
+					supported_flash.pagesize;
+				supported_flash.oobsize  =
+					onfi_param_page_ptr->
+					number_of_spare_bytes_per_page;
+				supported_flash.density  =
+					onfi_param_page_ptr->
+					number_of_blocks_per_logical_unit
+					* supported_flash.blksize;
+				supported_flash.ecc_correctability =
+					onfi_param_page_ptr->
+					number_of_bits_ecc_correctability;
+
+				pr_info("ONFI probe : Found an ONFI "
+					"compliant device %s\n",
+					onfi_param_page_ptr->device_model);
+
+				/* Temporary hack for MT29F4G08ABC device.
+				 * Since the device is not properly adhering
+				 * to ONFi specification it is reporting
+				 * as 16 bit device though it is 8 bit device!!!
+				 */
+				if (!strncmp(onfi_param_page_ptr->device_model,
+					"MT29F4G08ABC", 12))
+					supported_flash.widebus  = 0;
+			}
 		}
-		if (ops->datbuf)
-			for (n = 3; n < mtd->writesize; n+= 516)
-				datbuf[n] = 0xff;
 	}
-	return true;
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+	msm_nand_release_dma_buffer(chip, onfi_param_info_buf,
+			ONFI_PARAM_INFO_LENGTH);
+	msm_nand_release_dma_buffer(chip, onfi_identifier_buf,
+			ONFI_IDENTIFIER_LENGTH);
+
+	return err;
 }
 
 static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
@@ -388,7 +780,7 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 	struct msm_nand_chip *chip = mtd->priv;
 
 	struct {
-		dmov_s cmd[8 * 5 + 3];
+		dmov_s cmd[8 * 5 + 2];
 		unsigned cmdptr;
 		struct {
 			uint32_t cmd;
@@ -397,11 +789,9 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 			uint32_t chipsel;
 			uint32_t cfg0;
 			uint32_t cfg1;
+			uint32_t eccbchcfg;
 			uint32_t exec;
-#if SUPPORT_WRONG_ECC_CONFIG
 			uint32_t ecccfg;
-			uint32_t ecccfg_restore;
-#endif
 			struct {
 				uint32_t flash_status;
 				uint32_t buffer_status;
@@ -410,11 +800,11 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 	} *dma_buffer;
 	dmov_s *cmd;
 	unsigned n;
-	unsigned page = from >> chip->page_shift;
-	uint32_t oob_len = ops->ooblen;
+	unsigned page = 0;
+	uint32_t oob_len;
 	uint32_t sectordatasize;
 	uint32_t sectoroobsize;
-	int err, pageerr;
+	int err, pageerr, rawerr;
 	dma_addr_t data_dma_addr = 0;
 	dma_addr_t oob_dma_addr = 0;
 	dma_addr_t data_dma_addr_curr = 0;
@@ -423,12 +813,26 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 	unsigned page_count;
 	unsigned pages_read = 0;
 	unsigned start_sector = 0;
-	uint32_t sector_corrected;
-	uint32_t page_corrected;
-	uint32_t total_corrected = 0;
-	uint32_t total_uncorrected = 0;
-	unsigned long uncorrected_noalloc = 0;
-	unsigned long *uncorrected = &uncorrected_noalloc;
+	uint32_t ecc_errors;
+	uint32_t total_ecc_errors = 0;
+	unsigned cwperpage;
+#if VERBOSE
+	pr_info("================================================="
+			"================\n");
+	pr_info("%s:\nfrom 0x%llx mode %d\ndatbuf 0x%p datlen 0x%x"
+			"\noobbuf 0x%p ooblen 0x%x\n",
+			__func__, from, ops->mode, ops->datbuf, ops->len,
+			ops->oobbuf, ops->ooblen);
+#endif
+
+	if (mtd->writesize == 2048)
+		page = from >> 11;
+
+	if (mtd->writesize == 4096)
+		page = from >> 12;
+
+	oob_len = ops->ooblen;
+	cwperpage = (mtd->writesize >> 9);
 
 	if (from & (mtd->writesize - 1)) {
 		pr_err("%s: unsupported from, 0x%llx\n",
@@ -458,34 +862,22 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 	}
 
 	if (ops->oobbuf && !ops->datbuf && ops->mode == MTD_OOB_AUTO)
-		start_sector = chip->last_sector;
+		start_sector = cwperpage - 1;
 
 	if (ops->oobbuf && !ops->datbuf) {
-		unsigned tmpoobsz = (ops->mode == MTD_OOB_AUTO) ?
-			mtd->oobavail : mtd->oobsize;
-		page_count = DIV_ROUND_UP(ops->ooblen, tmpoobsz);
+		page_count = ops->ooblen / ((ops->mode == MTD_OOB_AUTO) ?
+			mtd->oobavail : mtd->oobsize);
+		if ((page_count == 0) && (ops->ooblen))
+			page_count = 1;
 	} else if (ops->mode != MTD_OOB_RAW)
 		page_count = ops->len / mtd->writesize;
 	else
 		page_count = ops->len / (mtd->writesize + mtd->oobsize);
 
-#if 0 /* yaffs reads more oob data than it needs */
-	if (ops->ooblen >= sectoroobsize * 4) {
-		pr_err("%s: unsupported ops->ooblen, %d\n",
-		       __func__, ops->ooblen);
-		return -EINVAL;
-	}
-#endif
-
-#if VERBOSE
-	pr_info("msm_nand_read_oob %llx %p %x %p %x\n",
-		from, ops->datbuf, ops->len, ops->oobbuf, ops->ooblen);
-#endif
 	if (ops->datbuf) {
-		/* memset(ops->datbuf, 0x55, ops->len); */
 		data_dma_addr_curr = data_dma_addr =
 			msm_nand_dma_map(chip->dev, ops->datbuf, ops->len,
-					 DMA_FROM_DEVICE);
+				       DMA_FROM_DEVICE);
 		if (dma_mapping_error(chip->dev, data_dma_addr)) {
 			pr_err("msm_nand_read_oob: failed to get dma addr "
 			       "for %p\n", ops->datbuf);
@@ -496,7 +888,7 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 		memset(ops->oobbuf, 0xff, ops->ooblen);
 		oob_dma_addr_curr = oob_dma_addr =
 			msm_nand_dma_map(chip->dev, ops->oobbuf,
-					 ops->ooblen, DMA_BIDIRECTIONAL);
+				       ops->ooblen, DMA_BIDIRECTIONAL);
 		if (dma_mapping_error(chip->dev, oob_dma_addr)) {
 			pr_err("msm_nand_read_oob: failed to get dma addr "
 			       "for %p\n", ops->oobbuf);
@@ -504,20 +896,12 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 			goto err_dma_map_oobbuf_failed;
 		}
 	}
-	if (BITS_TO_LONGS(page_count) > 1) {
-		uncorrected = kzalloc(BITS_TO_LONGS(page_count) * sizeof(long),
-				      GFP_NOIO);
-		if (!uncorrected) {
-			err = -ENOMEM;
-			goto err_alloc_uncorrected_failed;
-		}
-	}
 
 	wait_event(chip->wait_queue,
 		   (dma_buffer = msm_nand_get_dma_buffer(
 			    chip, sizeof(*dma_buffer))));
 
-	oob_col = start_sector * 0x210;
+	oob_col = start_sector * chip->cw_size;
 	if (chip->CFG1 & CFG1_WIDE_FLASH)
 		oob_col >>= 1;
 
@@ -529,22 +913,22 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 		if (ops->mode != MTD_OOB_RAW) {
 			dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ_ECC;
 			dma_buffer->data.cfg0 =
-				(chip->CFG0 & ~(7U << 6)) |
-				((chip->last_sector - start_sector) << 6);
+			(chip->CFG0 & ~(7U << 6))
+				| (((cwperpage-1) - start_sector) << 6);
 			dma_buffer->data.cfg1 = chip->CFG1;
+			if (enable_bch_ecc)
+				dma_buffer->data.eccbchcfg = chip->ecc_bch_cfg;
 		} else {
 			dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ;
-			dma_buffer->data.cfg0 =
-				(MSM_NAND_CFG0_RAW & ~(7U << 6)) |
-				(chip->last_sector << 6);
-			dma_buffer->data.cfg1 = MSM_NAND_CFG1_RAW |
-						(chip->CFG1 & CFG1_WIDE_FLASH);
+			dma_buffer->data.cfg0 = (chip->CFG0_RAW
+					& ~(7U << 6)) | ((cwperpage-1) << 6);
+			dma_buffer->data.cfg1 = chip->CFG1_RAW |
+					(chip->CFG1 & CFG1_WIDE_FLASH);
 		}
 
 		dma_buffer->data.addr0 = (page << 16) | oob_col;
-		/* qc example is (page >> 16) && 0xff !? */
 		dma_buffer->data.addr1 = (page >> 16) & 0xff;
-		/* flash0 + undoc bit */
+		/* chipsel_0 + enable DM interface */
 		dma_buffer->data.chipsel = 0 | 4;
 
 
@@ -554,7 +938,7 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 
 		BUILD_BUG_ON(8 != ARRAY_SIZE(dma_buffer->data.result));
 
-		for (n = start_sector; n <= chip->last_sector; n++) {
+		for (n = start_sector; n < cwperpage; n++) {
 			/* flash + buffer status return words */
 			dma_buffer->data.result[n].flash_status = 0xeeeeeeee;
 			dma_buffer->data.result[n].buffer_status = 0xeeeeeeee;
@@ -577,21 +961,19 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 				cmd->src = msm_virt_to_dma(chip,
 							&dma_buffer->data.cfg0);
 				cmd->dst = MSM_NAND_DEV0_CFG0;
-				cmd->len = 8;
+				if (enable_bch_ecc)
+					cmd->len = 12;
+				else
+					cmd->len = 8;
+				cmd++;
+
+				dma_buffer->data.ecccfg = chip->ecc_buf_cfg;
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.ecccfg);
+				cmd->dst = MSM_NAND_EBI2_ECC_BUF_CFG;
+				cmd->len = 4;
 				cmd++;
-#if SUPPORT_WRONG_ECC_CONFIG
-				if (chip->saved_ecc_buf_cfg !=
-				    chip->ecc_buf_cfg) {
-					dma_buffer->data.ecccfg =
-						chip->ecc_buf_cfg;
-					cmd->cmd = 0;
-					cmd->src = msm_virt_to_dma(chip,
-						      &dma_buffer->data.ecccfg);
-					cmd->dst = MSM_NAND_EBI2_ECC_BUF_CFG;
-					cmd->len = 4;
-					cmd++;
-				}
-#endif
 			}
 
 			/* kick the execute register */
@@ -618,11 +1000,10 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 			 */
 			if (ops->datbuf) {
 				if (ops->mode != MTD_OOB_RAW)
-					sectordatasize =
-						(n < chip->last_sector) ?
-						516 : chip->last_sectorsz;
+					sectordatasize = (n < (cwperpage - 1))
+					? 516 : (512 - ((cwperpage - 1) << 2));
 				else
-					sectordatasize = 528;
+					sectordatasize = chip->cw_size;
 
 				cmd->cmd = 0;
 				cmd->src = MSM_NAND_FLASH_BUFFER;
@@ -632,19 +1013,19 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 				cmd++;
 			}
 
-			if (ops->oobbuf && (n == chip->last_sector ||
-					    ops->mode != MTD_OOB_AUTO)) {
+			if (ops->oobbuf && (n == (cwperpage - 1)
+			     || ops->mode != MTD_OOB_AUTO)) {
 				cmd->cmd = 0;
-				if (n == chip->last_sector) {
+				if (n == (cwperpage - 1)) {
 					cmd->src = MSM_NAND_FLASH_BUFFER +
-						chip->last_sectorsz;
-					sectoroobsize =
-						(chip->last_sector + 1) * 4;
+						(512 - ((cwperpage - 1) << 2));
+					sectoroobsize = (cwperpage << 2);
 					if (ops->mode != MTD_OOB_AUTO)
-						sectoroobsize += 10;
+						sectoroobsize +=
+							chip->ecc_parity_bytes;
 				} else {
 					cmd->src = MSM_NAND_FLASH_BUFFER + 516;
-					sectoroobsize = 10;
+					sectoroobsize = chip->ecc_parity_bytes;
 				}
 
 				cmd->dst = oob_dma_addr_curr;
@@ -658,20 +1039,8 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 					cmd++;
 			}
 		}
-#if SUPPORT_WRONG_ECC_CONFIG
-		if (chip->saved_ecc_buf_cfg != chip->ecc_buf_cfg) {
-			dma_buffer->data.ecccfg_restore =
-				chip->saved_ecc_buf_cfg;
-			cmd->cmd = 0;
-			cmd->src = msm_virt_to_dma(chip,
-					      &dma_buffer->data.ecccfg_restore);
-			cmd->dst = MSM_NAND_EBI2_ECC_BUF_CFG;
-			cmd->len = 4;
-			cmd++;
-		}
-#endif
 
-		BUILD_BUG_ON(8 * 5 + 3 != ARRAY_SIZE(dma_buffer->cmd));
+		BUILD_BUG_ON(8 * 5 + 2 != ARRAY_SIZE(dma_buffer->cmd));
 		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
 		dma_buffer->cmd[0].cmd |= CMD_OCB;
 		cmd[-1].cmd |= CMD_OCU | CMD_LC;
@@ -680,78 +1049,123 @@ static int msm_nand_read_oob(struct mtd_info *mtd, loff_t from,
 			(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3)
 			| CMD_PTR_LP;
 
-		msm_dmov_exec_cmd(
-			chip->dma_channel, DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(
-				msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+			&dma_buffer->cmdptr)));
+		mb();
 
 		/* if any of the writes failed (0x10), or there
 		 * was a protection violation (0x100), we lose
 		 */
-		pageerr = 0;
-		page_corrected = 0;
-		for (n = start_sector; n <= chip->last_sector; n++) {
-			uint32_t buf_stat =
-				dma_buffer->data.result[n].buffer_status;
-			if (buf_stat & BUF_STAT_UNCORRECTABLE) {
-				total_uncorrected++;
-				uncorrected[BIT_WORD(pages_read)] |=
-							BIT_MASK(pages_read);
-				pageerr = -EBADMSG;
-				break;
-			}
+		pageerr = rawerr = 0;
+		for (n = start_sector; n < cwperpage; n++) {
 			if (dma_buffer->data.result[n].flash_status & 0x110) {
-				pageerr = -EIO;
+				rawerr = -EIO;
 				break;
 			}
-			sector_corrected =buf_stat & BUF_STAT_NUM_ERRS_MASK;
-			page_corrected += sector_corrected;
-			if (sector_corrected > 1)
-				pageerr = -EUCLEAN;
-		}
-		if ((!pageerr && page_corrected) || pageerr == -EUCLEAN) {
-			total_corrected += page_corrected;
-			/* not thread safe */
-			mtd->ecc_stats.corrected += page_corrected;
 		}
-		if (pageerr && (pageerr != -EUCLEAN || err == 0))
-			err = pageerr;
+		if (rawerr) {
+			if (ops->datbuf && ops->mode != MTD_OOB_RAW) {
+				uint8_t *datbuf = ops->datbuf +
+					pages_read * mtd->writesize;
+
+				dma_sync_single_for_cpu(chip->dev,
+					data_dma_addr_curr-mtd->writesize,
+					mtd->writesize, DMA_BIDIRECTIONAL);
+
+				for (n = 0; n < mtd->writesize; n++) {
+					/* empty blocks read 0x54 at
+					 * these offsets
+					 */
+					if ((n % 516 == 3 || n % 516 == 175)
+							&& datbuf[n] == 0x54)
+						datbuf[n] = 0xff;
+					if (datbuf[n] != 0xff) {
+						pageerr = rawerr;
+						break;
+					}
+				}
 
-#if VERBOSE
-		pr_info("status: %x %x %x %x %x %x %x %x "
-			"%x %x %x %x %x %x %x %x\n",
-			dma_buffer->data.result[0].flash_status,
-			dma_buffer->data.result[0].buffer_status,
-			dma_buffer->data.result[1].flash_status,
-			dma_buffer->data.result[1].buffer_status,
-			dma_buffer->data.result[2].flash_status,
-			dma_buffer->data.result[2].buffer_status,
-			dma_buffer->data.result[3].flash_status,
-			dma_buffer->data.result[3].buffer_status,
-			dma_buffer->data.result[4].flash_status,
-			dma_buffer->data.result[4].buffer_status,
-			dma_buffer->data.result[5].flash_status,
-			dma_buffer->data.result[5].buffer_status,
-			dma_buffer->data.result[6].flash_status,
-			dma_buffer->data.result[6].buffer_status,
-			dma_buffer->data.result[7].flash_status,
-			dma_buffer->data.result[7].buffer_status);
-#endif
-		if (err && err != -EUCLEAN && err != -EBADMSG)
-			break;
+				dma_sync_single_for_device(chip->dev,
+					data_dma_addr_curr-mtd->writesize,
+					mtd->writesize, DMA_BIDIRECTIONAL);
+
+			}
+			if (ops->oobbuf) {
+				dma_sync_single_for_cpu(chip->dev,
+				oob_dma_addr_curr - (ops->ooblen - oob_len),
+				ops->ooblen - oob_len, DMA_BIDIRECTIONAL);
+
+				for (n = 0; n < ops->ooblen; n++) {
+					if (ops->oobbuf[n] != 0xff) {
+						pageerr = rawerr;
+						break;
+					}
+				}
+
+				dma_sync_single_for_device(chip->dev,
+				oob_dma_addr_curr - (ops->ooblen - oob_len),
+				ops->ooblen - oob_len, DMA_BIDIRECTIONAL);
+			}
+		}
+		if (pageerr) {
+			for (n = start_sector; n < cwperpage; n++) {
+				if (enable_bch_ecc ?
+			(dma_buffer->data.result[n].buffer_status & 0x10) :
+			(dma_buffer->data.result[n].buffer_status & 0x8)) {
+					/* not thread safe */
+					mtd->ecc_stats.failed++;
+					pageerr = -EBADMSG;
+					break;
+				}
+			}
+		}
+		if (!rawerr) { /* check for corretable errors */
+			for (n = start_sector; n < cwperpage; n++) {
+				ecc_errors = enable_bch_ecc ?
+			(dma_buffer->data.result[n].buffer_status & 0xF) :
+			(dma_buffer->data.result[n].buffer_status & 0x7);
+				if (ecc_errors) {
+					total_ecc_errors += ecc_errors;
+					/* not thread safe */
+					mtd->ecc_stats.corrected += ecc_errors;
+					if (ecc_errors > 1)
+						pageerr = -EUCLEAN;
+				}
+			}
+		}
+		if (pageerr && (pageerr != -EUCLEAN || err == 0))
+			err = pageerr;
+
+#if VERBOSE
+		if (rawerr && !pageerr) {
+			pr_err("msm_nand_read_oob %llx %x %x empty page\n",
+			       (loff_t)page * mtd->writesize, ops->len,
+			       ops->ooblen);
+		} else {
+			for (n = start_sector; n < cwperpage; n++)
+				pr_info("flash_status[%d] = %x,\
+				buffr_status[%d] = %x\n",
+				n, dma_buffer->data.result[n].flash_status,
+				n, dma_buffer->data.result[n].buffer_status);
+		}
+#endif
+		if (err && err != -EUCLEAN && err != -EBADMSG)
+			break;
 		pages_read++;
 		page++;
 	}
 	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
 
-err_alloc_uncorrected_failed:
 	if (ops->oobbuf) {
 		dma_unmap_page(chip->dev, oob_dma_addr,
-			       ops->ooblen, DMA_FROM_DEVICE);
+				 ops->ooblen, DMA_FROM_DEVICE);
 	}
 err_dma_map_oobbuf_failed:
 	if (ops->datbuf) {
 		dma_unmap_page(chip->dev, data_dma_addr,
-			       ops->len, DMA_FROM_DEVICE);
+				 ops->len, DMA_BIDIRECTIONAL);
 	}
 
 	if (ops->mode != MTD_OOB_RAW)
@@ -760,467 +1174,4608 @@ err_dma_map_oobbuf_failed:
 		ops->retlen = (mtd->writesize +  mtd->oobsize) *
 							pages_read;
 	ops->oobretlen = ops->ooblen - oob_len;
-
-	if (err == -EBADMSG && msm_nand_check_empty(mtd, ops, uncorrected))
-		err = 0;
-	else if (total_uncorrected)
-		mtd->ecc_stats.failed += total_uncorrected; /* not threadsafe */
-	if (uncorrected != &uncorrected_noalloc)
-		kfree(uncorrected);
-
 	if (err)
 		pr_err("msm_nand_read_oob %llx %x %x failed %d, corrected %d\n",
 		       from, ops->datbuf ? ops->len : 0, ops->ooblen, err,
-		       total_corrected);
-	return err;
-}
-
-static int
-msm_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
-	      size_t *retlen, u_char *buf)
-{
-	int ret;
-	struct mtd_oob_ops ops;
-
-	/* printk("msm_nand_read %llx %x\n", from, len); */
+		       total_ecc_errors);
+#if VERBOSE
+	pr_info("\n%s: ret %d, retlen %d oobretlen %d\n",
+			__func__, err, ops->retlen, ops->oobretlen);
 
-	ops.mode = MTD_OOB_PLACE;
-	ops.len = len;
-	ops.retlen = 0;
-	ops.ooblen = 0;
-	ops.datbuf = buf;
-	ops.oobbuf = NULL;
-	ret =  msm_nand_read_oob(mtd, from, &ops);
-	*retlen = ops.retlen;
-	return ret;
+	pr_info("==================================================="
+			"==============\n");
+#endif
+	return err;
 }
 
-static int
-msm_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+static int msm_nand_read_oob_dualnandc(struct mtd_info *mtd, loff_t from,
+			struct mtd_oob_ops *ops)
 {
 	struct msm_nand_chip *chip = mtd->priv;
+
 	struct {
-		dmov_s cmd[8 * 6 + 3];
+		dmov_s cmd[16 * 6 + 20];
 		unsigned cmdptr;
 		struct {
 			uint32_t cmd;
-			uint32_t addr0;
-			uint32_t addr1;
-			uint32_t chipsel;
+			uint32_t nandc01_addr0;
+			uint32_t nandc10_addr0;
+			uint32_t nandc11_addr1;
+			uint32_t chipsel_cs0;
+			uint32_t chipsel_cs1;
 			uint32_t cfg0;
 			uint32_t cfg1;
+			uint32_t eccbchcfg;
 			uint32_t exec;
-#if SUPPORT_WRONG_ECC_CONFIG
 			uint32_t ecccfg;
-			uint32_t ecccfg_restore;
-#endif
-			uint32_t flash_status[8];
-			uint32_t zeroes;
+			uint32_t ebi2_chip_select_cfg0;
+			uint32_t adm_mux_data_ack_req_nc01;
+			uint32_t adm_mux_cmd_ack_req_nc01;
+			uint32_t adm_mux_data_ack_req_nc10;
+			uint32_t adm_mux_cmd_ack_req_nc10;
+			uint32_t adm_default_mux;
+			uint32_t default_ebi2_chip_select_cfg0;
+			uint32_t nc10_flash_dev_cmd_vld;
+			uint32_t nc10_flash_dev_cmd1;
+			uint32_t nc10_flash_dev_cmd_vld_default;
+			uint32_t nc10_flash_dev_cmd1_default;
+			struct {
+				uint32_t flash_status;
+				uint32_t buffer_status;
+			} result[16];
 		} data;
 	} *dma_buffer;
 	dmov_s *cmd;
 	unsigned n;
-	unsigned page = to >> chip->page_shift;
-	uint32_t oob_len = ops->ooblen;
-	uint32_t sectordatawritesize;
-	int err;
+	unsigned page = 0;
+	uint32_t oob_len;
+	uint32_t sectordatasize;
+	uint32_t sectoroobsize;
+	int err, pageerr, rawerr;
 	dma_addr_t data_dma_addr = 0;
 	dma_addr_t oob_dma_addr = 0;
 	dma_addr_t data_dma_addr_curr = 0;
 	dma_addr_t oob_dma_addr_curr = 0;
+	uint32_t oob_col = 0;
 	unsigned page_count;
-	unsigned pages_written = 0;
+	unsigned pages_read = 0;
+	unsigned start_sector = 0;
+	uint32_t ecc_errors;
+	uint32_t total_ecc_errors = 0;
+	unsigned cwperpage;
+	unsigned cw_offset = chip->cw_size;
+#if VERBOSE
+		pr_info("================================================="
+				"============\n");
+		pr_info("%s:\nfrom 0x%llx mode %d\ndatbuf 0x%p datlen 0x%x"
+				"\noobbuf 0x%p ooblen 0x%x\n\n",
+				__func__, from, ops->mode, ops->datbuf,
+				ops->len, ops->oobbuf, ops->ooblen);
+#endif
 
-	if (to & (mtd->writesize - 1)) {
-		pr_err("%s: unsupported to, 0x%llx\n", __func__, to);
+	if (mtd->writesize == 2048)
+		page = from >> 11;
+
+	if (mtd->writesize == 4096)
+		page = from >> 12;
+
+	if (interleave_enable)
+		page = (from >> 1) >> 12;
+
+	oob_len = ops->ooblen;
+	cwperpage = (mtd->writesize >> 9);
+
+	if (from & (mtd->writesize - 1)) {
+		pr_err("%s: unsupported from, 0x%llx\n",
+		       __func__, from);
 		return -EINVAL;
 	}
-
 	if (ops->mode != MTD_OOB_RAW) {
-		if (ops->ooblen != 0 && ops->mode != MTD_OOB_AUTO) {
-			pr_err("%s: unsupported ops->mode,%d\n",
-					 __func__, ops->mode);
-			return -EINVAL;
-		}
-		if ((ops->len % mtd->writesize) != 0) {
+		if (ops->datbuf != NULL && (ops->len % mtd->writesize) != 0) {
 			pr_err("%s: unsupported ops->len, %d\n",
-					__func__, ops->len);
+			       __func__, ops->len);
 			return -EINVAL;
 		}
 	} else {
-		if ((ops->len % (mtd->writesize + mtd->oobsize)) != 0) {
-			pr_err("%s: unsupported ops->len, "
-				"%d for MTD_OOB_RAW mode\n",
-				 __func__, ops->len);
+		if (ops->datbuf != NULL &&
+			(ops->len % (mtd->writesize + mtd->oobsize)) != 0) {
+			pr_err("%s: unsupported ops->len,"
+				" %d for MTD_OOB_RAW\n", __func__, ops->len);
 			return -EINVAL;
 		}
 	}
 
-	if (ops->datbuf == NULL) {
-		pr_err("%s: unsupported ops->datbuf == NULL\n", __func__);
-		return -EINVAL;
-	}
-#if 0 /* yaffs writes more oob data than it needs */
-	if (ops->ooblen >= sectoroobsize * 4) {
-		pr_err("%s: unsupported ops->ooblen, %d\n",
-		       __func__, ops->ooblen);
-		return -EINVAL;
-	}
-#endif
 	if (ops->mode != MTD_OOB_RAW && ops->ooblen != 0 && ops->ooboffs != 0) {
 		pr_err("%s: unsupported ops->ooboffs, %d\n",
 		       __func__, ops->ooboffs);
 		return -EINVAL;
 	}
 
+	if (ops->oobbuf && !ops->datbuf && ops->mode == MTD_OOB_AUTO)
+		start_sector = cwperpage - 1;
+
+	if (ops->oobbuf && !ops->datbuf) {
+		page_count = ops->ooblen / ((ops->mode == MTD_OOB_AUTO) ?
+			mtd->oobavail : mtd->oobsize);
+		if ((page_count == 0) && (ops->ooblen))
+			page_count = 1;
+	} else if (ops->mode != MTD_OOB_RAW)
+		page_count = ops->len / mtd->writesize;
+	else
+		page_count = ops->len / (mtd->writesize + mtd->oobsize);
+
 	if (ops->datbuf) {
 		data_dma_addr_curr = data_dma_addr =
-			msm_nand_dma_map(chip->dev, ops->datbuf,
-					 ops->len, DMA_TO_DEVICE);
+			msm_nand_dma_map(chip->dev, ops->datbuf, ops->len,
+				       DMA_FROM_DEVICE);
 		if (dma_mapping_error(chip->dev, data_dma_addr)) {
-			pr_err("msm_nand_write_oob: failed to get dma addr "
-			       "for %p\n", ops->datbuf);
+			pr_err("msm_nand_read_oob_dualnandc: "
+				"failed to get dma addr for %p\n",
+				ops->datbuf);
 			return -EIO;
 		}
 	}
 	if (ops->oobbuf) {
+		memset(ops->oobbuf, 0xff, ops->ooblen);
 		oob_dma_addr_curr = oob_dma_addr =
 			msm_nand_dma_map(chip->dev, ops->oobbuf,
-					 ops->ooblen, DMA_TO_DEVICE);
+				       ops->ooblen, DMA_BIDIRECTIONAL);
 		if (dma_mapping_error(chip->dev, oob_dma_addr)) {
-			pr_err("msm_nand_write_oob: failed to get dma addr "
-			       "for %p\n", ops->oobbuf);
+			pr_err("msm_nand_read_oob_dualnandc: "
+				"failed to get dma addr for %p\n",
+				ops->oobbuf);
 			err = -EIO;
 			goto err_dma_map_oobbuf_failed;
 		}
 	}
-	if (ops->mode != MTD_OOB_RAW)
-		page_count = ops->len / mtd->writesize;
-	else
-		page_count = ops->len / (mtd->writesize + mtd->oobsize);
 
-	wait_event(chip->wait_queue, (dma_buffer =
-			msm_nand_get_dma_buffer(chip, sizeof(*dma_buffer))));
+	wait_event(chip->wait_queue,
+		   (dma_buffer = msm_nand_get_dma_buffer(
+			    chip, sizeof(*dma_buffer))));
+
+	oob_col = start_sector * chip->cw_size;
+	if (chip->CFG1 & CFG1_WIDE_FLASH) {
+		oob_col >>= 1;
+		cw_offset >>= 1;
+	}
 
+	err = 0;
 	while (page_count-- > 0) {
 		cmd = dma_buffer->cmd;
 
-		/* CMD / ADDR0 / ADDR1 / CHIPSEL program values */
 		if (ops->mode != MTD_OOB_RAW) {
-			dma_buffer->data.cfg0 = chip->CFG0;
+			dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ_ECC;
+			if (start_sector == (cwperpage - 1)) {
+				dma_buffer->data.cfg0 = (chip->CFG0 &
+							~(7U << 6));
+			} else {
+				dma_buffer->data.cfg0 = (chip->CFG0 &
+				~(7U << 6))
+				| (((cwperpage >> 1)-1) << 6);
+			}
 			dma_buffer->data.cfg1 = chip->CFG1;
+			if (enable_bch_ecc)
+				dma_buffer->data.eccbchcfg = chip->ecc_bch_cfg;
 		} else {
-			dma_buffer->data.cfg0 =
-				(MSM_NAND_CFG0_RAW & ~(7U << 6)) |
-				(chip->last_sector << 6);
-			dma_buffer->data.cfg1 = MSM_NAND_CFG1_RAW |
-				(chip->CFG1 & CFG1_WIDE_FLASH);
+			dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ;
+			dma_buffer->data.cfg0 = ((chip->CFG0_RAW &
+				~(7U << 6)) | ((((cwperpage >> 1)-1) << 6)));
+			dma_buffer->data.cfg1 = chip->CFG1_RAW |
+					(chip->CFG1 & CFG1_WIDE_FLASH);
 		}
 
-		dma_buffer->data.cmd = MSM_NAND_CMD_PRG_PAGE;
-		dma_buffer->data.addr0 = page << 16;
-		dma_buffer->data.addr1 = (page >> 16) & 0xff;
-		dma_buffer->data.chipsel = 0 | 4; /* flash0 + undoc bit */
-		dma_buffer->data.zeroes = 0;
+		if (!interleave_enable) {
+			if (start_sector == (cwperpage - 1)) {
+				dma_buffer->data.nandc10_addr0 =
+							(page << 16) | oob_col;
+				dma_buffer->data.nc10_flash_dev_cmd_vld = 0xD;
+				dma_buffer->data.nc10_flash_dev_cmd1 =
+								0xF00F3000;
+			} else {
+				dma_buffer->data.nandc01_addr0 = page << 16;
+				/* NC10 ADDR0 points to the next code word */
+				dma_buffer->data.nandc10_addr0 = (page << 16) |
+								cw_offset;
+				dma_buffer->data.nc10_flash_dev_cmd_vld = 0x1D;
+				dma_buffer->data.nc10_flash_dev_cmd1 =
+								0xF00FE005;
+			}
+		} else {
+			dma_buffer->data.nandc01_addr0 =
+			dma_buffer->data.nandc10_addr0 =
+						(page << 16) | oob_col;
+		}
+		/* ADDR1 */
+		dma_buffer->data.nandc11_addr1 = (page >> 16) & 0xff;
 
+		dma_buffer->data.adm_mux_data_ack_req_nc01 = 0x00000A3C;
+		dma_buffer->data.adm_mux_cmd_ack_req_nc01  = 0x0000053C;
+		dma_buffer->data.adm_mux_data_ack_req_nc10 = 0x00000F28;
+		dma_buffer->data.adm_mux_cmd_ack_req_nc10  = 0x00000F14;
+		dma_buffer->data.adm_default_mux = 0x00000FC0;
+		dma_buffer->data.nc10_flash_dev_cmd_vld_default = 0x1D;
+		dma_buffer->data.nc10_flash_dev_cmd1_default = 0xF00F3000;
 
-			/* GO bit for the EXEC register */
+		dma_buffer->data.ebi2_chip_select_cfg0 = 0x00000805;
+		dma_buffer->data.default_ebi2_chip_select_cfg0 = 0x00000801;
+
+		/* chipsel_0 + enable DM interface */
+		dma_buffer->data.chipsel_cs0 = (1<<4) | 4;
+		/* chipsel_1 + enable DM interface */
+		dma_buffer->data.chipsel_cs1 = (1<<4) | 5;
+
+		/* GO bit for the EXEC register */
 		dma_buffer->data.exec = 1;
 
-		BUILD_BUG_ON(8 != ARRAY_SIZE(dma_buffer->data.flash_status));
+		BUILD_BUG_ON(16 != ARRAY_SIZE(dma_buffer->data.result));
 
-		for (n = 0; n <= chip->last_sector ; n++) {
-			/* status return words */
-			dma_buffer->data.flash_status[n] = 0xeeeeeeee;
-			/* block on cmd ready, then
-			 * write CMD / ADDR0 / ADDR1 / CHIPSEL regs in a burst
-			 */
-			cmd->cmd = DST_CRCI_NAND_CMD;
-			cmd->src =
-				msm_virt_to_dma(chip, &dma_buffer->data.cmd);
-			cmd->dst = MSM_NAND_FLASH_CMD;
-			if (n == 0)
-				cmd->len = 16;
-			else
-				cmd->len = 4;
-			cmd++;
+		for (n = start_sector; n < cwperpage; n++) {
+			/* flash + buffer status return words */
+			dma_buffer->data.result[n].flash_status = 0xeeeeeeee;
+			dma_buffer->data.result[n].buffer_status = 0xeeeeeeee;
 
-			if (n == 0) {
+			if (n == start_sector) {
+				if (!interleave_enable) {
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+						data.nc10_flash_dev_cmd_vld);
+					cmd->dst = NC10(MSM_NAND_DEV_CMD_VLD);
+					cmd->len = 4;
+					cmd++;
+
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nc10_flash_dev_cmd1);
+					cmd->dst = NC10(MSM_NAND_DEV_CMD1);
+					cmd->len = 4;
+					cmd++;
+
+					/* NC01, NC10 --> ADDR1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc11_addr1);
+					cmd->dst = NC11(MSM_NAND_ADDR1);
+					cmd->len = 8;
+					cmd++;
+
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cfg0);
+					cmd->dst = NC11(MSM_NAND_DEV0_CFG0);
+					if (enable_bch_ecc)
+						cmd->len = 12;
+					else
+						cmd->len = 8;
+					cmd++;
+				} else {
+					/* enable CS0 & CS1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+						data.ebi2_chip_select_cfg0);
+					cmd->dst = EBI2_CHIP_SELECT_CFG0;
+					cmd->len = 4;
+					cmd++;
+
+					/* NC01, NC10 --> ADDR1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc11_addr1);
+					cmd->dst = NC11(MSM_NAND_ADDR1);
+					cmd->len = 4;
+					cmd++;
+
+					/* Enable CS0 for NC01 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.chipsel_cs0);
+					cmd->dst =
+					NC01(MSM_NAND_FLASH_CHIP_SELECT);
+					cmd->len = 4;
+					cmd++;
+
+					/* Enable CS1 for NC10 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.chipsel_cs1);
+					cmd->dst =
+					NC10(MSM_NAND_FLASH_CHIP_SELECT);
+					cmd->len = 4;
+					cmd++;
+
+					/* config DEV0_CFG0 & CFG1 for CS0 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.cfg0);
+					cmd->dst = NC01(MSM_NAND_DEV0_CFG0);
+					cmd->len = 8;
+					cmd++;
+
+					/* config DEV1_CFG0 & CFG1 for CS1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.cfg0);
+					cmd->dst = NC10(MSM_NAND_DEV1_CFG0);
+					cmd->len = 8;
+					cmd++;
+				}
+
+				dma_buffer->data.ecccfg = chip->ecc_buf_cfg;
 				cmd->cmd = 0;
 				cmd->src = msm_virt_to_dma(chip,
-							&dma_buffer->data.cfg0);
-				cmd->dst = MSM_NAND_DEV0_CFG0;
-				cmd->len = 8;
+						&dma_buffer->data.ecccfg);
+				cmd->dst = NC11(MSM_NAND_EBI2_ECC_BUF_CFG);
+				cmd->len = 4;
 				cmd++;
-#if SUPPORT_WRONG_ECC_CONFIG
-				if (chip->saved_ecc_buf_cfg !=
-				    chip->ecc_buf_cfg) {
-					dma_buffer->data.ecccfg =
-						chip->ecc_buf_cfg;
+
+				/* if 'only' the last code word */
+				if (n == cwperpage - 1) {
+					/* MASK CMD ACK/REQ --> NC01 (0x53C)*/
 					cmd->cmd = 0;
 					cmd->src = msm_virt_to_dma(chip,
-						      &dma_buffer->data.ecccfg);
-					cmd->dst = MSM_NAND_EBI2_ECC_BUF_CFG;
+					&dma_buffer->
+						data.adm_mux_cmd_ack_req_nc01);
+					cmd->dst = EBI2_NAND_ADM_MUX;
 					cmd->len = 4;
 					cmd++;
-				}
-#endif
-			}
 
-				/* write data block */
-			if (ops->mode != MTD_OOB_RAW)
-				sectordatawritesize = (n < chip->last_sector) ?
-					516 : chip->last_sectorsz;
-			else
-				sectordatawritesize = 528;
+					/* CMD */
+					cmd->cmd = DST_CRCI_NAND_CMD;
+					cmd->src = msm_virt_to_dma(chip,
+							&dma_buffer->data.cmd);
+					cmd->dst = NC10(MSM_NAND_FLASH_CMD);
+					cmd->len = 4;
+					cmd++;
 
-			cmd->cmd = 0;
-			cmd->src = data_dma_addr_curr;
-			data_dma_addr_curr += sectordatawritesize;
-			cmd->dst = MSM_NAND_FLASH_BUFFER;
-			cmd->len = sectordatawritesize;
-			cmd++;
+					/* NC10 --> ADDR0 ( 0x0 ) */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc10_addr0);
+					cmd->dst = NC10(MSM_NAND_ADDR0);
+					cmd->len = 4;
+					cmd++;
 
-			if (ops->oobbuf) {
-				if (n == chip->last_sector) {
+					/* kick the execute reg for NC10 */
 					cmd->cmd = 0;
-					cmd->src = oob_dma_addr_curr;
-					cmd->dst = MSM_NAND_FLASH_BUFFER +
-						chip->last_sectorsz;
-					cmd->len = 516 - chip->last_sectorsz;
-					if (oob_len <= cmd->len)
-						cmd->len = oob_len;
-					oob_dma_addr_curr += cmd->len;
-					oob_len -= cmd->len;
-					if (cmd->len > 0)
-						cmd++;
-				}
-				if (ops->mode != MTD_OOB_AUTO) {
-					/* skip ecc bytes in oobbuf */
-					if (oob_len < 10) {
-						oob_dma_addr_curr += 10;
-						oob_len -= 10;
-					} else {
-						oob_dma_addr_curr += oob_len;
-						oob_len = 0;
-					}
-				}
-			}
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.exec);
+					cmd->dst = NC10(MSM_NAND_EXEC_CMD);
+					cmd->len = 4;
+					cmd++;
 
-			/* kick the execute register */
-			cmd->cmd = 0;
-			cmd->src =
-				msm_virt_to_dma(chip, &dma_buffer->data.exec);
-			cmd->dst = MSM_NAND_EXEC_CMD;
-			cmd->len = 4;
-			cmd++;
+					/* MASK DATA ACK/REQ --> NC01 (0xA3C)*/
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+					data.adm_mux_data_ack_req_nc01);
+					cmd->dst = EBI2_NAND_ADM_MUX;
+					cmd->len = 4;
+					cmd++;
 
-			/* block on data ready, then
-			 * read the status register
+					/* block on data ready from NC10, then
+					 * read the status register
+					 */
+					cmd->cmd = SRC_CRCI_NAND_DATA;
+					cmd->src = NC10(MSM_NAND_FLASH_STATUS);
+					cmd->dst = msm_virt_to_dma(chip,
+						&dma_buffer->data.result[n]);
+					/* MSM_NAND_FLASH_STATUS +
+					 * MSM_NAND_BUFFER_STATUS
+					 */
+					cmd->len = 8;
+					cmd++;
+				} else {
+					/* NC01 --> ADDR0 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc01_addr0);
+					cmd->dst = NC01(MSM_NAND_ADDR0);
+					cmd->len = 4;
+					cmd++;
+
+					/* NC10 --> ADDR1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc10_addr0);
+					cmd->dst = NC10(MSM_NAND_ADDR0);
+					cmd->len = 4;
+					cmd++;
+
+					/* MASK CMD ACK/REQ --> NC10 (0xF14)*/
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+						data.adm_mux_cmd_ack_req_nc10);
+					cmd->dst = EBI2_NAND_ADM_MUX;
+					cmd->len = 4;
+					cmd++;
+
+					/* CMD */
+					cmd->cmd = DST_CRCI_NAND_CMD;
+					cmd->src = msm_virt_to_dma(chip,
+							&dma_buffer->data.cmd);
+					cmd->dst = NC01(MSM_NAND_FLASH_CMD);
+					cmd->len = 4;
+					cmd++;
+
+					/* kick the execute register for NC01*/
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						 &dma_buffer->data.exec);
+					cmd->dst = NC01(MSM_NAND_EXEC_CMD);
+					cmd->len = 4;
+					cmd++;
+				}
+			}
+
+			/* read data block
+			 * (only valid if status says success)
 			 */
-			cmd->cmd = SRC_CRCI_NAND_DATA;
-			cmd->src = MSM_NAND_FLASH_STATUS;
-			cmd->dst = msm_virt_to_dma(chip,
-					     &dma_buffer->data.flash_status[n]);
+			if (ops->datbuf || (ops->oobbuf &&
+						 ops->mode != MTD_OOB_AUTO)) {
+				if (ops->mode != MTD_OOB_RAW)
+					sectordatasize = (n < (cwperpage - 1))
+					? 516 : (512 - ((cwperpage - 1) << 2));
+				else
+					sectordatasize = chip->cw_size;
+
+				if (n % 2 == 0) {
+					/* MASK DATA ACK/REQ --> NC10 (0xF28)*/
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+					data.adm_mux_data_ack_req_nc10);
+					cmd->dst = EBI2_NAND_ADM_MUX;
+					cmd->len = 4;
+					cmd++;
+
+					/* block on data ready from NC01, then
+					 * read the status register
+					 */
+					cmd->cmd = SRC_CRCI_NAND_DATA;
+					cmd->src = NC01(MSM_NAND_FLASH_STATUS);
+					cmd->dst = msm_virt_to_dma(chip,
+						&dma_buffer->data.result[n]);
+					/* MSM_NAND_FLASH_STATUS +
+					 * MSM_NAND_BUFFER_STATUS
+					 */
+					cmd->len = 8;
+					cmd++;
+
+					/* MASK CMD ACK/REQ --> NC01 (0x53C)*/
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+						data.adm_mux_cmd_ack_req_nc01);
+					cmd->dst = EBI2_NAND_ADM_MUX;
+					cmd->len = 4;
+					cmd++;
+
+					/* CMD */
+					cmd->cmd = DST_CRCI_NAND_CMD;
+					cmd->src = msm_virt_to_dma(chip,
+							&dma_buffer->data.cmd);
+					cmd->dst = NC10(MSM_NAND_FLASH_CMD);
+					cmd->len = 4;
+					cmd++;
+
+					/* kick the execute register for NC10 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.exec);
+					cmd->dst = NC10(MSM_NAND_EXEC_CMD);
+					cmd->len = 4;
+					cmd++;
+
+					/* Read only when there is data
+					 * buffer
+					 */
+					if (ops->datbuf) {
+						cmd->cmd = 0;
+						cmd->src =
+						NC01(MSM_NAND_FLASH_BUFFER);
+						cmd->dst = data_dma_addr_curr;
+						data_dma_addr_curr +=
+						sectordatasize;
+						cmd->len = sectordatasize;
+						cmd++;
+					}
+				} else {
+					/* MASK DATA ACK/REQ -->
+					 * NC01 (0xA3C)
+					 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+					data.adm_mux_data_ack_req_nc01);
+					cmd->dst = EBI2_NAND_ADM_MUX;
+					cmd->len = 4;
+					cmd++;
+
+					/* block on data ready from NC10
+					 * then read the status register
+					 */
+					cmd->cmd = SRC_CRCI_NAND_DATA;
+					cmd->src =
+					NC10(MSM_NAND_FLASH_STATUS);
+					cmd->dst = msm_virt_to_dma(chip,
+					   &dma_buffer->data.result[n]);
+					/* MSM_NAND_FLASH_STATUS +
+					 * MSM_NAND_BUFFER_STATUS
+					 */
+					cmd->len = 8;
+					cmd++;
+					if (n != cwperpage - 1) {
+						/* MASK CMD ACK/REQ -->
+						 * NC10 (0xF14)
+						 */
+						cmd->cmd = 0;
+						cmd->src =
+						msm_virt_to_dma(chip,
+						&dma_buffer->
+						data.adm_mux_cmd_ack_req_nc10);
+						cmd->dst = EBI2_NAND_ADM_MUX;
+						cmd->len = 4;
+						cmd++;
+
+						/* CMD */
+						cmd->cmd = DST_CRCI_NAND_CMD;
+						cmd->src = msm_virt_to_dma(chip,
+							&dma_buffer->data.cmd);
+						cmd->dst =
+						NC01(MSM_NAND_FLASH_CMD);
+						cmd->len = 4;
+						cmd++;
+
+						/* EXEC */
+						cmd->cmd = 0;
+						cmd->src = msm_virt_to_dma(chip,
+							&dma_buffer->data.exec);
+						cmd->dst =
+						NC01(MSM_NAND_EXEC_CMD);
+						cmd->len = 4;
+						cmd++;
+					}
+
+					/* Read only when there is data
+					 * buffer
+					 */
+					if (ops->datbuf) {
+						cmd->cmd = 0;
+						cmd->src =
+						NC10(MSM_NAND_FLASH_BUFFER);
+						cmd->dst = data_dma_addr_curr;
+						data_dma_addr_curr +=
+						sectordatasize;
+						cmd->len = sectordatasize;
+						cmd++;
+					}
+				}
+			}
+
+			if (ops->oobbuf && (n == (cwperpage - 1)
+			     || ops->mode != MTD_OOB_AUTO)) {
+				cmd->cmd = 0;
+				if (n == (cwperpage - 1)) {
+					/* Use NC10 for reading the
+					 * last codeword!!!
+					 */
+					cmd->src = NC10(MSM_NAND_FLASH_BUFFER) +
+						(512 - ((cwperpage - 1) << 2));
+					sectoroobsize = (cwperpage << 2);
+					if (ops->mode != MTD_OOB_AUTO)
+						sectoroobsize +=
+							chip->ecc_parity_bytes;
+				} else {
+					if (n % 2 == 0)
+						cmd->src =
+						NC01(MSM_NAND_FLASH_BUFFER)
+						+ 516;
+					else
+						cmd->src =
+						NC10(MSM_NAND_FLASH_BUFFER)
+						+ 516;
+					sectoroobsize = chip->ecc_parity_bytes;
+				}
+				cmd->dst = oob_dma_addr_curr;
+				if (sectoroobsize < oob_len)
+					cmd->len = sectoroobsize;
+				else
+					cmd->len = oob_len;
+				oob_dma_addr_curr += cmd->len;
+				oob_len -= cmd->len;
+				if (cmd->len > 0)
+					cmd++;
+			}
+		}
+		/* ADM --> Default mux state (0xFC0) */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_default_mux);
+		cmd->dst = EBI2_NAND_ADM_MUX;
+		cmd->len = 4;
+		cmd++;
+
+		if (!interleave_enable) {
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.nc10_flash_dev_cmd_vld_default);
+			cmd->dst = NC10(MSM_NAND_DEV_CMD_VLD);
 			cmd->len = 4;
 			cmd++;
 
-			/* clear the status register in case the OP_ERR is set
-			 * due to the write, to work around a h/w bug */
 			cmd->cmd = 0;
 			cmd->src = msm_virt_to_dma(chip,
-						   &dma_buffer->data.zeroes);
-			cmd->dst = MSM_NAND_FLASH_STATUS;
+			&dma_buffer->data.nc10_flash_dev_cmd1_default);
+			cmd->dst = NC10(MSM_NAND_DEV_CMD1);
 			cmd->len = 4;
 			cmd++;
-		}
-#if SUPPORT_WRONG_ECC_CONFIG
-		if (chip->saved_ecc_buf_cfg != chip->ecc_buf_cfg) {
-			dma_buffer->data.ecccfg_restore =
-				chip->saved_ecc_buf_cfg;
+		} else {
+			/* disable CS1 */
 			cmd->cmd = 0;
 			cmd->src = msm_virt_to_dma(chip,
-					      &dma_buffer->data.ecccfg_restore);
-			cmd->dst = MSM_NAND_EBI2_ECC_BUF_CFG;
+			&dma_buffer->data.default_ebi2_chip_select_cfg0);
+			cmd->dst = EBI2_CHIP_SELECT_CFG0;
 			cmd->len = 4;
 			cmd++;
 		}
-#endif
+
+		BUILD_BUG_ON(16 * 6 + 20 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
 		dma_buffer->cmd[0].cmd |= CMD_OCB;
 		cmd[-1].cmd |= CMD_OCU | CMD_LC;
-		BUILD_BUG_ON(8 * 6 + 3 != ARRAY_SIZE(dma_buffer->cmd));
-		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+
 		dma_buffer->cmdptr =
-			(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) |
-			CMD_PTR_LP;
+			(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3)
+			| CMD_PTR_LP;
 
+		mb();
 		msm_dmov_exec_cmd(chip->dma_channel,
-			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(
-				msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+			&dma_buffer->cmdptr)));
+		mb();
 
-		/* if any of the writes failed (0x10), or there was a
-		 * protection violation (0x100), or the program success
-		 * bit (0x80) is unset, we lose
+		/* if any of the writes failed (0x10), or there
+		 * was a protection violation (0x100), we lose
 		 */
-		err = 0;
-		for (n = 0; n <= chip->last_sector ; n++) {
-			if (dma_buffer->data.flash_status[n] & 0x110) {
-				if (dma_buffer->data.flash_status[n] & 0x10)
-					pr_err("msm_nand: critical write error,"
-					       " 0x%x(%d)\n", page, n);
-				err = -EIO;
+		pageerr = rawerr = 0;
+		for (n = start_sector; n < cwperpage; n++) {
+			if (dma_buffer->data.result[n].flash_status & 0x110) {
+				rawerr = -EIO;
 				break;
 			}
-			if (!(dma_buffer->data.flash_status[n] & 0x80)) {
-				err = -EIO;
-				break;
+		}
+		if (rawerr) {
+			if (ops->datbuf && ops->mode != MTD_OOB_RAW) {
+				uint8_t *datbuf = ops->datbuf +
+					pages_read * mtd->writesize;
+
+				dma_sync_single_for_cpu(chip->dev,
+					data_dma_addr_curr-mtd->writesize,
+					mtd->writesize, DMA_BIDIRECTIONAL);
+
+				for (n = 0; n < mtd->writesize; n++) {
+					/* empty blocks read 0x54 at
+					 * these offsets
+					 */
+					if ((n % 516 == 3 || n % 516 == 175)
+							&& datbuf[n] == 0x54)
+						datbuf[n] = 0xff;
+					if (datbuf[n] != 0xff) {
+						pageerr = rawerr;
+						break;
+					}
+				}
+
+				dma_sync_single_for_device(chip->dev,
+					data_dma_addr_curr-mtd->writesize,
+					mtd->writesize, DMA_BIDIRECTIONAL);
+
+			}
+			if (ops->oobbuf) {
+				dma_sync_single_for_cpu(chip->dev,
+				oob_dma_addr_curr - (ops->ooblen - oob_len),
+				ops->ooblen - oob_len, DMA_BIDIRECTIONAL);
+
+				for (n = 0; n < ops->ooblen; n++) {
+					if (ops->oobbuf[n] != 0xff) {
+						pageerr = rawerr;
+						break;
+					}
+				}
+
+				dma_sync_single_for_device(chip->dev,
+				oob_dma_addr_curr - (ops->ooblen - oob_len),
+				ops->ooblen - oob_len, DMA_BIDIRECTIONAL);
+			}
+		}
+		if (pageerr) {
+			for (n = start_sector; n < cwperpage; n++) {
+				if (dma_buffer->data.result[n].buffer_status
+					& MSM_NAND_BUF_STAT_UNCRCTBL_ERR) {
+					/* not thread safe */
+					mtd->ecc_stats.failed++;
+					pageerr = -EBADMSG;
+					break;
+				}
 			}
 		}
+		if (!rawerr) { /* check for corretable errors */
+			for (n = start_sector; n < cwperpage; n++) {
+				ecc_errors = dma_buffer->data.
+					result[n].buffer_status
+					& MSM_NAND_BUF_STAT_NUM_ERR_MASK;
+				if (ecc_errors) {
+					total_ecc_errors += ecc_errors;
+					/* not thread safe */
+					mtd->ecc_stats.corrected += ecc_errors;
+					if (ecc_errors > 1)
+						pageerr = -EUCLEAN;
+				}
+			}
+		}
+		if (pageerr && (pageerr != -EUCLEAN || err == 0))
+			err = pageerr;
 
 #if VERBOSE
-		pr_info("write page %d: status: %x %x %x %x %x %x %x %x\n",
-			page, dma_buffer->data.flash_status[0],
-			dma_buffer->data.flash_status[1],
-			dma_buffer->data.flash_status[2],
-			dma_buffer->data.flash_status[3],
-			dma_buffer->data.flash_status[4],
-			dma_buffer->data.flash_status[5],
-			dma_buffer->data.flash_status[6],
-			dma_buffer->data.flash_status[7]);
+		if (rawerr && !pageerr) {
+			pr_err("msm_nand_read_oob_dualnandc "
+				"%llx %x %x empty page\n",
+			       (loff_t)page * mtd->writesize, ops->len,
+			       ops->ooblen);
+		} else {
+			for (n = start_sector; n < cwperpage; n++) {
+				if (n%2) {
+					pr_info("NC10: flash_status[%d] = %x, "
+					 "buffr_status[%d] = %x\n",
+					n, dma_buffer->
+						data.result[n].flash_status,
+					n, dma_buffer->
+						data.result[n].buffer_status);
+				} else {
+					pr_info("NC01: flash_status[%d] = %x, "
+					 "buffr_status[%d] = %x\n",
+					n, dma_buffer->
+						data.result[n].flash_status,
+					n, dma_buffer->
+						data.result[n].buffer_status);
+				}
+			}
+		}
 #endif
-		if (err)
+		if (err && err != -EUCLEAN && err != -EBADMSG)
 			break;
-		pages_written++;
+		pages_read++;
 		page++;
 	}
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+	if (ops->oobbuf) {
+		dma_unmap_page(chip->dev, oob_dma_addr,
+				 ops->ooblen, DMA_FROM_DEVICE);
+	}
+err_dma_map_oobbuf_failed:
+	if (ops->datbuf) {
+		dma_unmap_page(chip->dev, data_dma_addr,
+				 ops->len, DMA_BIDIRECTIONAL);
+	}
+
 	if (ops->mode != MTD_OOB_RAW)
-		ops->retlen = mtd->writesize * pages_written;
+		ops->retlen = mtd->writesize * pages_read;
 	else
-		ops->retlen = (mtd->writesize + mtd->oobsize) * pages_written;
-
+		ops->retlen = (mtd->writesize +  mtd->oobsize) *
+							pages_read;
 	ops->oobretlen = ops->ooblen - oob_len;
+	if (err)
+		pr_err("msm_nand_read_oob_dualnandc "
+			"%llx %x %x failed %d, corrected %d\n",
+			from, ops->datbuf ? ops->len : 0, ops->ooblen, err,
+			total_ecc_errors);
+#if VERBOSE
+	pr_info("\n%s: ret %d, retlen %d oobretlen %d\n",
+			__func__, err, ops->retlen, ops->oobretlen);
+
+	pr_info("==================================================="
+			"==========\n");
+#endif
+	return err;
+}
+
+static int
+msm_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+	      size_t *retlen, u_char *buf)
+{
+	int ret;
+	struct mtd_oob_ops ops;
+
+	/* printk("msm_nand_read %llx %x\n", from, len); */
+
+	ops.mode = MTD_OOB_PLACE;
+	ops.len = len;
+	ops.retlen = 0;
+	ops.ooblen = 0;
+	ops.datbuf = buf;
+	ops.oobbuf = NULL;
+	if (!dual_nand_ctlr_present)
+		ret =  msm_nand_read_oob(mtd, from, &ops);
+	else
+		ret = msm_nand_read_oob_dualnandc(mtd, from, &ops);
+	*retlen = ops.retlen;
+	return ret;
+}
+
+static int
+msm_nand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+	struct {
+		dmov_s cmd[8 * 7 + 2];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t chipsel;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t eccbchcfg;
+			uint32_t exec;
+			uint32_t ecccfg;
+			uint32_t clrfstatus;
+			uint32_t clrrstatus;
+			uint32_t flash_status[8];
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+	unsigned n;
+	unsigned page = 0;
+	uint32_t oob_len;
+	uint32_t sectordatawritesize;
+	int err = 0;
+	dma_addr_t data_dma_addr = 0;
+	dma_addr_t oob_dma_addr = 0;
+	dma_addr_t data_dma_addr_curr = 0;
+	dma_addr_t oob_dma_addr_curr = 0;
+	unsigned page_count;
+	unsigned pages_written = 0;
+	unsigned cwperpage;
+#if VERBOSE
+	pr_info("================================================="
+			"================\n");
+	pr_info("%s:\nto 0x%llx mode %d\ndatbuf 0x%p datlen 0x%x"
+			"\noobbuf 0x%p ooblen 0x%x\n",
+			__func__, to, ops->mode, ops->datbuf, ops->len,
+			ops->oobbuf, ops->ooblen);
+#endif
+
+	if (mtd->writesize == 2048)
+		page = to >> 11;
+
+	if (mtd->writesize == 4096)
+		page = to >> 12;
+
+	oob_len = ops->ooblen;
+	cwperpage = (mtd->writesize >> 9);
+
+	if (to & (mtd->writesize - 1)) {
+		pr_err("%s: unsupported to, 0x%llx\n", __func__, to);
+		return -EINVAL;
+	}
+
+	if (ops->mode != MTD_OOB_RAW) {
+		if (ops->ooblen != 0 && ops->mode != MTD_OOB_AUTO) {
+			pr_err("%s: unsupported ops->mode,%d\n",
+					 __func__, ops->mode);
+			return -EINVAL;
+		}
+		if ((ops->len % mtd->writesize) != 0) {
+			pr_err("%s: unsupported ops->len, %d\n",
+					__func__, ops->len);
+			return -EINVAL;
+		}
+	} else {
+		if ((ops->len % (mtd->writesize + mtd->oobsize)) != 0) {
+			pr_err("%s: unsupported ops->len, "
+				"%d for MTD_OOB_RAW mode\n",
+				 __func__, ops->len);
+			return -EINVAL;
+		}
+	}
+
+	if (ops->datbuf == NULL) {
+		pr_err("%s: unsupported ops->datbuf == NULL\n", __func__);
+		return -EINVAL;
+	}
+	if (ops->mode != MTD_OOB_RAW && ops->ooblen != 0 && ops->ooboffs != 0) {
+		pr_err("%s: unsupported ops->ooboffs, %d\n",
+		       __func__, ops->ooboffs);
+		return -EINVAL;
+	}
+
+	if (ops->datbuf) {
+		data_dma_addr_curr = data_dma_addr =
+			msm_nand_dma_map(chip->dev, ops->datbuf,
+				       ops->len, DMA_TO_DEVICE);
+		if (dma_mapping_error(chip->dev, data_dma_addr)) {
+			pr_err("msm_nand_write_oob: failed to get dma addr "
+			       "for %p\n", ops->datbuf);
+			return -EIO;
+		}
+	}
+	if (ops->oobbuf) {
+		oob_dma_addr_curr = oob_dma_addr =
+			msm_nand_dma_map(chip->dev, ops->oobbuf,
+				       ops->ooblen, DMA_TO_DEVICE);
+		if (dma_mapping_error(chip->dev, oob_dma_addr)) {
+			pr_err("msm_nand_write_oob: failed to get dma addr "
+			       "for %p\n", ops->oobbuf);
+			err = -EIO;
+			goto err_dma_map_oobbuf_failed;
+		}
+	}
+	if (ops->mode != MTD_OOB_RAW)
+		page_count = ops->len / mtd->writesize;
+	else
+		page_count = ops->len / (mtd->writesize + mtd->oobsize);
+
+	wait_event(chip->wait_queue, (dma_buffer =
+			msm_nand_get_dma_buffer(chip, sizeof(*dma_buffer))));
+
+	while (page_count-- > 0) {
+		cmd = dma_buffer->cmd;
+
+		if (ops->mode != MTD_OOB_RAW) {
+			dma_buffer->data.cfg0 = chip->CFG0;
+			dma_buffer->data.cfg1 = chip->CFG1;
+			if (enable_bch_ecc)
+				dma_buffer->data.eccbchcfg = chip->ecc_bch_cfg;
+		} else {
+			dma_buffer->data.cfg0 = (chip->CFG0_RAW &
+					~(7U << 6)) | ((cwperpage-1) << 6);
+			dma_buffer->data.cfg1 = chip->CFG1_RAW |
+						(chip->CFG1 & CFG1_WIDE_FLASH);
+		}
+
+		/* CMD / ADDR0 / ADDR1 / CHIPSEL program values */
+		dma_buffer->data.cmd = MSM_NAND_CMD_PRG_PAGE;
+		dma_buffer->data.addr0 = page << 16;
+		dma_buffer->data.addr1 = (page >> 16) & 0xff;
+		/* chipsel_0 + enable DM interface */
+		dma_buffer->data.chipsel = 0 | 4;
+
+
+		/* GO bit for the EXEC register */
+		dma_buffer->data.exec = 1;
+		dma_buffer->data.clrfstatus = 0x00000020;
+		dma_buffer->data.clrrstatus = 0x000000C0;
+
+		BUILD_BUG_ON(8 != ARRAY_SIZE(dma_buffer->data.flash_status));
+
+		for (n = 0; n < cwperpage ; n++) {
+			/* status return words */
+			dma_buffer->data.flash_status[n] = 0xeeeeeeee;
+			/* block on cmd ready, then
+			 * write CMD / ADDR0 / ADDR1 / CHIPSEL regs in a burst
+			 */
+			cmd->cmd = DST_CRCI_NAND_CMD;
+			cmd->src =
+				msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+			cmd->dst = MSM_NAND_FLASH_CMD;
+			if (n == 0)
+				cmd->len = 16;
+			else
+				cmd->len = 4;
+			cmd++;
+
+			if (n == 0) {
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+							&dma_buffer->data.cfg0);
+				cmd->dst = MSM_NAND_DEV0_CFG0;
+				if (enable_bch_ecc)
+					cmd->len = 12;
+				else
+					cmd->len = 8;
+				cmd++;
+
+				dma_buffer->data.ecccfg = chip->ecc_buf_cfg;
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						 &dma_buffer->data.ecccfg);
+				cmd->dst = MSM_NAND_EBI2_ECC_BUF_CFG;
+				cmd->len = 4;
+				cmd++;
+			}
+
+			/* write data block */
+			if (ops->mode != MTD_OOB_RAW)
+				sectordatawritesize = (n < (cwperpage - 1)) ?
+					516 : (512 - ((cwperpage - 1) << 2));
+			else
+				sectordatawritesize = chip->cw_size;
+
+			cmd->cmd = 0;
+			cmd->src = data_dma_addr_curr;
+			data_dma_addr_curr += sectordatawritesize;
+			cmd->dst = MSM_NAND_FLASH_BUFFER;
+			cmd->len = sectordatawritesize;
+			cmd++;
+
+			if (ops->oobbuf) {
+				if (n == (cwperpage - 1)) {
+					cmd->cmd = 0;
+					cmd->src = oob_dma_addr_curr;
+					cmd->dst = MSM_NAND_FLASH_BUFFER +
+						(512 - ((cwperpage - 1) << 2));
+					if ((cwperpage << 2) < oob_len)
+						cmd->len = (cwperpage << 2);
+					else
+						cmd->len = oob_len;
+					oob_dma_addr_curr += cmd->len;
+					oob_len -= cmd->len;
+					if (cmd->len > 0)
+						cmd++;
+				}
+				if (ops->mode != MTD_OOB_AUTO) {
+					/* skip ecc bytes in oobbuf */
+					if (oob_len < chip->ecc_parity_bytes) {
+						oob_dma_addr_curr +=
+							chip->ecc_parity_bytes;
+						oob_len -=
+							chip->ecc_parity_bytes;
+					} else {
+						oob_dma_addr_curr += oob_len;
+						oob_len = 0;
+					}
+				}
+			}
+
+			/* kick the execute register */
+			cmd->cmd = 0;
+			cmd->src =
+				msm_virt_to_dma(chip, &dma_buffer->data.exec);
+			cmd->dst = MSM_NAND_EXEC_CMD;
+			cmd->len = 4;
+			cmd++;
+
+			/* block on data ready, then
+			 * read the status register
+			 */
+			cmd->cmd = SRC_CRCI_NAND_DATA;
+			cmd->src = MSM_NAND_FLASH_STATUS;
+			cmd->dst = msm_virt_to_dma(chip,
+					     &dma_buffer->data.flash_status[n]);
+			cmd->len = 4;
+			cmd++;
+
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.clrfstatus);
+			cmd->dst = MSM_NAND_FLASH_STATUS;
+			cmd->len = 4;
+			cmd++;
+
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.clrrstatus);
+			cmd->dst = MSM_NAND_READ_STATUS;
+			cmd->len = 4;
+			cmd++;
+
+		}
+
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
+		BUILD_BUG_ON(8 * 7 + 2 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmdptr =
+			(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) |
+			CMD_PTR_LP;
+
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(
+				msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+		mb();
+
+		/* if any of the writes failed (0x10), or there was a
+		 * protection violation (0x100), or the program success
+		 * bit (0x80) is unset, we lose
+		 */
+		err = 0;
+		for (n = 0; n < cwperpage; n++) {
+			if (dma_buffer->data.flash_status[n] & 0x110) {
+				err = -EIO;
+				break;
+			}
+			if (!(dma_buffer->data.flash_status[n] & 0x80)) {
+				err = -EIO;
+				break;
+			}
+		}
+
+#if VERBOSE
+		for (n = 0; n < cwperpage; n++)
+			pr_info("write pg %d: flash_status[%d] = %x\n", page,
+				n, dma_buffer->data.flash_status[n]);
+
+#endif
+		if (err)
+			break;
+		pages_written++;
+		page++;
+	}
+	if (ops->mode != MTD_OOB_RAW)
+		ops->retlen = mtd->writesize * pages_written;
+	else
+		ops->retlen = (mtd->writesize + mtd->oobsize) * pages_written;
+
+	ops->oobretlen = ops->ooblen - oob_len;
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+	if (ops->oobbuf)
+		dma_unmap_page(chip->dev, oob_dma_addr,
+				 ops->ooblen, DMA_TO_DEVICE);
+err_dma_map_oobbuf_failed:
+	if (ops->datbuf)
+		dma_unmap_page(chip->dev, data_dma_addr, ops->len,
+				DMA_TO_DEVICE);
+	if (err)
+		pr_err("msm_nand_write_oob %llx %x %x failed %d\n",
+		       to, ops->len, ops->ooblen, err);
+
+#if VERBOSE
+		pr_info("\n%s: ret %d, retlen %d oobretlen %d\n",
+				__func__, err, ops->retlen, ops->oobretlen);
+
+		pr_info("==================================================="
+				"==============\n");
+#endif
+	return err;
+}
+
+static int
+msm_nand_write_oob_dualnandc(struct mtd_info *mtd, loff_t to,
+				struct mtd_oob_ops *ops)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+	struct {
+		dmov_s cmd[16 * 6 + 18];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t nandc01_addr0;
+			uint32_t nandc10_addr0;
+			uint32_t nandc11_addr1;
+			uint32_t chipsel_cs0;
+			uint32_t chipsel_cs1;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t eccbchcfg;
+			uint32_t exec;
+			uint32_t ecccfg;
+			uint32_t cfg0_nc01;
+			uint32_t ebi2_chip_select_cfg0;
+			uint32_t adm_mux_data_ack_req_nc01;
+			uint32_t adm_mux_cmd_ack_req_nc01;
+			uint32_t adm_mux_data_ack_req_nc10;
+			uint32_t adm_mux_cmd_ack_req_nc10;
+			uint32_t adm_default_mux;
+			uint32_t default_ebi2_chip_select_cfg0;
+			uint32_t nc01_flash_dev_cmd_vld;
+			uint32_t nc10_flash_dev_cmd0;
+			uint32_t nc01_flash_dev_cmd_vld_default;
+			uint32_t nc10_flash_dev_cmd0_default;
+			uint32_t flash_status[16];
+			uint32_t clrfstatus;
+			uint32_t clrrstatus;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+	unsigned n;
+	unsigned page = 0;
+	uint32_t oob_len;
+	uint32_t sectordatawritesize;
+	int err = 0;
+	dma_addr_t data_dma_addr = 0;
+	dma_addr_t oob_dma_addr = 0;
+	dma_addr_t data_dma_addr_curr = 0;
+	dma_addr_t oob_dma_addr_curr = 0;
+	unsigned page_count;
+	unsigned pages_written = 0;
+	unsigned cwperpage;
+	unsigned cw_offset = chip->cw_size;
+#if VERBOSE
+		pr_info("================================================="
+				"============\n");
+		pr_info("%s:\nto 0x%llx mode %d\ndatbuf 0x%p datlen 0x%x"
+				"\noobbuf 0x%p ooblen 0x%x\n\n",
+				__func__, to, ops->mode, ops->datbuf, ops->len,
+				ops->oobbuf, ops->ooblen);
+#endif
+
+	if (mtd->writesize == 2048)
+		page = to >> 11;
+
+	if (mtd->writesize == 4096)
+		page = to >> 12;
+
+	if (interleave_enable)
+		page = (to >> 1) >> 12;
+
+	oob_len = ops->ooblen;
+	cwperpage = (mtd->writesize >> 9);
+
+	if (to & (mtd->writesize - 1)) {
+		pr_err("%s: unsupported to, 0x%llx\n", __func__, to);
+		return -EINVAL;
+	}
+
+	if (ops->mode != MTD_OOB_RAW) {
+		if (ops->ooblen != 0 && ops->mode != MTD_OOB_AUTO) {
+			pr_err("%s: unsupported ops->mode,%d\n",
+					 __func__, ops->mode);
+			return -EINVAL;
+		}
+		if ((ops->len % mtd->writesize) != 0) {
+			pr_err("%s: unsupported ops->len, %d\n",
+					__func__, ops->len);
+			return -EINVAL;
+		}
+	} else {
+		if ((ops->len % (mtd->writesize + mtd->oobsize)) != 0) {
+			pr_err("%s: unsupported ops->len, "
+				"%d for MTD_OOB_RAW mode\n",
+				 __func__, ops->len);
+			return -EINVAL;
+		}
+	}
+
+	if (ops->datbuf == NULL) {
+		pr_err("%s: unsupported ops->datbuf == NULL\n", __func__);
+		return -EINVAL;
+	}
+
+	if (ops->mode != MTD_OOB_RAW && ops->ooblen != 0 && ops->ooboffs != 0) {
+		pr_err("%s: unsupported ops->ooboffs, %d\n",
+		       __func__, ops->ooboffs);
+		return -EINVAL;
+	}
+
+	if (ops->datbuf) {
+		data_dma_addr_curr = data_dma_addr =
+			msm_nand_dma_map(chip->dev, ops->datbuf,
+				       ops->len, DMA_TO_DEVICE);
+		if (dma_mapping_error(chip->dev, data_dma_addr)) {
+			pr_err("msm_nand_write_oob_dualnandc:"
+				"failed to get dma addr "
+			       "for %p\n", ops->datbuf);
+			return -EIO;
+		}
+	}
+	if (ops->oobbuf) {
+		oob_dma_addr_curr = oob_dma_addr =
+			msm_nand_dma_map(chip->dev, ops->oobbuf,
+				       ops->ooblen, DMA_TO_DEVICE);
+		if (dma_mapping_error(chip->dev, oob_dma_addr)) {
+			pr_err("msm_nand_write_oob_dualnandc:"
+				"failed to get dma addr "
+			       "for %p\n", ops->oobbuf);
+			err = -EIO;
+			goto err_dma_map_oobbuf_failed;
+		}
+	}
+	if (ops->mode != MTD_OOB_RAW)
+		page_count = ops->len / mtd->writesize;
+	else
+		page_count = ops->len / (mtd->writesize + mtd->oobsize);
+
+	wait_event(chip->wait_queue, (dma_buffer =
+			msm_nand_get_dma_buffer(chip, sizeof(*dma_buffer))));
+
+	if (chip->CFG1 & CFG1_WIDE_FLASH)
+		cw_offset >>= 1;
+
+	dma_buffer->data.ebi2_chip_select_cfg0 = 0x00000805;
+	dma_buffer->data.adm_mux_data_ack_req_nc01 = 0x00000A3C;
+	dma_buffer->data.adm_mux_cmd_ack_req_nc01  = 0x0000053C;
+	dma_buffer->data.adm_mux_data_ack_req_nc10 = 0x00000F28;
+	dma_buffer->data.adm_mux_cmd_ack_req_nc10  = 0x00000F14;
+	dma_buffer->data.adm_default_mux = 0x00000FC0;
+	dma_buffer->data.default_ebi2_chip_select_cfg0 = 0x00000801;
+	dma_buffer->data.nc01_flash_dev_cmd_vld = 0x9;
+	dma_buffer->data.nc10_flash_dev_cmd0 = 0x1085D060;
+	dma_buffer->data.nc01_flash_dev_cmd_vld_default = 0x1D;
+	dma_buffer->data.nc10_flash_dev_cmd0_default = 0x1080D060;
+	dma_buffer->data.clrfstatus = 0x00000020;
+	dma_buffer->data.clrrstatus = 0x000000C0;
+
+	while (page_count-- > 0) {
+		cmd = dma_buffer->cmd;
+
+		if (ops->mode != MTD_OOB_RAW) {
+			dma_buffer->data.cfg0 = ((chip->CFG0 & ~(7U << 6))
+				& ~(1 << 4)) | ((((cwperpage >> 1)-1)) << 6);
+			dma_buffer->data.cfg1 = chip->CFG1;
+			if (enable_bch_ecc)
+				dma_buffer->data.eccbchcfg = chip->ecc_bch_cfg;
+		} else {
+			dma_buffer->data.cfg0 = ((chip->CFG0_RAW &
+			~(7U << 6)) & ~(1 << 4)) | (((cwperpage >> 1)-1) << 6);
+			dma_buffer->data.cfg1 = chip->CFG1_RAW |
+					(chip->CFG1 & CFG1_WIDE_FLASH);
+		}
+
+		/* Disables the automatic issuing of the read
+		 * status command for first NAND controller.
+		 */
+		if (!interleave_enable)
+			dma_buffer->data.cfg0_nc01 = dma_buffer->data.cfg0
+							| (1 << 4);
+		else
+			dma_buffer->data.cfg0 |= (1 << 4);
+
+		dma_buffer->data.cmd = MSM_NAND_CMD_PRG_PAGE;
+		dma_buffer->data.chipsel_cs0 = (1<<4) | 4;
+		dma_buffer->data.chipsel_cs1 = (1<<4) | 5;
+
+		/* GO bit for the EXEC register */
+		dma_buffer->data.exec = 1;
+
+		if (!interleave_enable) {
+			dma_buffer->data.nandc01_addr0 = (page << 16) | 0x0;
+			/* NC10 ADDR0 points to the next code word */
+			dma_buffer->data.nandc10_addr0 =
+					(page << 16) | cw_offset;
+		} else {
+			dma_buffer->data.nandc01_addr0 =
+			dma_buffer->data.nandc10_addr0 = (page << 16) | 0x0;
+		}
+		/* ADDR1 */
+		dma_buffer->data.nandc11_addr1 = (page >> 16) & 0xff;
+
+		BUILD_BUG_ON(16 != ARRAY_SIZE(dma_buffer->data.flash_status));
+
+		for (n = 0; n < cwperpage; n++) {
+			/* status return words */
+			dma_buffer->data.flash_status[n] = 0xeeeeeeee;
+
+			if (n == 0) {
+				if (!interleave_enable) {
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+					data.nc01_flash_dev_cmd_vld);
+					cmd->dst = NC01(MSM_NAND_DEV_CMD_VLD);
+					cmd->len = 4;
+					cmd++;
+
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nc10_flash_dev_cmd0);
+					cmd->dst = NC10(MSM_NAND_DEV_CMD0);
+					cmd->len = 4;
+					cmd++;
+
+					/* common settings for both NC01 & NC10
+					 * NC01, NC10 --> ADDR1 / CHIPSEL
+					 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc11_addr1);
+					cmd->dst = NC11(MSM_NAND_ADDR1);
+					cmd->len = 8;
+					cmd++;
+
+					/* Disables the automatic issue of the
+					 * read status command after the write
+					 * operation.
+					 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cfg0_nc01);
+					cmd->dst = NC01(MSM_NAND_DEV0_CFG0);
+					cmd->len = 4;
+					cmd++;
+
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cfg0);
+					cmd->dst = NC10(MSM_NAND_DEV0_CFG0);
+					cmd->len = 4;
+					cmd++;
+
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cfg1);
+					cmd->dst = NC11(MSM_NAND_DEV0_CFG1);
+					if (enable_bch_ecc)
+						cmd->len = 8;
+					else
+						cmd->len = 4;
+					cmd++;
+				} else {
+					/* enable CS1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+					data.ebi2_chip_select_cfg0);
+					cmd->dst = EBI2_CHIP_SELECT_CFG0;
+					cmd->len = 4;
+					cmd++;
+
+					/* NC11 --> ADDR1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc11_addr1);
+					cmd->dst = NC11(MSM_NAND_ADDR1);
+					cmd->len = 4;
+					cmd++;
+
+					/* Enable CS0 for NC01 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.chipsel_cs0);
+					cmd->dst =
+					NC01(MSM_NAND_FLASH_CHIP_SELECT);
+					cmd->len = 4;
+					cmd++;
+
+					/* Enable CS1 for NC10 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.chipsel_cs1);
+					cmd->dst =
+					NC10(MSM_NAND_FLASH_CHIP_SELECT);
+					cmd->len = 4;
+					cmd++;
+
+					/* config DEV0_CFG0 & CFG1 for CS0 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cfg0);
+					cmd->dst = NC01(MSM_NAND_DEV0_CFG0);
+					cmd->len = 8;
+					cmd++;
+
+					/* config DEV1_CFG0 & CFG1 for CS1 */
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.cfg0);
+					cmd->dst = NC10(MSM_NAND_DEV1_CFG0);
+					cmd->len = 8;
+					cmd++;
+				}
+
+				dma_buffer->data.ecccfg = chip->ecc_buf_cfg;
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.ecccfg);
+				cmd->dst = NC11(MSM_NAND_EBI2_ECC_BUF_CFG);
+				cmd->len = 4;
+				cmd++;
+
+				/* NC01 --> ADDR0 */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.nandc01_addr0);
+				cmd->dst = NC01(MSM_NAND_ADDR0);
+				cmd->len = 4;
+				cmd++;
+
+				/* NC10 --> ADDR0 */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.nandc10_addr0);
+				cmd->dst = NC10(MSM_NAND_ADDR0);
+				cmd->len = 4;
+				cmd++;
+			}
+
+			if (n % 2 == 0) {
+				/* MASK CMD ACK/REQ --> NC10 (0xF14)*/
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.adm_mux_cmd_ack_req_nc10);
+				cmd->dst = EBI2_NAND_ADM_MUX;
+				cmd->len = 4;
+				cmd++;
+
+				/* CMD */
+				cmd->cmd = DST_CRCI_NAND_CMD;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cmd);
+				cmd->dst = NC01(MSM_NAND_FLASH_CMD);
+				cmd->len = 4;
+				cmd++;
+			} else {
+				/* MASK CMD ACK/REQ --> NC01 (0x53C)*/
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.adm_mux_cmd_ack_req_nc01);
+				cmd->dst = EBI2_NAND_ADM_MUX;
+				cmd->len = 4;
+				cmd++;
+
+				/* CMD */
+				cmd->cmd = DST_CRCI_NAND_CMD;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.cmd);
+				cmd->dst = NC10(MSM_NAND_FLASH_CMD);
+				cmd->len = 4;
+				cmd++;
+			}
+
+			if (ops->mode != MTD_OOB_RAW)
+				sectordatawritesize = (n < (cwperpage - 1)) ?
+					516 : (512 - ((cwperpage - 1) << 2));
+			else
+				sectordatawritesize = chip->cw_size;
+
+			cmd->cmd = 0;
+			cmd->src = data_dma_addr_curr;
+			data_dma_addr_curr += sectordatawritesize;
+
+			if (n % 2 == 0)
+				cmd->dst = NC01(MSM_NAND_FLASH_BUFFER);
+			else
+				cmd->dst = NC10(MSM_NAND_FLASH_BUFFER);
+			cmd->len = sectordatawritesize;
+			cmd++;
+
+			if (ops->oobbuf) {
+				if (n == (cwperpage - 1)) {
+					cmd->cmd = 0;
+					cmd->src = oob_dma_addr_curr;
+					cmd->dst = NC10(MSM_NAND_FLASH_BUFFER) +
+						(512 - ((cwperpage - 1) << 2));
+					if ((cwperpage << 2) < oob_len)
+						cmd->len = (cwperpage << 2);
+					else
+						cmd->len = oob_len;
+					oob_dma_addr_curr += cmd->len;
+					oob_len -= cmd->len;
+					if (cmd->len > 0)
+						cmd++;
+				}
+				if (ops->mode != MTD_OOB_AUTO) {
+					/* skip ecc bytes in oobbuf */
+					if (oob_len < chip->ecc_parity_bytes) {
+						oob_dma_addr_curr +=
+							chip->ecc_parity_bytes;
+						oob_len -=
+							chip->ecc_parity_bytes;
+					} else {
+						oob_dma_addr_curr += oob_len;
+						oob_len = 0;
+					}
+				}
+			}
+
+			if (n % 2 == 0) {
+				if (n != 0) {
+					/* MASK DATA ACK/REQ --> NC01 (0xA3C)*/
+					cmd->cmd = 0;
+					cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->
+					data.adm_mux_data_ack_req_nc01);
+					cmd->dst = EBI2_NAND_ADM_MUX;
+					cmd->len = 4;
+					cmd++;
+
+					/* block on data ready from NC10, then
+					* read the status register
+					*/
+					cmd->cmd = SRC_CRCI_NAND_DATA;
+					cmd->src = NC10(MSM_NAND_FLASH_STATUS);
+					cmd->dst = msm_virt_to_dma(chip,
+					&dma_buffer->data.flash_status[n-1]);
+					cmd->len = 4;
+					cmd++;
+				}
+				/* kick the NC01 execute register */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.exec);
+				cmd->dst = NC01(MSM_NAND_EXEC_CMD);
+				cmd->len = 4;
+				cmd++;
+			} else {
+				/* MASK DATA ACK/REQ --> NC10 (0xF28)*/
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.adm_mux_data_ack_req_nc10);
+				cmd->dst = EBI2_NAND_ADM_MUX;
+				cmd->len = 4;
+				cmd++;
+
+				/* block on data ready from NC01, then
+				 * read the status register
+				 */
+				cmd->cmd = SRC_CRCI_NAND_DATA;
+				cmd->src = NC01(MSM_NAND_FLASH_STATUS);
+				cmd->dst = msm_virt_to_dma(chip,
+				&dma_buffer->data.flash_status[n-1]);
+				cmd->len = 4;
+				cmd++;
+
+				/* kick the execute register */
+				cmd->cmd = 0;
+				cmd->src =
+				msm_virt_to_dma(chip, &dma_buffer->data.exec);
+				cmd->dst = NC10(MSM_NAND_EXEC_CMD);
+				cmd->len = 4;
+				cmd++;
+			}
+		}
+
+		/* MASK DATA ACK/REQ --> NC01 (0xA3C)*/
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.adm_mux_data_ack_req_nc01);
+		cmd->dst = EBI2_NAND_ADM_MUX;
+		cmd->len = 4;
+		cmd++;
+
+		/* we should process outstanding request */
+		/* block on data ready, then
+		 * read the status register
+		 */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = NC10(MSM_NAND_FLASH_STATUS);
+		cmd->dst = msm_virt_to_dma(chip,
+			     &dma_buffer->data.flash_status[n-1]);
+		cmd->len = 4;
+		cmd++;
+
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.clrfstatus);
+		cmd->dst = NC11(MSM_NAND_FLASH_STATUS);
+		cmd->len = 4;
+		cmd++;
+
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.clrrstatus);
+		cmd->dst = NC11(MSM_NAND_READ_STATUS);
+		cmd->len = 4;
+		cmd++;
+
+		/* MASK DATA ACK/REQ --> NC01 (0xFC0)*/
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip,
+				&dma_buffer->data.adm_default_mux);
+		cmd->dst = EBI2_NAND_ADM_MUX;
+		cmd->len = 4;
+		cmd++;
+
+		if (!interleave_enable) {
+			/* setting to defalut values back */
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.nc01_flash_dev_cmd_vld_default);
+			cmd->dst = NC01(MSM_NAND_DEV_CMD_VLD);
+			cmd->len = 4;
+			cmd++;
+
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.nc10_flash_dev_cmd0_default);
+			cmd->dst = NC10(MSM_NAND_DEV_CMD0);
+			cmd->len = 4;
+			cmd++;
+		} else {
+			/* disable CS1 */
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.default_ebi2_chip_select_cfg0);
+			cmd->dst = EBI2_CHIP_SELECT_CFG0;
+			cmd->len = 4;
+			cmd++;
+		}
+
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
+		BUILD_BUG_ON(16 * 6 + 18 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmdptr =
+		((msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) | CMD_PTR_LP);
+
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(
+				msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+		mb();
+
+		/* if any of the writes failed (0x10), or there was a
+		 * protection violation (0x100), or the program success
+		 * bit (0x80) is unset, we lose
+		 */
+		err = 0;
+		for (n = 0; n < cwperpage; n++) {
+			if (dma_buffer->data.flash_status[n] & 0x110) {
+				err = -EIO;
+				break;
+			}
+			if (!(dma_buffer->data.flash_status[n] & 0x80)) {
+				err = -EIO;
+				break;
+			}
+		}
+		/* check for flash status busy for the last codeword */
+		if (!interleave_enable)
+			if (!(dma_buffer->data.flash_status[cwperpage - 1]
+								& 0x20)) {
+				err = -EIO;
+				break;
+			}
+#if VERBOSE
+	for (n = 0; n < cwperpage; n++) {
+		if (n%2) {
+			pr_info("NC10: write pg %d: flash_status[%d] = %x\n",
+				page, n, dma_buffer->data.flash_status[n]);
+		} else {
+			pr_info("NC01: write pg %d: flash_status[%d] = %x\n",
+				page, n, dma_buffer->data.flash_status[n]);
+		}
+	}
+#endif
+		if (err)
+			break;
+		pages_written++;
+		page++;
+	}
+	if (ops->mode != MTD_OOB_RAW)
+		ops->retlen = mtd->writesize * pages_written;
+	else
+		ops->retlen = (mtd->writesize + mtd->oobsize) * pages_written;
+
+	ops->oobretlen = ops->ooblen - oob_len;
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+	if (ops->oobbuf)
+		dma_unmap_page(chip->dev, oob_dma_addr,
+				 ops->ooblen, DMA_TO_DEVICE);
+err_dma_map_oobbuf_failed:
+	if (ops->datbuf)
+		dma_unmap_page(chip->dev, data_dma_addr, ops->len,
+				DMA_TO_DEVICE);
+	if (err)
+		pr_err("msm_nand_write_oob_dualnandc %llx %x %x failed %d\n",
+		       to, ops->len, ops->ooblen, err);
+
+#if VERBOSE
+	pr_info("\n%s: ret %d, retlen %d oobretlen %d\n",
+			__func__, err, ops->retlen, ops->oobretlen);
+
+	pr_info("==================================================="
+			"==========\n");
+#endif
+	return err;
+}
+
+static int msm_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const u_char *buf)
+{
+	int ret;
+	struct mtd_oob_ops ops;
+
+	ops.mode = MTD_OOB_PLACE;
+	ops.len = len;
+	ops.retlen = 0;
+	ops.ooblen = 0;
+	ops.datbuf = (uint8_t *)buf;
+	ops.oobbuf = NULL;
+	if (!dual_nand_ctlr_present)
+		ret =  msm_nand_write_oob(mtd, to, &ops);
+	else
+		ret =  msm_nand_write_oob_dualnandc(mtd, to, &ops);
+	*retlen = ops.retlen;
+	return ret;
+}
+
+static int
+msm_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	int err;
+	struct msm_nand_chip *chip = mtd->priv;
+	struct {
+		dmov_s cmd[6];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t chipsel;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t exec;
+			uint32_t flash_status;
+			uint32_t clrfstatus;
+			uint32_t clrrstatus;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+	unsigned page = 0;
+
+	if (mtd->writesize == 2048)
+		page = instr->addr >> 11;
+
+	if (mtd->writesize == 4096)
+		page = instr->addr >> 12;
+
+	if (instr->addr & (mtd->erasesize - 1)) {
+		pr_err("%s: unsupported erase address, 0x%llx\n",
+		       __func__, instr->addr);
+		return -EINVAL;
+	}
+	if (instr->len != mtd->erasesize) {
+		pr_err("%s: unsupported erase len, %lld\n",
+		       __func__, instr->len);
+		return -EINVAL;
+	}
+
+	wait_event(chip->wait_queue,
+		   (dma_buffer = msm_nand_get_dma_buffer(
+			    chip, sizeof(*dma_buffer))));
+
+	cmd = dma_buffer->cmd;
+
+	dma_buffer->data.cmd = MSM_NAND_CMD_BLOCK_ERASE;
+	dma_buffer->data.addr0 = page;
+	dma_buffer->data.addr1 = 0;
+	dma_buffer->data.chipsel = 0 | 4;
+	dma_buffer->data.exec = 1;
+	dma_buffer->data.flash_status = 0xeeeeeeee;
+	dma_buffer->data.cfg0 = chip->CFG0 & (~(7 << 6));  /* CW_PER_PAGE = 0 */
+	dma_buffer->data.cfg1 = chip->CFG1;
+	dma_buffer->data.clrfstatus = 0x00000020;
+	dma_buffer->data.clrrstatus = 0x000000C0;
+
+	cmd->cmd = DST_CRCI_NAND_CMD | CMD_OCB;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = MSM_NAND_FLASH_CMD;
+	cmd->len = 16;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
+	cmd->dst = MSM_NAND_DEV0_CFG0;
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = MSM_NAND_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_FLASH_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.flash_status);
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.clrfstatus);
+	cmd->dst = MSM_NAND_FLASH_STATUS;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = CMD_OCU | CMD_LC;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.clrrstatus);
+	cmd->dst = MSM_NAND_READ_STATUS;
+	cmd->len = 4;
+	cmd++;
+
+	BUILD_BUG_ON(5 != ARRAY_SIZE(dma_buffer->cmd) - 1);
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+	dma_buffer->cmdptr =
+		(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(
+		chip->dma_channel, DMOV_CMD_PTR_LIST |
+		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
+
+	/* we fail if there was an operation error, a mpu error, or the
+	 * erase success bit was not set.
+	 */
+
+	if (dma_buffer->data.flash_status & 0x110 ||
+			!(dma_buffer->data.flash_status & 0x80))
+		err = -EIO;
+	else
+		err = 0;
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+	if (err) {
+		pr_err("%s: erase failed, 0x%llx\n", __func__, instr->addr);
+		instr->fail_addr = instr->addr;
+		instr->state = MTD_ERASE_FAILED;
+	} else {
+		instr->state = MTD_ERASE_DONE;
+		instr->fail_addr = 0xffffffff;
+		mtd_erase_callback(instr);
+	}
+	return err;
+}
+
+static int
+msm_nand_erase_dualnandc(struct mtd_info *mtd, struct erase_info *instr)
+{
+	int err;
+	struct msm_nand_chip *chip = mtd->priv;
+	struct {
+		dmov_s cmd[18];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t chipsel_cs0;
+			uint32_t chipsel_cs1;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t exec;
+			uint32_t ecccfg;
+			uint32_t ebi2_chip_select_cfg0;
+			uint32_t adm_mux_data_ack_req_nc01;
+			uint32_t adm_mux_cmd_ack_req_nc01;
+			uint32_t adm_mux_data_ack_req_nc10;
+			uint32_t adm_mux_cmd_ack_req_nc10;
+			uint32_t adm_default_mux;
+			uint32_t default_ebi2_chip_select_cfg0;
+			uint32_t nc01_flash_dev_cmd0;
+			uint32_t nc01_flash_dev_cmd0_default;
+			uint32_t flash_status[2];
+			uint32_t clrfstatus;
+			uint32_t clrrstatus;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+	unsigned page = 0;
+
+	if (mtd->writesize == 2048)
+		page = instr->addr >> 11;
+
+	if (mtd->writesize == 4096)
+		page = instr->addr >> 12;
+
+	if (mtd->writesize == 8192)
+		page = (instr->addr >> 1) >> 12;
+
+	if (instr->addr & (mtd->erasesize - 1)) {
+		pr_err("%s: unsupported erase address, 0x%llx\n",
+		       __func__, instr->addr);
+		return -EINVAL;
+	}
+	if (instr->len != mtd->erasesize) {
+		pr_err("%s: unsupported erase len, %lld\n",
+		       __func__, instr->len);
+		return -EINVAL;
+	}
+
+	wait_event(chip->wait_queue,
+		   (dma_buffer = msm_nand_get_dma_buffer(
+			    chip, sizeof(*dma_buffer))));
+
+	cmd = dma_buffer->cmd;
+
+	dma_buffer->data.cmd = MSM_NAND_CMD_BLOCK_ERASE;
+	dma_buffer->data.addr0 = page;
+	dma_buffer->data.addr1 = 0;
+	dma_buffer->data.chipsel_cs0 = (1<<4) | 4;
+	dma_buffer->data.chipsel_cs1 = (1<<4) | 5;
+	dma_buffer->data.exec = 1;
+	dma_buffer->data.flash_status[0] = 0xeeeeeeee;
+	dma_buffer->data.flash_status[1] = 0xeeeeeeee;
+	dma_buffer->data.cfg0 = chip->CFG0 & (~(7 << 6));  /* CW_PER_PAGE = 0 */
+	dma_buffer->data.cfg1 = chip->CFG1;
+	dma_buffer->data.clrfstatus = 0x00000020;
+	dma_buffer->data.clrrstatus = 0x000000C0;
+
+	dma_buffer->data.ebi2_chip_select_cfg0 = 0x00000805;
+	dma_buffer->data.adm_mux_data_ack_req_nc01 = 0x00000A3C;
+	dma_buffer->data.adm_mux_cmd_ack_req_nc01  = 0x0000053C;
+	dma_buffer->data.adm_mux_data_ack_req_nc10 = 0x00000F28;
+	dma_buffer->data.adm_mux_cmd_ack_req_nc10  = 0x00000F14;
+	dma_buffer->data.adm_default_mux = 0x00000FC0;
+	dma_buffer->data.default_ebi2_chip_select_cfg0 = 0x00000801;
+
+	/* enable CS1 */
+	cmd->cmd = 0 | CMD_OCB;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.ebi2_chip_select_cfg0);
+	cmd->dst = EBI2_CHIP_SELECT_CFG0;
+	cmd->len = 4;
+	cmd++;
+
+	/* erase CS0 block now !!! */
+	/* 0xF14 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_mux_cmd_ack_req_nc10);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = NC01(MSM_NAND_FLASH_CMD);
+	cmd->len = 16;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
+	cmd->dst = NC01(MSM_NAND_DEV0_CFG0);
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = NC01(MSM_NAND_EXEC_CMD);
+	cmd->len = 4;
+	cmd++;
+
+	/* 0xF28 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_mux_data_ack_req_nc10);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = NC01(MSM_NAND_FLASH_STATUS);
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.flash_status[0]);
+	cmd->len = 4;
+	cmd++;
+
+	/* erase CS1 block now !!! */
+	/* 0x53C */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			       &dma_buffer->data.adm_mux_cmd_ack_req_nc01);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = NC10(MSM_NAND_FLASH_CMD);
+	cmd->len = 12;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.chipsel_cs1);
+	cmd->dst = NC10(MSM_NAND_FLASH_CHIP_SELECT);
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
+	cmd->dst = NC10(MSM_NAND_DEV1_CFG0);
+	cmd->len = 8;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = NC10(MSM_NAND_EXEC_CMD);
+	cmd->len = 4;
+	cmd++;
+
+	/* 0xA3C */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			     &dma_buffer->data.adm_mux_data_ack_req_nc01);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = NC10(MSM_NAND_FLASH_STATUS);
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.flash_status[1]);
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.clrfstatus);
+	cmd->dst = NC11(MSM_NAND_FLASH_STATUS);
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.clrrstatus);
+	cmd->dst = NC11(MSM_NAND_READ_STATUS);
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_default_mux);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	/* disable CS1 */
+	cmd->cmd = CMD_OCU | CMD_LC;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.default_ebi2_chip_select_cfg0);
+	cmd->dst = EBI2_CHIP_SELECT_CFG0;
+	cmd->len = 4;
+	cmd++;
+
+	BUILD_BUG_ON(17 != ARRAY_SIZE(dma_buffer->cmd) - 1);
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+
+	dma_buffer->cmdptr =
+		(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(
+		chip->dma_channel, DMOV_CMD_PTR_LIST |
+		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
+
+	/* we fail if there was an operation error, a mpu error, or the
+	 * erase success bit was not set.
+	 */
+
+	if (dma_buffer->data.flash_status[0] & 0x110 ||
+			!(dma_buffer->data.flash_status[0] & 0x80) ||
+			dma_buffer->data.flash_status[1] & 0x110 ||
+			!(dma_buffer->data.flash_status[1] & 0x80))
+		err = -EIO;
+	else
+		err = 0;
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+	if (err) {
+		pr_err("%s: erase failed, 0x%llx\n", __func__, instr->addr);
+		instr->fail_addr = instr->addr;
+		instr->state = MTD_ERASE_FAILED;
+	} else {
+		instr->state = MTD_ERASE_DONE;
+		instr->fail_addr = 0xffffffff;
+		mtd_erase_callback(instr);
+	}
+	return err;
+}
+
+static int
+msm_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+	int ret;
+	struct {
+		dmov_s cmd[5];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t chipsel;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t eccbchcfg;
+			uint32_t exec;
+			uint32_t ecccfg;
+			struct {
+				uint32_t flash_status;
+				uint32_t buffer_status;
+			} result;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+	uint8_t *buf;
+	unsigned page = 0;
+	unsigned cwperpage;
+
+	if (mtd->writesize == 2048)
+		page = ofs >> 11;
+
+	if (mtd->writesize == 4096)
+		page = ofs >> 12;
+
+	cwperpage = (mtd->writesize >> 9);
+
+	/* Check for invalid offset */
+	if (ofs > mtd->size)
+		return -EINVAL;
+	if (ofs & (mtd->erasesize - 1)) {
+		pr_err("%s: unsupported block address, 0x%x\n",
+			 __func__, (uint32_t)ofs);
+		return -EINVAL;
+	}
+
+	wait_event(chip->wait_queue,
+		(dma_buffer = msm_nand_get_dma_buffer(chip ,
+					 sizeof(*dma_buffer) + 4)));
+	buf = (uint8_t *)dma_buffer + sizeof(*dma_buffer);
+
+	/* Read 4 bytes starting from the bad block marker location
+	 * in the last code word of the page
+	 */
+
+	cmd = dma_buffer->cmd;
+
+	dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ;
+	dma_buffer->data.cfg0 = chip->CFG0_RAW & ~(7U << 6);
+	dma_buffer->data.cfg1 = chip->CFG1_RAW |
+				(chip->CFG1 & CFG1_WIDE_FLASH);
+	if (enable_bch_ecc)
+		dma_buffer->data.eccbchcfg = chip->ecc_bch_cfg;
+
+	if (chip->CFG1 & CFG1_WIDE_FLASH)
+		dma_buffer->data.addr0 = (page << 16) |
+			((chip->cw_size * (cwperpage-1)) >> 1);
+	else
+		dma_buffer->data.addr0 = (page << 16) |
+			(chip->cw_size * (cwperpage-1));
+
+	dma_buffer->data.addr1 = (page >> 16) & 0xff;
+	dma_buffer->data.chipsel = 0 | 4;
+
+	dma_buffer->data.exec = 1;
+
+	dma_buffer->data.result.flash_status = 0xeeeeeeee;
+	dma_buffer->data.result.buffer_status = 0xeeeeeeee;
+
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = MSM_NAND_FLASH_CMD;
+	cmd->len = 16;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
+	cmd->dst = MSM_NAND_DEV0_CFG0;
+	if (enable_bch_ecc)
+		cmd->len = 12;
+	else
+		cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = MSM_NAND_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_FLASH_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.result);
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = MSM_NAND_FLASH_BUFFER +
+	(mtd->writesize - (chip->cw_size * (cwperpage-1)));
+	cmd->dst = msm_virt_to_dma(chip, buf);
+	cmd->len = 4;
+	cmd++;
+
+	BUILD_BUG_ON(5 != ARRAY_SIZE(dma_buffer->cmd));
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+	dma_buffer->cmd[0].cmd |= CMD_OCB;
+	cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+	dma_buffer->cmdptr = (msm_virt_to_dma(chip,
+				dma_buffer->cmd) >> 3) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST |
+		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
+
+	ret = 0;
+	if (dma_buffer->data.result.flash_status & 0x110)
+		ret = -EIO;
+
+	if (!ret) {
+		/* Check for bad block marker byte */
+		if (chip->CFG1 & CFG1_WIDE_FLASH) {
+			if (buf[0] != 0xFF || buf[1] != 0xFF)
+				ret = 1;
+		} else {
+			if (buf[0] != 0xFF)
+				ret = 1;
+		}
+	}
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer) + 4);
+	return ret;
+}
+
+static int
+msm_nand_block_isbad_dualnandc(struct mtd_info *mtd, loff_t ofs)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+	int ret;
+	struct {
+		dmov_s cmd[18];
+		unsigned cmdptr;
+		struct {
+			uint32_t cmd;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t chipsel_cs0;
+			uint32_t chipsel_cs1;
+			uint32_t cfg0;
+			uint32_t cfg1;
+			uint32_t exec;
+			uint32_t ecccfg;
+			uint32_t ebi2_chip_select_cfg0;
+			uint32_t adm_mux_data_ack_req_nc01;
+			uint32_t adm_mux_cmd_ack_req_nc01;
+			uint32_t adm_mux_data_ack_req_nc10;
+			uint32_t adm_mux_cmd_ack_req_nc10;
+			uint32_t adm_default_mux;
+			uint32_t default_ebi2_chip_select_cfg0;
+			struct {
+				uint32_t flash_status;
+				uint32_t buffer_status;
+			} result[2];
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+	uint8_t *buf01;
+	uint8_t *buf10;
+	unsigned page = 0;
+	unsigned cwperpage;
+
+	if (mtd->writesize == 2048)
+		page = ofs >> 11;
+
+	if (mtd->writesize == 4096)
+		page = ofs >> 12;
+
+	if (mtd->writesize == 8192)
+		page = (ofs >> 1) >> 12;
+
+	cwperpage = ((mtd->writesize >> 1) >> 9);
+
+	/* Check for invalid offset */
+	if (ofs > mtd->size)
+		return -EINVAL;
+	if (ofs & (mtd->erasesize - 1)) {
+		pr_err("%s: unsupported block address, 0x%x\n",
+			 __func__, (uint32_t)ofs);
+		return -EINVAL;
+	}
+
+	wait_event(chip->wait_queue,
+		(dma_buffer = msm_nand_get_dma_buffer(chip ,
+					 sizeof(*dma_buffer) + 8)));
+	buf01 = (uint8_t *)dma_buffer + sizeof(*dma_buffer);
+	buf10 = buf01 + 4;
+
+	/* Read 4 bytes starting from the bad block marker location
+	 * in the last code word of the page
+	 */
+	cmd = dma_buffer->cmd;
+
+	dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ;
+	dma_buffer->data.cfg0 = chip->CFG0_RAW & ~(7U << 6);
+	dma_buffer->data.cfg1 = chip->CFG1_RAW |
+				(chip->CFG1 & CFG1_WIDE_FLASH);
+
+	if (chip->CFG1 & CFG1_WIDE_FLASH)
+		dma_buffer->data.addr0 = (page << 16) |
+			((528*(cwperpage-1)) >> 1);
+	else
+		dma_buffer->data.addr0 = (page << 16) |
+			(528*(cwperpage-1));
+
+	dma_buffer->data.addr1 = (page >> 16) & 0xff;
+	dma_buffer->data.chipsel_cs0 = (1<<4) | 4;
+	dma_buffer->data.chipsel_cs1 = (1<<4) | 5;
+
+	dma_buffer->data.exec = 1;
+
+	dma_buffer->data.result[0].flash_status = 0xeeeeeeee;
+	dma_buffer->data.result[0].buffer_status = 0xeeeeeeee;
+	dma_buffer->data.result[1].flash_status = 0xeeeeeeee;
+	dma_buffer->data.result[1].buffer_status = 0xeeeeeeee;
+
+	dma_buffer->data.ebi2_chip_select_cfg0 = 0x00000805;
+	dma_buffer->data.adm_mux_data_ack_req_nc01 = 0x00000A3C;
+	dma_buffer->data.adm_mux_cmd_ack_req_nc01  = 0x0000053C;
+	dma_buffer->data.adm_mux_data_ack_req_nc10 = 0x00000F28;
+	dma_buffer->data.adm_mux_cmd_ack_req_nc10  = 0x00000F14;
+	dma_buffer->data.adm_default_mux = 0x00000FC0;
+	dma_buffer->data.default_ebi2_chip_select_cfg0 = 0x00000801;
+
+	/* Reading last code word from NC01 */
+	/* enable CS1 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.ebi2_chip_select_cfg0);
+	cmd->dst = EBI2_CHIP_SELECT_CFG0;
+	cmd->len = 4;
+	cmd++;
+
+	/* 0xF14 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_mux_cmd_ack_req_nc10);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = NC01(MSM_NAND_FLASH_CMD);
+	cmd->len = 16;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
+	cmd->dst = NC01(MSM_NAND_DEV0_CFG0);
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = NC01(MSM_NAND_EXEC_CMD);
+	cmd->len = 4;
+	cmd++;
+
+	/* 0xF28 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_mux_data_ack_req_nc10);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = NC01(MSM_NAND_FLASH_STATUS);
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.result[0]);
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = NC01(MSM_NAND_FLASH_BUFFER) + ((mtd->writesize >> 1) -
+							(528*(cwperpage-1)));
+	cmd->dst = msm_virt_to_dma(chip, buf01);
+	cmd->len = 4;
+	cmd++;
+
+	/* Reading last code word from NC10 */
+	/* 0x53C */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+	&dma_buffer->data.adm_mux_cmd_ack_req_nc01);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = NC10(MSM_NAND_FLASH_CMD);
+	cmd->len = 12;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.chipsel_cs1);
+	cmd->dst = NC10(MSM_NAND_FLASH_CHIP_SELECT);
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
+	cmd->dst = NC10(MSM_NAND_DEV1_CFG0);
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = NC10(MSM_NAND_EXEC_CMD);
+	cmd->len = 4;
+	cmd++;
+
+	/* A3C */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_mux_data_ack_req_nc01);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = NC10(MSM_NAND_FLASH_STATUS);
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.result[1]);
+	cmd->len = 8;
+	cmd++;
+
+	cmd->cmd = 0;
+	cmd->src = NC10(MSM_NAND_FLASH_BUFFER) + ((mtd->writesize >> 1) -
+							(528*(cwperpage-1)));
+	cmd->dst = msm_virt_to_dma(chip, buf10);
+	cmd->len = 4;
+	cmd++;
+
+	/* FC0 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.adm_default_mux);
+	cmd->dst = EBI2_NAND_ADM_MUX;
+	cmd->len = 4;
+	cmd++;
+
+	/* disble CS1 */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip,
+			&dma_buffer->data.ebi2_chip_select_cfg0);
+	cmd->dst = EBI2_CHIP_SELECT_CFG0;
+	cmd->len = 4;
+	cmd++;
+
+	BUILD_BUG_ON(18 != ARRAY_SIZE(dma_buffer->cmd));
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+	dma_buffer->cmd[0].cmd |= CMD_OCB;
+	cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+	dma_buffer->cmdptr = (msm_virt_to_dma(chip,
+				dma_buffer->cmd) >> 3) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST |
+		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	mb();
+
+	ret = 0;
+	if ((dma_buffer->data.result[0].flash_status & 0x110) ||
+			(dma_buffer->data.result[1].flash_status & 0x110))
+		ret = -EIO;
+
+	if (!ret) {
+		/* Check for bad block marker byte for NC01 & NC10 */
+		if (chip->CFG1 & CFG1_WIDE_FLASH) {
+			if ((buf01[0] != 0xFF || buf01[1] != 0xFF) ||
+				(buf10[0] != 0xFF || buf10[1] != 0xFF))
+				ret = 1;
+		} else {
+			if (buf01[0] != 0xFF || buf10[0] != 0xFF)
+				ret = 1;
+		}
+	}
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer) + 8);
+	return ret;
+}
+
+static int
+msm_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct mtd_oob_ops ops;
+	int ret;
+	uint8_t *buf;
+
+	/* Check for invalid offset */
+	if (ofs > mtd->size)
+		return -EINVAL;
+	if (ofs & (mtd->erasesize - 1)) {
+		pr_err("%s: unsupported block address, 0x%x\n",
+				 __func__, (uint32_t)ofs);
+		return -EINVAL;
+	}
+
+	/*
+	Write all 0s to the first page
+	This will set the BB marker to 0
+	*/
+	buf = page_address(ZERO_PAGE());
+
+	ops.mode = MTD_OOB_RAW;
+	ops.len = mtd->writesize + mtd->oobsize;
+	ops.retlen = 0;
+	ops.ooblen = 0;
+	ops.datbuf = buf;
+	ops.oobbuf = NULL;
+	if (!interleave_enable)
+		ret =  msm_nand_write_oob(mtd, ofs, &ops);
+	else
+		ret = msm_nand_write_oob_dualnandc(mtd, ofs, &ops);
+
+	return ret;
+}
+
+/**
+ * msm_nand_suspend - [MTD Interface] Suspend the msm_nand flash
+ * @param mtd		MTD device structure
+ */
+static int msm_nand_suspend(struct mtd_info *mtd)
+{
+	return 0;
+}
+
+/**
+ * msm_nand_resume - [MTD Interface] Resume the msm_nand flash
+ * @param mtd		MTD device structure
+ */
+static void msm_nand_resume(struct mtd_info *mtd)
+{
+}
+
+struct onenand_information {
+	uint16_t manufacturer_id;
+	uint16_t device_id;
+	uint16_t version_id;
+	uint16_t data_buf_size;
+	uint16_t boot_buf_size;
+	uint16_t num_of_buffers;
+	uint16_t technology;
+};
+
+static struct onenand_information onenand_info;
+static uint32_t nand_sfcmd_mode;
+
+uint32_t flash_onenand_probe(struct msm_nand_chip *chip)
+{
+	struct {
+		dmov_s cmd[7];
+		unsigned cmdptr;
+		struct {
+			uint32_t bcfg;
+			uint32_t cmd;
+			uint32_t exec;
+			uint32_t status;
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t addr2;
+			uint32_t addr3;
+			uint32_t addr4;
+			uint32_t addr5;
+			uint32_t addr6;
+			uint32_t data0;
+			uint32_t data1;
+			uint32_t data2;
+			uint32_t data3;
+			uint32_t data4;
+			uint32_t data5;
+			uint32_t data6;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+
+	int err = 0;
+	uint32_t initialsflashcmd = 0;
+
+	initialsflashcmd = flash_rd_reg(chip, MSM_NAND_SFLASHC_CMD);
+
+	if ((initialsflashcmd & 0x10) == 0x10)
+		nand_sfcmd_mode = MSM_NAND_SFCMD_ASYNC;
+	else
+		nand_sfcmd_mode = MSM_NAND_SFCMD_BURST;
+
+	printk(KERN_INFO "SFLASHC Async Mode bit: %x \n", nand_sfcmd_mode);
+
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
+
+	cmd = dma_buffer->cmd;
+
+	dma_buffer->data.bcfg = SFLASH_BCFG |
+					(nand_sfcmd_mode ? 0 : (1 << 24));
+	dma_buffer->data.cmd = SFLASH_PREPCMD(7, 0, 0,
+						MSM_NAND_SFCMD_DATXS,
+						nand_sfcmd_mode,
+						MSM_NAND_SFCMD_REGRD);
+	dma_buffer->data.exec = 1;
+	dma_buffer->data.status = CLEAN_DATA_32;
+	dma_buffer->data.addr0 = (ONENAND_DEVICE_ID << 16) |
+						(ONENAND_MANUFACTURER_ID);
+	dma_buffer->data.addr1 = (ONENAND_DATA_BUFFER_SIZE << 16) |
+						(ONENAND_VERSION_ID);
+	dma_buffer->data.addr2 = (ONENAND_AMOUNT_OF_BUFFERS << 16) |
+						(ONENAND_BOOT_BUFFER_SIZE);
+	dma_buffer->data.addr3 = (CLEAN_DATA_16 << 16) |
+						(ONENAND_TECHNOLOGY << 0);
+	dma_buffer->data.data0 = CLEAN_DATA_32;
+	dma_buffer->data.data1 = CLEAN_DATA_32;
+	dma_buffer->data.data2 = CLEAN_DATA_32;
+	dma_buffer->data.data3 = CLEAN_DATA_32;
+
+	/* Enable and configure the SFlash controller */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.bcfg);
+	cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+	cmd->len = 4;
+	cmd++;
+
+	/* Block on cmd ready and write CMD register */
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
+	cmd->dst = MSM_NAND_SFLASHC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Configure the ADDR0 and ADDR1 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr0);
+	cmd->dst = MSM_NAND_ADDR0;
+	cmd->len = 8;
+	cmd++;
+
+	/* Configure the ADDR2 and ADDR3 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr2);
+	cmd->dst = MSM_NAND_ADDR2;
+	cmd->len = 8;
+	cmd++;
+
+	/* Kick the execute command */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
+	cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Block on data ready, and read the two status registers */
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_SFLASHC_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.status);
+	cmd->len = 4;
+	cmd++;
+
+	/* Read data registers - valid only if status says success */
+	cmd->cmd = 0;
+	cmd->src = MSM_NAND_GENP_REG0;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data0);
+	cmd->len = 16;
+	cmd++;
+
+	BUILD_BUG_ON(7 != ARRAY_SIZE(dma_buffer->cmd));
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+	dma_buffer->cmd[0].cmd |= CMD_OCB;
+	cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+	dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+			>> 3) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST
+			| DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+			&dma_buffer->cmdptr)));
+	mb();
+
+	/* Check for errors, protection violations etc */
+	if (dma_buffer->data.status & 0x110) {
+		pr_info("%s: MPU/OP error"
+				"(0x%x) during Onenand probe\n",
+				__func__, dma_buffer->data.status);
+		err = -EIO;
+	} else {
+
+		onenand_info.manufacturer_id =
+			(dma_buffer->data.data0 >> 0) & 0x0000FFFF;
+		onenand_info.device_id =
+			(dma_buffer->data.data0 >> 16) & 0x0000FFFF;
+		onenand_info.version_id =
+			(dma_buffer->data.data1 >> 0) & 0x0000FFFF;
+		onenand_info.data_buf_size =
+			(dma_buffer->data.data1 >> 16) & 0x0000FFFF;
+		onenand_info.boot_buf_size =
+			(dma_buffer->data.data2 >> 0) & 0x0000FFFF;
+		onenand_info.num_of_buffers =
+			(dma_buffer->data.data2 >> 16) & 0x0000FFFF;
+		onenand_info.technology =
+			(dma_buffer->data.data3 >> 0) & 0x0000FFFF;
+
+
+		pr_info("======================================="
+				"==========================\n");
+
+		pr_info("%s: manufacturer_id = 0x%x\n"
+				, __func__, onenand_info.manufacturer_id);
+		pr_info("%s: device_id = 0x%x\n"
+				, __func__, onenand_info.device_id);
+		pr_info("%s: version_id = 0x%x\n"
+				, __func__, onenand_info.version_id);
+		pr_info("%s: data_buf_size = 0x%x\n"
+				, __func__, onenand_info.data_buf_size);
+		pr_info("%s: boot_buf_size = 0x%x\n"
+				, __func__, onenand_info.boot_buf_size);
+		pr_info("%s: num_of_buffers = 0x%x\n"
+				, __func__, onenand_info.num_of_buffers);
+		pr_info("%s: technology = 0x%x\n"
+				, __func__, onenand_info.technology);
+
+		pr_info("======================================="
+				"==========================\n");
+
+		if ((onenand_info.manufacturer_id != 0x00EC)
+			|| ((onenand_info.device_id & 0x0040) != 0x0040)
+			|| (onenand_info.data_buf_size != 0x0800)
+			|| (onenand_info.boot_buf_size != 0x0200)
+			|| (onenand_info.num_of_buffers != 0x0201)
+			|| (onenand_info.technology != 0)) {
+
+			pr_info("%s: Detected an unsupported device\n"
+				, __func__);
+			err = -EIO;
+		}
+	}
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+	return err;
+}
+
+int msm_onenand_read_oob(struct mtd_info *mtd,
+		loff_t from, struct mtd_oob_ops *ops)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+
+	struct {
+		dmov_s cmd[53];
+		unsigned cmdptr;
+		struct {
+			uint32_t sfbcfg;
+			uint32_t sfcmd[9];
+			uint32_t sfexec;
+			uint32_t sfstat[9];
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t addr2;
+			uint32_t addr3;
+			uint32_t addr4;
+			uint32_t addr5;
+			uint32_t addr6;
+			uint32_t data0;
+			uint32_t data1;
+			uint32_t data2;
+			uint32_t data3;
+			uint32_t data4;
+			uint32_t data5;
+			uint32_t data6;
+			uint32_t macro[5];
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+
+	int err = 0;
+	int i;
+	dma_addr_t data_dma_addr = 0;
+	dma_addr_t oob_dma_addr = 0;
+	dma_addr_t data_dma_addr_curr = 0;
+	dma_addr_t oob_dma_addr_curr = 0;
+
+	loff_t from_curr = 0;
+	unsigned page_count;
+	unsigned pages_read = 0;
+
+	uint16_t onenand_startaddr1;
+	uint16_t onenand_startaddr8;
+	uint16_t onenand_startaddr2;
+	uint16_t onenand_startbuffer;
+	uint16_t onenand_sysconfig1;
+	uint16_t controller_status;
+	uint16_t interrupt_status;
+	uint16_t ecc_status;
+#if VERBOSE
+	pr_info("================================================="
+			"================\n");
+	pr_info("%s: from 0x%llx mode %d \ndatbuf 0x%p datlen 0x%x"
+			"\noobbuf 0x%p ooblen 0x%x\n",
+			__func__, from, ops->mode, ops->datbuf, ops->len,
+			ops->oobbuf, ops->ooblen);
+#endif
+	if (!mtd) {
+		pr_err("%s: invalid mtd pointer, 0x%x\n", __func__,
+				(uint32_t)mtd);
+		return -EINVAL;
+	}
+	if (from & (mtd->writesize - 1)) {
+		pr_err("%s: unsupported from, 0x%llx\n", __func__,
+				from);
+		return -EINVAL;
+	}
+
+	if ((ops->mode != MTD_OOB_PLACE) && (ops->mode != MTD_OOB_AUTO) &&
+			(ops->mode != MTD_OOB_RAW)) {
+		pr_err("%s: unsupported ops->mode, %d\n", __func__,
+				ops->mode);
+		return -EINVAL;
+	}
+
+	if (((ops->datbuf == NULL) || (ops->len == 0)) &&
+			((ops->oobbuf == NULL) || (ops->ooblen == 0))) {
+		pr_err("%s: incorrect ops fields - nothing to do\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if ((ops->datbuf != NULL) && (ops->len == 0)) {
+		pr_err("%s: data buffer passed but length 0\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if ((ops->oobbuf != NULL) && (ops->ooblen == 0)) {
+		pr_err("%s: oob buffer passed but length 0\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (ops->mode != MTD_OOB_RAW) {
+		if (ops->datbuf != NULL && (ops->len % mtd->writesize) != 0) {
+			/* when ops->datbuf is NULL, ops->len can be ooblen */
+			pr_err("%s: unsupported ops->len, %d\n", __func__,
+					ops->len);
+			return -EINVAL;
+		}
+	} else {
+		if (ops->datbuf != NULL &&
+			(ops->len % (mtd->writesize + mtd->oobsize)) != 0) {
+			pr_err("%s: unsupported ops->len,"
+				" %d for MTD_OOB_RAW\n", __func__, ops->len);
+			return -EINVAL;
+		}
+	}
+
+	if ((ops->mode == MTD_OOB_RAW) && (ops->oobbuf)) {
+		pr_err("%s: unsupported operation, oobbuf pointer "
+				"passed in for RAW mode, %x\n", __func__,
+				(uint32_t)ops->oobbuf);
+		return -EINVAL;
+	}
+
+	if (ops->oobbuf && !ops->datbuf) {
+		page_count = ops->ooblen / ((ops->mode == MTD_OOB_AUTO) ?
+			mtd->oobavail : mtd->oobsize);
+		if ((page_count == 0) && (ops->ooblen))
+			page_count = 1;
+	} else if (ops->mode != MTD_OOB_RAW)
+			page_count = ops->len / mtd->writesize;
+		else
+			page_count = ops->len / (mtd->writesize + mtd->oobsize);
+
+	if ((ops->mode == MTD_OOB_PLACE) && (ops->oobbuf != NULL)) {
+		if (page_count * mtd->oobsize > ops->ooblen) {
+			pr_err("%s: unsupported ops->ooblen for "
+				"PLACE, %d\n", __func__, ops->ooblen);
+			return -EINVAL;
+		}
+	}
+
+	if ((ops->mode == MTD_OOB_PLACE) && (ops->ooblen != 0) &&
+							(ops->ooboffs != 0)) {
+		pr_err("%s: unsupported ops->ooboffs, %d\n", __func__,
+				ops->ooboffs);
+		return -EINVAL;
+	}
+
+	if (ops->datbuf) {
+		memset(ops->datbuf, 0x55, ops->len);
+		data_dma_addr_curr = data_dma_addr = msm_nand_dma_map(chip->dev,
+				ops->datbuf, ops->len, DMA_FROM_DEVICE);
+		if (dma_mapping_error(chip->dev, data_dma_addr)) {
+			pr_err("%s: failed to get dma addr for %p\n",
+					__func__, ops->datbuf);
+			return -EIO;
+		}
+	}
+	if (ops->oobbuf) {
+		memset(ops->oobbuf, 0x55, ops->ooblen);
+		oob_dma_addr_curr = oob_dma_addr = msm_nand_dma_map(chip->dev,
+				ops->oobbuf, ops->ooblen, DMA_FROM_DEVICE);
+		if (dma_mapping_error(chip->dev, oob_dma_addr)) {
+			pr_err("%s: failed to get dma addr for %p\n",
+					__func__, ops->oobbuf);
+			err = -EIO;
+			goto err_dma_map_oobbuf_failed;
+		}
+	}
+
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
+
+	from_curr = from;
+
+	while (page_count-- > 0) {
+
+		cmd = dma_buffer->cmd;
+
+		if ((onenand_info.device_id & ONENAND_DEVICE_IS_DDP)
+			&& (from_curr >= (mtd->size>>1))) { /* DDP Device */
+				onenand_startaddr1 = DEVICE_FLASHCORE_1 |
+					(((uint32_t)(from_curr-(mtd->size>>1))
+					/ mtd->erasesize));
+				onenand_startaddr2 = DEVICE_BUFFERRAM_1;
+		} else {
+				onenand_startaddr1 = DEVICE_FLASHCORE_0 |
+				((uint32_t)from_curr / mtd->erasesize) ;
+				onenand_startaddr2 = DEVICE_BUFFERRAM_0;
+		}
+
+		onenand_startaddr8 = (((uint32_t)from_curr &
+				(mtd->erasesize - 1)) / mtd->writesize) << 2;
+		onenand_startbuffer = DATARAM0_0 << 8;
+		onenand_sysconfig1 = (ops->mode == MTD_OOB_RAW) ?
+			ONENAND_SYSCFG1_ECCDIS(nand_sfcmd_mode) :
+			ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode);
+
+		dma_buffer->data.sfbcfg = SFLASH_BCFG |
+					(nand_sfcmd_mode ? 0 : (1 << 24));
+		dma_buffer->data.sfcmd[0] =  SFLASH_PREPCMD(7, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfcmd[1] =  SFLASH_PREPCMD(0, 0, 32,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_INTHI);
+		dma_buffer->data.sfcmd[2] =  SFLASH_PREPCMD(3, 7, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGRD);
+		dma_buffer->data.sfcmd[3] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATRD);
+		dma_buffer->data.sfcmd[4] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATRD);
+		dma_buffer->data.sfcmd[5] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATRD);
+		dma_buffer->data.sfcmd[6] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATRD);
+		dma_buffer->data.sfcmd[7] =  SFLASH_PREPCMD(32, 0, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATRD);
+		dma_buffer->data.sfcmd[8] =  SFLASH_PREPCMD(4, 10, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfexec = 1;
+		dma_buffer->data.sfstat[0] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[1] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[2] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[3] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[4] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[5] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[6] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[7] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[8] = CLEAN_DATA_32;
+		dma_buffer->data.addr0 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr1 = (ONENAND_START_ADDRESS_8 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.addr2 = (ONENAND_START_BUFFER << 16) |
+						(ONENAND_START_ADDRESS_2);
+		dma_buffer->data.addr3 = (ONENAND_ECC_STATUS << 16) |
+						(ONENAND_COMMAND);
+		dma_buffer->data.addr4 = (ONENAND_CONTROLLER_STATUS << 16) |
+						(ONENAND_INTERRUPT_STATUS);
+		dma_buffer->data.addr5 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr6 = (ONENAND_START_ADDRESS_3 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.data0 = (ONENAND_CLRINTR << 16) |
+						(onenand_sysconfig1);
+		dma_buffer->data.data1 = (onenand_startaddr8 << 16) |
+						(onenand_startaddr1);
+		dma_buffer->data.data2 = (onenand_startbuffer << 16) |
+						(onenand_startaddr2);
+		dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+						(ONENAND_CMDLOADSPARE);
+		dma_buffer->data.data4 = (CLEAN_DATA_16 << 16) |
+						(CLEAN_DATA_16);
+		dma_buffer->data.data5 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+		dma_buffer->data.data6 = (ONENAND_STARTADDR3_RES << 16) |
+						(ONENAND_STARTADDR1_RES);
+		dma_buffer->data.macro[0] = 0x0200;
+		dma_buffer->data.macro[1] = 0x0300;
+		dma_buffer->data.macro[2] = 0x0400;
+		dma_buffer->data.macro[3] = 0x0500;
+		dma_buffer->data.macro[4] = 0x8010;
+
+		/*************************************************************/
+		/* Write necessary address registers in the onenand device   */
+		/*************************************************************/
+
+		/* Enable and configure the SFlash controller */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfbcfg);
+		cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[0]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the ADDR0 and ADDR1 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr0);
+		cmd->dst = MSM_NAND_ADDR0;
+		cmd->len = 8;
+		cmd++;
+
+		/* Write the ADDR2 ADDR3 ADDR4 ADDR5 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr2);
+		cmd->dst = MSM_NAND_ADDR2;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the ADDR6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr6);
+		cmd->dst = MSM_NAND_ADDR6;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the GENP0, GENP1, GENP2, GENP3 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data0);
+		cmd->dst = MSM_NAND_GENP_REG0;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the FLASH_DEV_CMD4,5,6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->dst = MSM_NAND_DEV_CMD4;
+		cmd->len = 12;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[0]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Wait for the interrupt from the Onenand device controller */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[1]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[1]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Read necessary status registers from the onenand device   */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[2]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[2]);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the GENP3 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_GENP_REG3;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data3);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the DEVCMD4 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_DEV_CMD4;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Read the data ram area from the onenand buffer ram        */
+		/*************************************************************/
+
+		if (ops->datbuf) {
+
+			dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+							(ONENAND_CMDLOAD);
+
+			for (i = 0; i < 4; i++) {
+
+				/* Block on cmd ready and write CMD register */
+				cmd->cmd = DST_CRCI_NAND_CMD;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.sfcmd[3+i]);
+				cmd->dst = MSM_NAND_SFLASHC_CMD;
+				cmd->len = 4;
+				cmd++;
+
+				/* Write the MACRO1 register */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.macro[i]);
+				cmd->dst = MSM_NAND_MACRO1_REG;
+				cmd->len = 4;
+				cmd++;
+
+				/* Kick the execute command */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.sfexec);
+				cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+				cmd->len = 4;
+				cmd++;
+
+				/* Block on data rdy, & read status register */
+				cmd->cmd = SRC_CRCI_NAND_DATA;
+				cmd->src = MSM_NAND_SFLASHC_STATUS;
+				cmd->dst = msm_virt_to_dma(chip,
+						&dma_buffer->data.sfstat[3+i]);
+				cmd->len = 4;
+				cmd++;
+
+				/* Transfer nand ctlr buf contents to usr buf */
+				cmd->cmd = 0;
+				cmd->src = MSM_NAND_FLASH_BUFFER;
+				cmd->dst = data_dma_addr_curr;
+				cmd->len = 512;
+				data_dma_addr_curr += 512;
+				cmd++;
+			}
+		}
+
+		if ((ops->oobbuf) || (ops->mode == MTD_OOB_RAW)) {
+
+			/* Block on cmd ready and write CMD register */
+			cmd->cmd = DST_CRCI_NAND_CMD;
+			cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.sfcmd[7]);
+			cmd->dst = MSM_NAND_SFLASHC_CMD;
+			cmd->len = 4;
+			cmd++;
+
+			/* Write the MACRO1 register */
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.macro[4]);
+			cmd->dst = MSM_NAND_MACRO1_REG;
+			cmd->len = 4;
+			cmd++;
+
+			/* Kick the execute command */
+			cmd->cmd = 0;
+			cmd->src = msm_virt_to_dma(chip,
+					&dma_buffer->data.sfexec);
+			cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+			cmd->len = 4;
+			cmd++;
+
+			/* Block on data ready, and read status register */
+			cmd->cmd = SRC_CRCI_NAND_DATA;
+			cmd->src = MSM_NAND_SFLASHC_STATUS;
+			cmd->dst = msm_virt_to_dma(chip,
+					&dma_buffer->data.sfstat[7]);
+			cmd->len = 4;
+			cmd++;
+
+			/* Transfer nand ctlr buffer contents into usr buf */
+			if (ops->mode == MTD_OOB_AUTO) {
+				for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES; i++) {
+					cmd->cmd = 0;
+					cmd->src = MSM_NAND_FLASH_BUFFER +
+					mtd->ecclayout->oobfree[i].offset;
+					cmd->dst = oob_dma_addr_curr;
+					cmd->len =
+					mtd->ecclayout->oobfree[i].length;
+					oob_dma_addr_curr +=
+					mtd->ecclayout->oobfree[i].length;
+					cmd++;
+				}
+			}
+			if (ops->mode == MTD_OOB_PLACE) {
+					cmd->cmd = 0;
+					cmd->src = MSM_NAND_FLASH_BUFFER;
+					cmd->dst = oob_dma_addr_curr;
+					cmd->len = mtd->oobsize;
+					oob_dma_addr_curr += mtd->oobsize;
+					cmd++;
+			}
+			if (ops->mode == MTD_OOB_RAW) {
+					cmd->cmd = 0;
+					cmd->src = MSM_NAND_FLASH_BUFFER;
+					cmd->dst = data_dma_addr_curr;
+					cmd->len = mtd->oobsize;
+					data_dma_addr_curr += mtd->oobsize;
+					cmd++;
+			}
+		}
+
+		/*************************************************************/
+		/* Restore the necessary registers to proper values          */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[8]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[8]);
+		cmd->len = 4;
+		cmd++;
+
+
+		BUILD_BUG_ON(53 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+		dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+				>> 3) | CMD_PTR_LP;
+
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+				&dma_buffer->cmdptr)));
+		mb();
+
+		ecc_status = (dma_buffer->data.data3 >> 16) &
+							0x0000FFFF;
+		interrupt_status = (dma_buffer->data.data4 >> 0) &
+							0x0000FFFF;
+		controller_status = (dma_buffer->data.data4 >> 16) &
+							0x0000FFFF;
+
+#if VERBOSE
+		pr_info("\n%s: sflash status %x %x %x %x %x %x %x"
+				"%x %x\n", __func__,
+					dma_buffer->data.sfstat[0],
+					dma_buffer->data.sfstat[1],
+					dma_buffer->data.sfstat[2],
+					dma_buffer->data.sfstat[3],
+					dma_buffer->data.sfstat[4],
+					dma_buffer->data.sfstat[5],
+					dma_buffer->data.sfstat[6],
+					dma_buffer->data.sfstat[7],
+					dma_buffer->data.sfstat[8]);
+
+		pr_info("%s: controller_status = %x\n", __func__,
+					controller_status);
+		pr_info("%s: interrupt_status = %x\n", __func__,
+					interrupt_status);
+		pr_info("%s: ecc_status = %x\n", __func__,
+					ecc_status);
+#endif
+		/* Check for errors, protection violations etc */
+		if ((controller_status != 0)
+				|| (dma_buffer->data.sfstat[0] & 0x110)
+				|| (dma_buffer->data.sfstat[1] & 0x110)
+				|| (dma_buffer->data.sfstat[2] & 0x110)
+				|| (dma_buffer->data.sfstat[8] & 0x110)
+				|| ((dma_buffer->data.sfstat[3] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[4] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[5] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[6] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[7] & 0x110) &&
+								((ops->oobbuf)
+					|| (ops->mode == MTD_OOB_RAW)))) {
+			pr_info("%s: ECC/MPU/OP error\n", __func__);
+			err = -EIO;
+		}
+
+		if (err)
+			break;
+		pages_read++;
+		from_curr += mtd->writesize;
+	}
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+	if (ops->oobbuf) {
+		dma_unmap_page(chip->dev, oob_dma_addr, ops->ooblen,
+				DMA_FROM_DEVICE);
+	}
+err_dma_map_oobbuf_failed:
+	if (ops->datbuf) {
+		dma_unmap_page(chip->dev, data_dma_addr, ops->len,
+				DMA_FROM_DEVICE);
+	}
+
+	if (err) {
+		pr_err("%s: %llx %x %x failed\n", __func__, from_curr,
+				ops->datbuf ? ops->len : 0, ops->ooblen);
+	} else {
+		ops->retlen = ops->oobretlen = 0;
+		if (ops->datbuf != NULL) {
+			if (ops->mode != MTD_OOB_RAW)
+				ops->retlen = mtd->writesize * pages_read;
+			else
+				ops->retlen = (mtd->writesize +  mtd->oobsize)
+							* pages_read;
+		}
+		if (ops->oobbuf != NULL) {
+			if (ops->mode == MTD_OOB_AUTO)
+				ops->oobretlen = mtd->oobavail * pages_read;
+			else
+				ops->oobretlen = mtd->oobsize * pages_read;
+		}
+	}
+
+#if VERBOSE
+	pr_info("\n%s: ret %d, retlen %d oobretlen %d\n",
+			__func__, err, ops->retlen, ops->oobretlen);
+
+	pr_info("==================================================="
+			"==============\n");
+#endif
+	return err;
+}
+
+int msm_onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int ret;
+	struct mtd_oob_ops ops;
+
+	ops.mode = MTD_OOB_PLACE;
+	ops.datbuf = buf;
+	ops.len = len;
+	ops.retlen = 0;
+	ops.oobbuf = NULL;
+	ops.ooblen = 0;
+	ops.oobretlen = 0;
+	ret =  msm_onenand_read_oob(mtd, from, &ops);
+	*retlen = ops.retlen;
+
+	return ret;
+}
+
+static int msm_onenand_write_oob(struct mtd_info *mtd, loff_t to,
+		struct mtd_oob_ops *ops)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+
+	struct {
+		dmov_s cmd[53];
+		unsigned cmdptr;
+		struct {
+			uint32_t sfbcfg;
+			uint32_t sfcmd[10];
+			uint32_t sfexec;
+			uint32_t sfstat[10];
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t addr2;
+			uint32_t addr3;
+			uint32_t addr4;
+			uint32_t addr5;
+			uint32_t addr6;
+			uint32_t data0;
+			uint32_t data1;
+			uint32_t data2;
+			uint32_t data3;
+			uint32_t data4;
+			uint32_t data5;
+			uint32_t data6;
+			uint32_t macro[5];
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
+
+	int err = 0;
+	int i, j, k;
+	dma_addr_t data_dma_addr = 0;
+	dma_addr_t oob_dma_addr = 0;
+	dma_addr_t init_dma_addr = 0;
+	dma_addr_t data_dma_addr_curr = 0;
+	dma_addr_t oob_dma_addr_curr = 0;
+	uint8_t *init_spare_bytes;
+
+	loff_t to_curr = 0;
+	unsigned page_count;
+	unsigned pages_written = 0;
+
+	uint16_t onenand_startaddr1;
+	uint16_t onenand_startaddr8;
+	uint16_t onenand_startaddr2;
+	uint16_t onenand_startbuffer;
+	uint16_t onenand_sysconfig1;
+
+	uint16_t controller_status;
+	uint16_t interrupt_status;
+	uint16_t ecc_status;
+
+#if VERBOSE
+	pr_info("================================================="
+			"================\n");
+	pr_info("%s: to 0x%llx mode %d \ndatbuf 0x%p datlen 0x%x"
+			"\noobbuf 0x%p ooblen 0x%x\n",
+			__func__, to, ops->mode, ops->datbuf, ops->len,
+			ops->oobbuf, ops->ooblen);
+#endif
+	if (!mtd) {
+		pr_err("%s: invalid mtd pointer, 0x%x\n", __func__,
+				(uint32_t)mtd);
+		return -EINVAL;
+	}
+	if (to & (mtd->writesize - 1)) {
+		pr_err("%s: unsupported to, 0x%llx\n", __func__, to);
+		return -EINVAL;
+	}
+
+	if ((ops->mode != MTD_OOB_PLACE) && (ops->mode != MTD_OOB_AUTO) &&
+			(ops->mode != MTD_OOB_RAW)) {
+		pr_err("%s: unsupported ops->mode, %d\n", __func__,
+				ops->mode);
+		return -EINVAL;
+	}
+
+	if (((ops->datbuf == NULL) || (ops->len == 0)) &&
+			((ops->oobbuf == NULL) || (ops->ooblen == 0))) {
+		pr_err("%s: incorrect ops fields - nothing to do\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if ((ops->datbuf != NULL) && (ops->len == 0)) {
+		pr_err("%s: data buffer passed but length 0\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if ((ops->oobbuf != NULL) && (ops->ooblen == 0)) {
+		pr_err("%s: oob buffer passed but length 0\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (ops->mode != MTD_OOB_RAW) {
+		if (ops->datbuf != NULL && (ops->len % mtd->writesize) != 0) {
+			/* when ops->datbuf is NULL, ops->len can be ooblen */
+			pr_err("%s: unsupported ops->len, %d\n", __func__,
+					ops->len);
+			return -EINVAL;
+		}
+	} else {
+		if (ops->datbuf != NULL &&
+			(ops->len % (mtd->writesize + mtd->oobsize)) != 0) {
+			pr_err("%s: unsupported ops->len,"
+				" %d for MTD_OOB_RAW\n", __func__, ops->len);
+			return -EINVAL;
+		}
+	}
+
+	if ((ops->mode == MTD_OOB_RAW) && (ops->oobbuf)) {
+		pr_err("%s: unsupported operation, oobbuf pointer "
+				"passed in for RAW mode, %x\n", __func__,
+				(uint32_t)ops->oobbuf);
+		return -EINVAL;
+	}
+
+	if (ops->oobbuf && !ops->datbuf) {
+		page_count = ops->ooblen / ((ops->mode == MTD_OOB_AUTO) ?
+			mtd->oobavail : mtd->oobsize);
+		if ((page_count == 0) && (ops->ooblen))
+			page_count = 1;
+	} else if (ops->mode != MTD_OOB_RAW)
+			page_count = ops->len / mtd->writesize;
+		else
+			page_count = ops->len / (mtd->writesize + mtd->oobsize);
+
+	if ((ops->mode == MTD_OOB_AUTO) && (ops->oobbuf != NULL)) {
+		if (page_count > 1) {
+			pr_err("%s: unsupported ops->ooblen for"
+				"AUTO, %d\n", __func__, ops->ooblen);
+			return -EINVAL;
+		}
+	}
+
+	if ((ops->mode == MTD_OOB_PLACE) && (ops->oobbuf != NULL)) {
+		if (page_count * mtd->oobsize > ops->ooblen) {
+			pr_err("%s: unsupported ops->ooblen for"
+				"PLACE,	%d\n", __func__, ops->ooblen);
+			return -EINVAL;
+		}
+	}
+
+	if ((ops->mode == MTD_OOB_PLACE) && (ops->ooblen != 0) &&
+						(ops->ooboffs != 0)) {
+		pr_err("%s: unsupported ops->ooboffs, %d\n",
+				__func__, ops->ooboffs);
+		return -EINVAL;
+	}
+
+	init_spare_bytes = kmalloc(64, GFP_KERNEL);
+	if (!init_spare_bytes) {
+		pr_err("%s: failed to alloc init_spare_bytes buffer\n",
+				__func__);
+		return -ENOMEM;
+	}
+	for (i = 0; i < 64; i++)
+		init_spare_bytes[i] = 0xFF;
+
+	if ((ops->oobbuf) && (ops->mode == MTD_OOB_AUTO)) {
+		for (i = 0, k = 0; i < MTD_MAX_OOBFREE_ENTRIES; i++)
+			for (j = 0; j < mtd->ecclayout->oobfree[i].length;
+					j++) {
+				init_spare_bytes[j +
+					mtd->ecclayout->oobfree[i].offset]
+						= (ops->oobbuf)[k];
+				k++;
+			}
+	}
+
+	if (ops->datbuf) {
+		data_dma_addr_curr = data_dma_addr = msm_nand_dma_map(chip->dev,
+				ops->datbuf, ops->len, DMA_TO_DEVICE);
+		if (dma_mapping_error(chip->dev, data_dma_addr)) {
+			pr_err("%s: failed to get dma addr for %p\n",
+					__func__, ops->datbuf);
+			return -EIO;
+		}
+	}
+	if (ops->oobbuf) {
+		oob_dma_addr_curr = oob_dma_addr = msm_nand_dma_map(chip->dev,
+				ops->oobbuf, ops->ooblen, DMA_TO_DEVICE);
+		if (dma_mapping_error(chip->dev, oob_dma_addr)) {
+			pr_err("%s: failed to get dma addr for %p\n",
+					__func__, ops->oobbuf);
+			err = -EIO;
+			goto err_dma_map_oobbuf_failed;
+		}
+	}
+
+	init_dma_addr = msm_nand_dma_map(chip->dev, init_spare_bytes, 64,
+			DMA_TO_DEVICE);
+	if (dma_mapping_error(chip->dev, init_dma_addr)) {
+		pr_err("%s: failed to get dma addr for %p\n",
+				__func__, init_spare_bytes);
+		err = -EIO;
+		goto err_dma_map_initbuf_failed;
+	}
+
+
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
+
+	to_curr = to;
+
+	while (page_count-- > 0) {
+		cmd = dma_buffer->cmd;
+
+		if ((onenand_info.device_id & ONENAND_DEVICE_IS_DDP)
+			&& (to_curr >= (mtd->size>>1))) { /* DDP Device */
+				onenand_startaddr1 = DEVICE_FLASHCORE_1 |
+					(((uint32_t)(to_curr-(mtd->size>>1))
+					/ mtd->erasesize));
+				onenand_startaddr2 = DEVICE_BUFFERRAM_1;
+		} else {
+				onenand_startaddr1 = DEVICE_FLASHCORE_0 |
+					((uint32_t)to_curr / mtd->erasesize) ;
+				onenand_startaddr2 = DEVICE_BUFFERRAM_0;
+		}
+
+		onenand_startaddr8 = (((uint32_t)to_curr &
+				(mtd->erasesize - 1)) / mtd->writesize) << 2;
+		onenand_startbuffer = DATARAM0_0 << 8;
+		onenand_sysconfig1 = (ops->mode == MTD_OOB_RAW) ?
+			ONENAND_SYSCFG1_ECCDIS(nand_sfcmd_mode) :
+			ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode);
+
+		dma_buffer->data.sfbcfg = SFLASH_BCFG |
+					(nand_sfcmd_mode ? 0 : (1 << 24));
+		dma_buffer->data.sfcmd[0] =  SFLASH_PREPCMD(6, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfcmd[1] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATWR);
+		dma_buffer->data.sfcmd[2] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATWR);
+		dma_buffer->data.sfcmd[3] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATWR);
+		dma_buffer->data.sfcmd[4] =  SFLASH_PREPCMD(256, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATWR);
+		dma_buffer->data.sfcmd[5] =  SFLASH_PREPCMD(32, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_DATWR);
+		dma_buffer->data.sfcmd[6] =  SFLASH_PREPCMD(1, 6, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfcmd[7] =  SFLASH_PREPCMD(0, 0, 32,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_INTHI);
+		dma_buffer->data.sfcmd[8] =  SFLASH_PREPCMD(3, 7, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGRD);
+		dma_buffer->data.sfcmd[9] =  SFLASH_PREPCMD(4, 10, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfexec = 1;
+		dma_buffer->data.sfstat[0] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[1] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[2] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[3] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[4] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[5] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[6] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[7] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[8] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[9] = CLEAN_DATA_32;
+		dma_buffer->data.addr0 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr1 = (ONENAND_START_ADDRESS_8 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.addr2 = (ONENAND_START_BUFFER << 16) |
+						(ONENAND_START_ADDRESS_2);
+		dma_buffer->data.addr3 = (ONENAND_ECC_STATUS << 16) |
+						(ONENAND_COMMAND);
+		dma_buffer->data.addr4 = (ONENAND_CONTROLLER_STATUS << 16) |
+						(ONENAND_INTERRUPT_STATUS);
+		dma_buffer->data.addr5 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr6 = (ONENAND_START_ADDRESS_3 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.data0 = (ONENAND_CLRINTR << 16) |
+						(onenand_sysconfig1);
+		dma_buffer->data.data1 = (onenand_startaddr8 << 16) |
+						(onenand_startaddr1);
+		dma_buffer->data.data2 = (onenand_startbuffer << 16) |
+						(onenand_startaddr2);
+		dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+						(ONENAND_CMDPROGSPARE);
+		dma_buffer->data.data4 = (CLEAN_DATA_16 << 16) |
+						(CLEAN_DATA_16);
+		dma_buffer->data.data5 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+		dma_buffer->data.data6 = (ONENAND_STARTADDR3_RES << 16) |
+						(ONENAND_STARTADDR1_RES);
+		dma_buffer->data.macro[0] = 0x0200;
+		dma_buffer->data.macro[1] = 0x0300;
+		dma_buffer->data.macro[2] = 0x0400;
+		dma_buffer->data.macro[3] = 0x0500;
+		dma_buffer->data.macro[4] = 0x8010;
+
+
+		/*************************************************************/
+		/* Write necessary address registers in the onenand device   */
+		/*************************************************************/
+
+		/* Enable and configure the SFlash controller */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfbcfg);
+		cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[0]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the ADDR0 and ADDR1 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr0);
+		cmd->dst = MSM_NAND_ADDR0;
+		cmd->len = 8;
+		cmd++;
+
+		/* Write the ADDR2 ADDR3 ADDR4 ADDR5 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr2);
+		cmd->dst = MSM_NAND_ADDR2;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the ADDR6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr6);
+		cmd->dst = MSM_NAND_ADDR6;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the GENP0, GENP1, GENP2, GENP3 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data0);
+		cmd->dst = MSM_NAND_GENP_REG0;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the FLASH_DEV_CMD4,5,6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->dst = MSM_NAND_DEV_CMD4;
+		cmd->len = 12;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[0]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Write the data ram area in the onenand buffer ram         */
+		/*************************************************************/
+
+		if (ops->datbuf) {
+			dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+							(ONENAND_CMDPROG);
+
+			for (i = 0; i < 4; i++) {
+
+				/* Block on cmd ready and write CMD register */
+				cmd->cmd = DST_CRCI_NAND_CMD;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.sfcmd[1+i]);
+				cmd->dst = MSM_NAND_SFLASHC_CMD;
+				cmd->len = 4;
+				cmd++;
+
+				/* Trnsfr usr buf contents to nand ctlr buf */
+				cmd->cmd = 0;
+				cmd->src = data_dma_addr_curr;
+				cmd->dst = MSM_NAND_FLASH_BUFFER;
+				cmd->len = 512;
+				data_dma_addr_curr += 512;
+				cmd++;
+
+				/* Write the MACRO1 register */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.macro[i]);
+				cmd->dst = MSM_NAND_MACRO1_REG;
+				cmd->len = 4;
+				cmd++;
+
+				/* Kick the execute command */
+				cmd->cmd = 0;
+				cmd->src = msm_virt_to_dma(chip,
+						&dma_buffer->data.sfexec);
+				cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+				cmd->len = 4;
+				cmd++;
+
+				/* Block on data rdy, & read status register */
+				cmd->cmd = SRC_CRCI_NAND_DATA;
+				cmd->src = MSM_NAND_SFLASHC_STATUS;
+				cmd->dst = msm_virt_to_dma(chip,
+						&dma_buffer->data.sfstat[1+i]);
+				cmd->len = 4;
+				cmd++;
+
+			}
+		}
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[5]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		if ((ops->oobbuf) || (ops->mode == MTD_OOB_RAW)) {
+
+			/* Transfer user buf contents into nand ctlr buffer */
+			if (ops->mode == MTD_OOB_AUTO) {
+				cmd->cmd = 0;
+				cmd->src = init_dma_addr;
+				cmd->dst = MSM_NAND_FLASH_BUFFER;
+				cmd->len = mtd->oobsize;
+				cmd++;
+			}
+			if (ops->mode == MTD_OOB_PLACE) {
+				cmd->cmd = 0;
+				cmd->src = oob_dma_addr_curr;
+				cmd->dst = MSM_NAND_FLASH_BUFFER;
+				cmd->len = mtd->oobsize;
+				oob_dma_addr_curr += mtd->oobsize;
+				cmd++;
+			}
+			if (ops->mode == MTD_OOB_RAW) {
+				cmd->cmd = 0;
+				cmd->src = data_dma_addr_curr;
+				cmd->dst = MSM_NAND_FLASH_BUFFER;
+				cmd->len = mtd->oobsize;
+				data_dma_addr_curr += mtd->oobsize;
+				cmd++;
+			}
+		} else {
+				cmd->cmd = 0;
+				cmd->src = init_dma_addr;
+				cmd->dst = MSM_NAND_FLASH_BUFFER;
+				cmd->len = mtd->oobsize;
+				cmd++;
+		}
+
+		/* Write the MACRO1 register */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.macro[4]);
+		cmd->dst = MSM_NAND_MACRO1_REG;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[5]);
+		cmd->len = 4;
+		cmd++;
+
+		/*********************************************************/
+		/* Issuing write command                                 */
+		/*********************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[6]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[6]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Wait for the interrupt from the Onenand device controller */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[7]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[7]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Read necessary status registers from the onenand device   */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[8]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[8]);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the GENP3 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_GENP_REG3;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data3);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the DEVCMD4 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_DEV_CMD4;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Restore the necessary registers to proper values          */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[9]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[9]);
+		cmd->len = 4;
+		cmd++;
+
+
+		BUILD_BUG_ON(53 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+		dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+				>> 3) | CMD_PTR_LP;
+
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+				&dma_buffer->cmdptr)));
+		mb();
+
+		ecc_status = (dma_buffer->data.data3 >> 16) & 0x0000FFFF;
+		interrupt_status = (dma_buffer->data.data4 >> 0)&0x0000FFFF;
+		controller_status = (dma_buffer->data.data4 >> 16)&0x0000FFFF;
+
+#if VERBOSE
+		pr_info("\n%s: sflash status %x %x %x %x %x %x %x"
+				" %x %x %x\n", __func__,
+					dma_buffer->data.sfstat[0],
+					dma_buffer->data.sfstat[1],
+					dma_buffer->data.sfstat[2],
+					dma_buffer->data.sfstat[3],
+					dma_buffer->data.sfstat[4],
+					dma_buffer->data.sfstat[5],
+					dma_buffer->data.sfstat[6],
+					dma_buffer->data.sfstat[7],
+					dma_buffer->data.sfstat[8],
+					dma_buffer->data.sfstat[9]);
+
+		pr_info("%s: controller_status = %x\n", __func__,
+					controller_status);
+		pr_info("%s: interrupt_status = %x\n", __func__,
+					interrupt_status);
+		pr_info("%s: ecc_status = %x\n", __func__,
+					ecc_status);
+#endif
+		/* Check for errors, protection violations etc */
+		if ((controller_status != 0)
+				|| (dma_buffer->data.sfstat[0] & 0x110)
+				|| (dma_buffer->data.sfstat[6] & 0x110)
+				|| (dma_buffer->data.sfstat[7] & 0x110)
+				|| (dma_buffer->data.sfstat[8] & 0x110)
+				|| (dma_buffer->data.sfstat[9] & 0x110)
+				|| ((dma_buffer->data.sfstat[1] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[2] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[3] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[4] & 0x110) &&
+								(ops->datbuf))
+				|| ((dma_buffer->data.sfstat[5] & 0x110) &&
+								((ops->oobbuf)
+					|| (ops->mode == MTD_OOB_RAW)))) {
+			pr_info("%s: ECC/MPU/OP error\n", __func__);
+			err = -EIO;
+		}
+
+		if (err)
+			break;
+		pages_written++;
+		to_curr += mtd->writesize;
+	}
+
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+	dma_unmap_page(chip->dev, init_dma_addr, 64, DMA_TO_DEVICE);
+
+err_dma_map_initbuf_failed:
+	if (ops->oobbuf) {
+		dma_unmap_page(chip->dev, oob_dma_addr, ops->ooblen,
+							DMA_TO_DEVICE);
+	}
+err_dma_map_oobbuf_failed:
+	if (ops->datbuf) {
+		dma_unmap_page(chip->dev, data_dma_addr, ops->len,
+							DMA_TO_DEVICE);
+	}
+
+	if (err) {
+		pr_err("%s: %llx %x %x failed\n", __func__, to_curr,
+				ops->datbuf ? ops->len : 0, ops->ooblen);
+	} else {
+		ops->retlen = ops->oobretlen = 0;
+		if (ops->datbuf != NULL) {
+			if (ops->mode != MTD_OOB_RAW)
+				ops->retlen = mtd->writesize * pages_written;
+			else
+				ops->retlen = (mtd->writesize +  mtd->oobsize)
+							* pages_written;
+		}
+		if (ops->oobbuf != NULL) {
+			if (ops->mode == MTD_OOB_AUTO)
+				ops->oobretlen = mtd->oobavail * pages_written;
+			else
+				ops->oobretlen = mtd->oobsize * pages_written;
+		}
+	}
 
-	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+#if VERBOSE
+	pr_info("\n%s: ret %d, retlen %d oobretlen %d\n",
+			__func__, err, ops->retlen, ops->oobretlen);
 
-	if (ops->oobbuf)
-		dma_unmap_page(chip->dev, oob_dma_addr,
-			       ops->ooblen, DMA_TO_DEVICE);
-err_dma_map_oobbuf_failed:
-	if (ops->datbuf)
-		dma_unmap_page(chip->dev, data_dma_addr,
-			       ops->len, DMA_TO_DEVICE);
-	if (err)
-		pr_err("msm_nand_write_oob %llx %x %x failed %d\n",
-		       to, ops->len, ops->ooblen, err);
+	pr_info("================================================="
+			"================\n");
+#endif
+	kfree(init_spare_bytes);
 	return err;
 }
 
-static int msm_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
-			  size_t *retlen, const u_char *buf)
+static int msm_onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
 {
 	int ret;
 	struct mtd_oob_ops ops;
 
 	ops.mode = MTD_OOB_PLACE;
+	ops.datbuf = (uint8_t *)buf;
 	ops.len = len;
 	ops.retlen = 0;
-	ops.ooblen = 0;
-	ops.datbuf = (uint8_t *)buf;
 	ops.oobbuf = NULL;
-	ret =  msm_nand_write_oob(mtd, to, &ops);
+	ops.ooblen = 0;
+	ops.oobretlen = 0;
+	ret =  msm_onenand_write_oob(mtd, to, &ops);
 	*retlen = ops.retlen;
+
 	return ret;
 }
 
-static int
-msm_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
+static int msm_onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	int err;
 	struct msm_nand_chip *chip = mtd->priv;
+
 	struct {
-		dmov_s cmd[5];
+		dmov_s cmd[20];
 		unsigned cmdptr;
-		unsigned data[9];
+		struct {
+			uint32_t sfbcfg;
+			uint32_t sfcmd[4];
+			uint32_t sfexec;
+			uint32_t sfstat[4];
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t addr2;
+			uint32_t addr3;
+			uint32_t addr4;
+			uint32_t addr5;
+			uint32_t addr6;
+			uint32_t data0;
+			uint32_t data1;
+			uint32_t data2;
+			uint32_t data3;
+			uint32_t data4;
+			uint32_t data5;
+			uint32_t data6;
+		} data;
 	} *dma_buffer;
-	unsigned page = instr->addr >> chip->page_shift;
+	dmov_s *cmd;
+
+	int err = 0;
+
+	uint16_t onenand_startaddr1;
+	uint16_t onenand_startaddr8;
+	uint16_t onenand_startaddr2;
+	uint16_t onenand_startbuffer;
+
+	uint16_t controller_status;
+	uint16_t interrupt_status;
+	uint16_t ecc_status;
+
+	uint64_t temp;
 
+#if VERBOSE
+	pr_info("================================================="
+			"================\n");
+	pr_info("%s: addr 0x%llx len 0x%llx\n",
+			__func__, instr->addr, instr->len);
+#endif
 	if (instr->addr & (mtd->erasesize - 1)) {
-		pr_err("%s: unsupported erase address, 0x%llx\n",
-		       __func__, instr->addr);
+		pr_err("%s: Unsupported erase address, 0x%llx\n",
+				__func__, instr->addr);
 		return -EINVAL;
 	}
 	if (instr->len != mtd->erasesize) {
-		pr_err("%s: unsupported erase len, %lld\n",
-		       __func__, instr->len);
+		pr_err("%s: Unsupported erase len, %lld\n",
+				__func__, instr->len);
 		return -EINVAL;
 	}
 
-	wait_event(chip->wait_queue,
-		   (dma_buffer = msm_nand_get_dma_buffer(
-			    chip, sizeof(*dma_buffer))));
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
 
-	dma_buffer->data[0] = MSM_NAND_CMD_BLOCK_ERASE;
-	dma_buffer->data[1] = page;
-	dma_buffer->data[2] = 0;
-	dma_buffer->data[3] = 0 | 4;
-	dma_buffer->data[4] = 1;
-	dma_buffer->data[5] = 0xeeeeeeee;
-	dma_buffer->data[6] = chip->CFG0 & (~(7 << 6));  /* CW_PER_PAGE = 0 */
-	dma_buffer->data[7] = chip->CFG1;
-	dma_buffer->data[8] = 0;
-	BUILD_BUG_ON(8 != ARRAY_SIZE(dma_buffer->data) - 1);
-
-	dma_buffer->cmd[0].cmd = DST_CRCI_NAND_CMD | CMD_OCB;
-	dma_buffer->cmd[0].src = msm_virt_to_dma(chip, &dma_buffer->data[0]);
-	dma_buffer->cmd[0].dst = MSM_NAND_FLASH_CMD;
-	dma_buffer->cmd[0].len = 16;
+	cmd = dma_buffer->cmd;
 
-	dma_buffer->cmd[1].cmd = 0;
-	dma_buffer->cmd[1].src = msm_virt_to_dma(chip, &dma_buffer->data[6]);
-	dma_buffer->cmd[1].dst = MSM_NAND_DEV0_CFG0;
-	dma_buffer->cmd[1].len = 8;
+	temp = instr->addr;
 
-	dma_buffer->cmd[2].cmd = 0;
-	dma_buffer->cmd[2].src = msm_virt_to_dma(chip, &dma_buffer->data[4]);
-	dma_buffer->cmd[2].dst = MSM_NAND_EXEC_CMD;
-	dma_buffer->cmd[2].len = 4;
+	if ((onenand_info.device_id & ONENAND_DEVICE_IS_DDP)
+		&& (temp >= (mtd->size>>1))) { /* DDP Device */
+			onenand_startaddr1 = DEVICE_FLASHCORE_1 |
+				(((uint32_t)(temp-(mtd->size>>1))
+						/ mtd->erasesize));
+			onenand_startaddr2 = DEVICE_BUFFERRAM_1;
+	} else {
+		onenand_startaddr1 = DEVICE_FLASHCORE_0 |
+			((uint32_t)temp / mtd->erasesize) ;
+		onenand_startaddr2 = DEVICE_BUFFERRAM_0;
+	}
 
-	dma_buffer->cmd[3].cmd = SRC_CRCI_NAND_DATA;
-	dma_buffer->cmd[3].src = MSM_NAND_FLASH_STATUS;
-	dma_buffer->cmd[3].dst = msm_virt_to_dma(chip, &dma_buffer->data[5]);
-	dma_buffer->cmd[3].len = 4;
+	onenand_startaddr8 = 0x0000;
+	onenand_startbuffer = DATARAM0_0 << 8;
+
+	dma_buffer->data.sfbcfg = SFLASH_BCFG |
+					(nand_sfcmd_mode ? 0 : (1 << 24));
+	dma_buffer->data.sfcmd[0] = SFLASH_PREPCMD(7, 0, 0,
+						MSM_NAND_SFCMD_CMDXS,
+						nand_sfcmd_mode,
+						MSM_NAND_SFCMD_REGWR);
+	dma_buffer->data.sfcmd[1] = SFLASH_PREPCMD(0, 0, 32,
+						MSM_NAND_SFCMD_CMDXS,
+						nand_sfcmd_mode,
+						MSM_NAND_SFCMD_INTHI);
+	dma_buffer->data.sfcmd[2] = SFLASH_PREPCMD(3, 7, 0,
+						MSM_NAND_SFCMD_DATXS,
+						nand_sfcmd_mode,
+						MSM_NAND_SFCMD_REGRD);
+	dma_buffer->data.sfcmd[3] = SFLASH_PREPCMD(4, 10, 0,
+						MSM_NAND_SFCMD_CMDXS,
+						nand_sfcmd_mode,
+						MSM_NAND_SFCMD_REGWR);
+	dma_buffer->data.sfexec = 1;
+	dma_buffer->data.sfstat[0] = CLEAN_DATA_32;
+	dma_buffer->data.sfstat[1] = CLEAN_DATA_32;
+	dma_buffer->data.sfstat[2] = CLEAN_DATA_32;
+	dma_buffer->data.sfstat[3] = CLEAN_DATA_32;
+	dma_buffer->data.addr0 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+	dma_buffer->data.addr1 = (ONENAND_START_ADDRESS_8 << 16) |
+						(ONENAND_START_ADDRESS_1);
+	dma_buffer->data.addr2 = (ONENAND_START_BUFFER << 16) |
+						(ONENAND_START_ADDRESS_2);
+	dma_buffer->data.addr3 = (ONENAND_ECC_STATUS << 16) |
+						(ONENAND_COMMAND);
+	dma_buffer->data.addr4 = (ONENAND_CONTROLLER_STATUS << 16) |
+						(ONENAND_INTERRUPT_STATUS);
+	dma_buffer->data.addr5 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+	dma_buffer->data.addr6 = (ONENAND_START_ADDRESS_3 << 16) |
+						(ONENAND_START_ADDRESS_1);
+	dma_buffer->data.data0 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+	dma_buffer->data.data1 = (onenand_startaddr8 << 16) |
+						(onenand_startaddr1);
+	dma_buffer->data.data2 = (onenand_startbuffer << 16) |
+						(onenand_startaddr2);
+	dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+						(ONENAND_CMDERAS);
+	dma_buffer->data.data4 = (CLEAN_DATA_16 << 16) |
+						(CLEAN_DATA_16);
+	dma_buffer->data.data5 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+	dma_buffer->data.data6 = (ONENAND_STARTADDR3_RES << 16) |
+						(ONENAND_STARTADDR1_RES);
+
+	/***************************************************************/
+	/* Write the necessary address registers in the onenand device */
+	/***************************************************************/
+
+	/* Enable and configure the SFlash controller */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfbcfg);
+	cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+	cmd->len = 4;
+	cmd++;
 
-	/* clear the status register in case the OP_ERR is set
-	 * due to the write, to work around a h/w bug */
-	dma_buffer->cmd[4].cmd = CMD_OCU | CMD_LC;
-	dma_buffer->cmd[4].src = msm_virt_to_dma(chip, &dma_buffer->data[8]);
-	dma_buffer->cmd[4].dst = MSM_NAND_FLASH_STATUS;
-	dma_buffer->cmd[4].len = 4;
+	/* Block on cmd ready and write CMD register */
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[0]);
+	cmd->dst = MSM_NAND_SFLASHC_CMD;
+	cmd->len = 4;
+	cmd++;
 
-	BUILD_BUG_ON(4 != ARRAY_SIZE(dma_buffer->cmd) - 1);
+	/* Write the ADDR0 and ADDR1 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr0);
+	cmd->dst = MSM_NAND_ADDR0;
+	cmd->len = 8;
+	cmd++;
 
-	dma_buffer->cmdptr =
-		(msm_virt_to_dma(chip, dma_buffer->cmd) >> 3) | CMD_PTR_LP;
+	/* Write the ADDR2 ADDR3 ADDR4 ADDR5 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr2);
+	cmd->dst = MSM_NAND_ADDR2;
+	cmd->len = 16;
+	cmd++;
 
-	msm_dmov_exec_cmd(
-		chip->dma_channel, DMOV_CMD_PTR_LIST |
-		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	/* Write the ADDR6 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr6);
+	cmd->dst = MSM_NAND_ADDR6;
+	cmd->len = 4;
+	cmd++;
 
-	/* we fail if there was an operation error, a mpu error, or the
-	 * erase success bit was not set.
-	 */
+	/* Write the GENP0, GENP1, GENP2, GENP3, GENP4 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data0);
+	cmd->dst = MSM_NAND_GENP_REG0;
+	cmd->len = 16;
+	cmd++;
+
+	/* Write the FLASH_DEV_CMD4,5,6 registers */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+	cmd->dst = MSM_NAND_DEV_CMD4;
+	cmd->len = 12;
+	cmd++;
+
+	/* Kick the execute command */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+	cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Block on data ready, and read the status register */
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_SFLASHC_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[0]);
+	cmd->len = 4;
+	cmd++;
+
+	/***************************************************************/
+	/* Wait for the interrupt from the Onenand device controller   */
+	/***************************************************************/
+
+	/* Block on cmd ready and write CMD register */
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[1]);
+	cmd->dst = MSM_NAND_SFLASHC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Kick the execute command */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+	cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Block on data ready, and read the status register */
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_SFLASHC_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[1]);
+	cmd->len = 4;
+	cmd++;
+
+	/***************************************************************/
+	/* Read the necessary status registers from the onenand device */
+	/***************************************************************/
+
+	/* Block on cmd ready and write CMD register */
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[2]);
+	cmd->dst = MSM_NAND_SFLASHC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Kick the execute command */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+	cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Block on data ready, and read the status register */
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_SFLASHC_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[2]);
+	cmd->len = 4;
+	cmd++;
+
+	/* Read the GENP3 register */
+	cmd->cmd = 0;
+	cmd->src = MSM_NAND_GENP_REG3;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data3);
+	cmd->len = 4;
+	cmd++;
+
+	/* Read the DEVCMD4 register */
+	cmd->cmd = 0;
+	cmd->src = MSM_NAND_DEV_CMD4;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+	cmd->len = 4;
+	cmd++;
+
+	/***************************************************************/
+	/* Restore the necessary registers to proper values            */
+	/***************************************************************/
+
+	/* Block on cmd ready and write CMD register */
+	cmd->cmd = DST_CRCI_NAND_CMD;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[3]);
+	cmd->dst = MSM_NAND_SFLASHC_CMD;
+	cmd->len = 4;
+	cmd++;
+
+	/* Kick the execute command */
+	cmd->cmd = 0;
+	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+	cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+	cmd->len = 4;
+	cmd++;
 
-	if (dma_buffer->data[5] & 0x110 || !(dma_buffer->data[5] & 0x80)) {
-		if (dma_buffer->data[5] & 0x10)
-			pr_warning("msm_nand: critical erase error, 0x%llx\n",
-				   instr->addr);
+	/* Block on data ready, and read the status register */
+	cmd->cmd = SRC_CRCI_NAND_DATA;
+	cmd->src = MSM_NAND_SFLASHC_STATUS;
+	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[3]);
+	cmd->len = 4;
+	cmd++;
+
+
+	BUILD_BUG_ON(20 != ARRAY_SIZE(dma_buffer->cmd));
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+	dma_buffer->cmd[0].cmd |= CMD_OCB;
+	cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+	dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+			>> 3) | CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST
+			| DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+			&dma_buffer->cmdptr)));
+	mb();
+
+	ecc_status = (dma_buffer->data.data3 >> 16) & 0x0000FFFF;
+	interrupt_status = (dma_buffer->data.data4 >> 0) & 0x0000FFFF;
+	controller_status = (dma_buffer->data.data4 >> 16) & 0x0000FFFF;
+
+#if VERBOSE
+	pr_info("\n%s: sflash status %x %x %x %x\n", __func__,
+				dma_buffer->data.sfstat[0],
+				dma_buffer->data.sfstat[1],
+				dma_buffer->data.sfstat[2],
+				dma_buffer->data.sfstat[3]);
+
+	pr_info("%s: controller_status = %x\n", __func__,
+				controller_status);
+	pr_info("%s: interrupt_status = %x\n", __func__,
+				interrupt_status);
+	pr_info("%s: ecc_status = %x\n", __func__,
+				ecc_status);
+#endif
+	/* Check for errors, protection violations etc */
+	if ((controller_status != 0)
+			|| (dma_buffer->data.sfstat[0] & 0x110)
+			|| (dma_buffer->data.sfstat[1] & 0x110)
+			|| (dma_buffer->data.sfstat[2] & 0x110)
+			|| (dma_buffer->data.sfstat[3] & 0x110)) {
+		pr_err("%s: ECC/MPU/OP error\n", __func__);
 		err = -EIO;
-	} else
-		err = 0;
+	}
 
 	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
 	if (err) {
-		pr_err("%s: erase failed, 0x%llx\n", __func__, instr->addr);
+		pr_err("%s: Erase failed, 0x%llx\n", __func__,
+				instr->addr);
 		instr->fail_addr = instr->addr;
 		instr->state = MTD_ERASE_FAILED;
 	} else {
@@ -1228,226 +5783,888 @@ msm_nand_erase(struct mtd_info *mtd, struct erase_info *instr)
 		instr->fail_addr = 0xffffffff;
 		mtd_erase_callback(instr);
 	}
+
+#if VERBOSE
+	pr_info("\n%s: ret %d\n", __func__, err);
+	pr_info("===================================================="
+			"=============\n");
+#endif
 	return err;
 }
 
-static int
-msm_nand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+static int msm_onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct mtd_oob_ops ops;
+	int rval, i;
+	int ret = 0;
+	uint8_t *buffer;
+	uint8_t *oobptr;
+
+	if ((ofs > mtd->size) || (ofs & (mtd->erasesize - 1))) {
+		pr_err("%s: unsupported block address, 0x%x\n",
+			 __func__, (uint32_t)ofs);
+		return -EINVAL;
+	}
+
+	buffer = kmalloc(2112, GFP_KERNEL|GFP_DMA);
+	if (buffer == 0) {
+		pr_err("%s: Could not kmalloc for buffer\n",
+				__func__);
+		return -ENOMEM;
+	}
+
+	memset(buffer, 0x00, 2112);
+	oobptr = &(buffer[2048]);
+
+	ops.mode = MTD_OOB_RAW;
+	ops.len = 2112;
+	ops.retlen = 0;
+	ops.ooblen = 0;
+	ops.oobretlen = 0;
+	ops.ooboffs = 0;
+	ops.datbuf = buffer;
+	ops.oobbuf = NULL;
+
+	for (i = 0; i < 2; i++) {
+		ofs = ofs + i*mtd->writesize;
+		rval = msm_onenand_read_oob(mtd, ofs, &ops);
+		if (rval) {
+			pr_err("%s: Error in reading bad blk info\n",
+					__func__);
+			ret = rval;
+			break;
+		}
+		if ((oobptr[0] != 0xFF) || (oobptr[1] != 0xFF) ||
+		    (oobptr[16] != 0xFF) || (oobptr[17] != 0xFF) ||
+		    (oobptr[32] != 0xFF) || (oobptr[33] != 0xFF) ||
+		    (oobptr[48] != 0xFF) || (oobptr[49] != 0xFF)
+		   ) {
+			ret = 1;
+			break;
+		}
+	}
+
+	kfree(buffer);
+
+#if VERBOSE
+	if (ret == 1)
+		pr_info("%s : Block containing 0x%x is bad\n",
+				__func__, (unsigned int)ofs);
+#endif
+	return ret;
+}
+
+static int msm_onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	struct mtd_oob_ops ops;
+	int rval, i;
+	int ret = 0;
+	uint8_t *buffer;
+
+	if ((ofs > mtd->size) || (ofs & (mtd->erasesize - 1))) {
+		pr_err("%s: unsupported block address, 0x%x\n",
+			 __func__, (uint32_t)ofs);
+		return -EINVAL;
+	}
+
+	buffer = page_address(ZERO_PAGE());
+
+	ops.mode = MTD_OOB_RAW;
+	ops.len = 2112;
+	ops.retlen = 0;
+	ops.ooblen = 0;
+	ops.oobretlen = 0;
+	ops.ooboffs = 0;
+	ops.datbuf = buffer;
+	ops.oobbuf = NULL;
+
+	for (i = 0; i < 2; i++) {
+		ofs = ofs + i*mtd->writesize;
+		rval = msm_onenand_write_oob(mtd, ofs, &ops);
+		if (rval) {
+			pr_err("%s: Error in writing bad blk info\n",
+					__func__);
+			ret = rval;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int msm_onenand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	struct msm_nand_chip *chip = mtd->priv;
-	int ret;
+
 	struct {
-		dmov_s cmd[5];
+		dmov_s cmd[20];
 		unsigned cmdptr;
 		struct {
-			uint32_t cmd;
+			uint32_t sfbcfg;
+			uint32_t sfcmd[4];
+			uint32_t sfexec;
+			uint32_t sfstat[4];
 			uint32_t addr0;
 			uint32_t addr1;
-			uint32_t chipsel;
-			uint32_t cfg0;
-			uint32_t cfg1;
-			uint32_t exec;
-			uint32_t ecccfg;
-			struct {
-				uint32_t flash_status;
-				uint32_t buffer_status;
-			} result;
+			uint32_t addr2;
+			uint32_t addr3;
+			uint32_t addr4;
+			uint32_t addr5;
+			uint32_t addr6;
+			uint32_t data0;
+			uint32_t data1;
+			uint32_t data2;
+			uint32_t data3;
+			uint32_t data4;
+			uint32_t data5;
+			uint32_t data6;
 		} data;
 	} *dma_buffer;
 	dmov_s *cmd;
-	uint8_t *buf;
-	unsigned page = ofs >> chip->page_shift;
 
-	/* Check for invalid offset */
-	if (ofs > mtd->size)
+	int err = 0;
+
+	uint16_t onenand_startaddr1;
+	uint16_t onenand_startaddr8;
+	uint16_t onenand_startaddr2;
+	uint16_t onenand_startblock;
+
+	uint16_t controller_status;
+	uint16_t interrupt_status;
+	uint16_t write_prot_status;
+
+	uint64_t start_ofs;
+
+#if VERBOSE
+	pr_info("===================================================="
+			"=============\n");
+	pr_info("%s: ofs 0x%llx len %lld\n", __func__, ofs, len);
+#endif
+	/* 'ofs' & 'len' should align to block size */
+	if (ofs&(mtd->erasesize - 1)) {
+		pr_err("%s: Unsupported ofs address, 0x%llx\n",
+				__func__, ofs);
 		return -EINVAL;
-	if (ofs & (mtd->erasesize - 1)) {
-		pr_err("%s: unsupported block address, 0x%x\n",
-			 __func__, (uint32_t)ofs);
+	}
+
+	if (len&(mtd->erasesize - 1)) {
+		pr_err("%s: Unsupported len, %lld\n",
+				__func__, len);
 		return -EINVAL;
 	}
 
-	wait_event(chip->wait_queue,
-		(dma_buffer = msm_nand_get_dma_buffer(chip ,
-					 sizeof(*dma_buffer) + 4)));
-	buf = (uint8_t *)dma_buffer + sizeof(*dma_buffer);
+	if (ofs+len > mtd->size) {
+		pr_err("%s: Maximum chip size exceeded\n", __func__);
+		return -EINVAL;
+	}
 
-	/* Read 4 bytes starting from the bad block marker location
-	 * in the last code word of the page
-	 */
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
+
+	for (start_ofs = ofs; ofs < start_ofs+len; ofs = ofs+mtd->erasesize) {
+#if VERBOSE
+		pr_info("%s: ofs 0x%llx len %lld\n", __func__, ofs, len);
+#endif
+
+		cmd = dma_buffer->cmd;
+		if ((onenand_info.device_id & ONENAND_DEVICE_IS_DDP)
+			&& (ofs >= (mtd->size>>1))) { /* DDP Device */
+			onenand_startaddr1 = DEVICE_FLASHCORE_1 |
+				(((uint32_t)(ofs - (mtd->size>>1))
+						/ mtd->erasesize));
+			onenand_startaddr2 = DEVICE_BUFFERRAM_1;
+			onenand_startblock = ((uint32_t)(ofs - (mtd->size>>1))
+						/ mtd->erasesize);
+		} else {
+			onenand_startaddr1 = DEVICE_FLASHCORE_0 |
+					((uint32_t)ofs / mtd->erasesize) ;
+			onenand_startaddr2 = DEVICE_BUFFERRAM_0;
+			onenand_startblock = ((uint32_t)ofs
+						/ mtd->erasesize);
+		}
+
+		onenand_startaddr8 = 0x0000;
+		dma_buffer->data.sfbcfg = SFLASH_BCFG |
+					(nand_sfcmd_mode ? 0 : (1 << 24));
+		dma_buffer->data.sfcmd[0] = SFLASH_PREPCMD(7, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfcmd[1] = SFLASH_PREPCMD(0, 0, 32,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_INTHI);
+		dma_buffer->data.sfcmd[2] = SFLASH_PREPCMD(3, 7, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGRD);
+		dma_buffer->data.sfcmd[3] = SFLASH_PREPCMD(4, 10, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfexec = 1;
+		dma_buffer->data.sfstat[0] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[1] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[2] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[3] = CLEAN_DATA_32;
+		dma_buffer->data.addr0 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr1 = (ONENAND_START_ADDRESS_8 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.addr2 = (ONENAND_START_BLOCK_ADDRESS << 16) |
+						(ONENAND_START_ADDRESS_2);
+		dma_buffer->data.addr3 = (ONENAND_WRITE_PROT_STATUS << 16) |
+						(ONENAND_COMMAND);
+		dma_buffer->data.addr4 = (ONENAND_CONTROLLER_STATUS << 16) |
+						(ONENAND_INTERRUPT_STATUS);
+		dma_buffer->data.addr5 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr6 = (ONENAND_START_ADDRESS_3 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.data0 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+		dma_buffer->data.data1 = (onenand_startaddr8 << 16) |
+						(onenand_startaddr1);
+		dma_buffer->data.data2 = (onenand_startblock << 16) |
+						(onenand_startaddr2);
+		dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+						(ONENAND_CMD_UNLOCK);
+		dma_buffer->data.data4 = (CLEAN_DATA_16 << 16) |
+						(CLEAN_DATA_16);
+		dma_buffer->data.data5 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+		dma_buffer->data.data6 = (ONENAND_STARTADDR3_RES << 16) |
+						(ONENAND_STARTADDR1_RES);
+
+		/*************************************************************/
+		/* Write the necessary address reg in the onenand device     */
+		/*************************************************************/
+
+		/* Enable and configure the SFlash controller */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfbcfg);
+		cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[0]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the ADDR0 and ADDR1 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr0);
+		cmd->dst = MSM_NAND_ADDR0;
+		cmd->len = 8;
+		cmd++;
+
+		/* Write the ADDR2 ADDR3 ADDR4 ADDR5 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr2);
+		cmd->dst = MSM_NAND_ADDR2;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the ADDR6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr6);
+		cmd->dst = MSM_NAND_ADDR6;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the GENP0, GENP1, GENP2, GENP3, GENP4 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data0);
+		cmd->dst = MSM_NAND_GENP_REG0;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the FLASH_DEV_CMD4,5,6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->dst = MSM_NAND_DEV_CMD4;
+		cmd->len = 12;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[0]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Wait for the interrupt from the Onenand device controller */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[1]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[1]);
+		cmd->len = 4;
+		cmd++;
+
+		/*********************************************************/
+		/* Read the necessary status reg from the onenand device */
+		/*********************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[2]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[2]);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the GENP3 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_GENP_REG3;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data3);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the DEVCMD4 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_DEV_CMD4;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->len = 4;
+		cmd++;
+
+		/************************************************************/
+		/* Restore the necessary registers to proper values         */
+		/************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[3]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[3]);
+		cmd->len = 4;
+		cmd++;
+
+
+		BUILD_BUG_ON(20 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
+
+		dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+				>> 3) | CMD_PTR_LP;
+
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+				&dma_buffer->cmdptr)));
+		mb();
+
+		write_prot_status = (dma_buffer->data.data3 >> 16) & 0x0000FFFF;
+		interrupt_status = (dma_buffer->data.data4 >> 0) & 0x0000FFFF;
+		controller_status = (dma_buffer->data.data4 >> 16) & 0x0000FFFF;
+
+#if VERBOSE
+		pr_info("\n%s: sflash status %x %x %x %x\n", __func__,
+					dma_buffer->data.sfstat[0],
+					dma_buffer->data.sfstat[1],
+					dma_buffer->data.sfstat[2],
+					dma_buffer->data.sfstat[3]);
+
+		pr_info("%s: controller_status = %x\n", __func__,
+					controller_status);
+		pr_info("%s: interrupt_status = %x\n", __func__,
+					interrupt_status);
+		pr_info("%s: write_prot_status = %x\n", __func__,
+					write_prot_status);
+#endif
+		/* Check for errors, protection violations etc */
+		if ((controller_status != 0)
+				|| (dma_buffer->data.sfstat[0] & 0x110)
+				|| (dma_buffer->data.sfstat[1] & 0x110)
+				|| (dma_buffer->data.sfstat[2] & 0x110)
+				|| (dma_buffer->data.sfstat[3] & 0x110)) {
+			pr_err("%s: ECC/MPU/OP error\n", __func__);
+			err = -EIO;
+		}
 
-	cmd = dma_buffer->cmd;
+		if (!(write_prot_status & ONENAND_WP_US)) {
+			pr_err("%s: Unexpected status ofs = 0x%llx,"
+				"wp_status = %x\n",
+				__func__, ofs, write_prot_status);
+			err = -EIO;
+		}
 
-	dma_buffer->data.cmd = MSM_NAND_CMD_PAGE_READ;
-	dma_buffer->data.cfg0 = MSM_NAND_CFG0_RAW & ~(7U << 6);
-	dma_buffer->data.cfg1 = MSM_NAND_CFG1_RAW | (chip->CFG1 & CFG1_WIDE_FLASH);
+		if (err)
+			break;
+	}
 
-	if (chip->CFG1 & CFG1_WIDE_FLASH)
-		dma_buffer->data.addr0 = (page << 16) |
-			((528 * chip->last_sector) >> 1);
-	else
-		dma_buffer->data.addr0 = (page << 16) |
-			(528 * chip->last_sector);
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
 
-	dma_buffer->data.addr1 = (page >> 16) & 0xff;
-	dma_buffer->data.chipsel = 0 | 4;
+#if VERBOSE
+	pr_info("\n%s: ret %d\n", __func__, err);
+	pr_info("===================================================="
+			"=============\n");
+#endif
+	return err;
+}
 
-	dma_buffer->data.exec = 1;
+static int msm_onenand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	struct msm_nand_chip *chip = mtd->priv;
 
-	dma_buffer->data.result.flash_status = 0xeeeeeeee;
-	dma_buffer->data.result.buffer_status = 0xeeeeeeee;
+	struct {
+		dmov_s cmd[20];
+		unsigned cmdptr;
+		struct {
+			uint32_t sfbcfg;
+			uint32_t sfcmd[4];
+			uint32_t sfexec;
+			uint32_t sfstat[4];
+			uint32_t addr0;
+			uint32_t addr1;
+			uint32_t addr2;
+			uint32_t addr3;
+			uint32_t addr4;
+			uint32_t addr5;
+			uint32_t addr6;
+			uint32_t data0;
+			uint32_t data1;
+			uint32_t data2;
+			uint32_t data3;
+			uint32_t data4;
+			uint32_t data5;
+			uint32_t data6;
+		} data;
+	} *dma_buffer;
+	dmov_s *cmd;
 
-	cmd->cmd = DST_CRCI_NAND_CMD;
-	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cmd);
-	cmd->dst = MSM_NAND_FLASH_CMD;
-	cmd->len = 16;
-	cmd++;
+	int err = 0;
 
-	cmd->cmd = 0;
-	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.cfg0);
-	cmd->dst = MSM_NAND_DEV0_CFG0;
-	cmd->len = 8;
-	cmd++;
+	uint16_t onenand_startaddr1;
+	uint16_t onenand_startaddr8;
+	uint16_t onenand_startaddr2;
+	uint16_t onenand_startblock;
 
-	cmd->cmd = 0;
-	cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.exec);
-	cmd->dst = MSM_NAND_EXEC_CMD;
-	cmd->len = 4;
-	cmd++;
+	uint16_t controller_status;
+	uint16_t interrupt_status;
+	uint16_t write_prot_status;
 
-	cmd->cmd = SRC_CRCI_NAND_DATA;
-	cmd->src = MSM_NAND_FLASH_STATUS;
-	cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.result);
-	cmd->len = 8;
-	cmd++;
+	uint64_t start_ofs;
 
-	cmd->cmd = 0;
-	cmd->src = MSM_NAND_FLASH_BUFFER +
-		(mtd->writesize - 528 * chip->last_sector);
-	cmd->dst = msm_virt_to_dma(chip, buf);
-	cmd->len = 4;
-	cmd++;
+#if VERBOSE
+	pr_info("===================================================="
+			"=============\n");
+	pr_info("%s: ofs 0x%llx len %lld\n", __func__, ofs, len);
+#endif
+	/* 'ofs' & 'len' should align to block size */
+	if (ofs&(mtd->erasesize - 1)) {
+		pr_err("%s: Unsupported ofs address, 0x%llx\n",
+				__func__, ofs);
+		return -EINVAL;
+	}
 
-	BUILD_BUG_ON(5 != ARRAY_SIZE(dma_buffer->cmd));
-	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
-	dma_buffer->cmd[0].cmd |= CMD_OCB;
-	cmd[-1].cmd |= CMD_OCU | CMD_LC;
+	if (len&(mtd->erasesize - 1)) {
+		pr_err("%s: Unsupported len, %lld\n",
+				__func__, len);
+		return -EINVAL;
+	}
 
-	dma_buffer->cmdptr = (msm_virt_to_dma(chip,
-				dma_buffer->cmd) >> 3) | CMD_PTR_LP;
+	if (ofs+len > mtd->size) {
+		pr_err("%s: Maximum chip size exceeded\n", __func__);
+		return -EINVAL;
+	}
 
-	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST |
-		DMOV_CMD_ADDR(msm_virt_to_dma(chip, &dma_buffer->cmdptr)));
+	wait_event(chip->wait_queue, (dma_buffer = msm_nand_get_dma_buffer
+				(chip, sizeof(*dma_buffer))));
 
-	ret = 0;
-	if (dma_buffer->data.result.flash_status & 0x110)
-		ret = -EIO;
+	for (start_ofs = ofs; ofs < start_ofs+len; ofs = ofs+mtd->erasesize) {
+#if VERBOSE
+		pr_info("%s: ofs 0x%llx len %lld\n", __func__, ofs, len);
+#endif
 
-	if (!ret) {
-		/* Check for bad block marker byte */
-		if (chip->CFG1 & CFG1_WIDE_FLASH) {
-			if (buf[0] != 0xFF || buf[1] != 0xFF)
-				ret = 1;
+		cmd = dma_buffer->cmd;
+		if ((onenand_info.device_id & ONENAND_DEVICE_IS_DDP)
+			&& (ofs >= (mtd->size>>1))) { /* DDP Device */
+			onenand_startaddr1 = DEVICE_FLASHCORE_1 |
+				(((uint32_t)(ofs - (mtd->size>>1))
+						/ mtd->erasesize));
+			onenand_startaddr2 = DEVICE_BUFFERRAM_1;
+			onenand_startblock = ((uint32_t)(ofs - (mtd->size>>1))
+						/ mtd->erasesize);
 		} else {
-			if (buf[0] != 0xFF)
-				ret = 1;
+			onenand_startaddr1 = DEVICE_FLASHCORE_0 |
+					((uint32_t)ofs / mtd->erasesize) ;
+			onenand_startaddr2 = DEVICE_BUFFERRAM_0;
+			onenand_startblock = ((uint32_t)ofs
+						/ mtd->erasesize);
 		}
-	}
 
-	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer) + 4);
-	return ret;
-}
+		onenand_startaddr8 = 0x0000;
+		dma_buffer->data.sfbcfg = SFLASH_BCFG |
+					(nand_sfcmd_mode ? 0 : (1 << 24));
+		dma_buffer->data.sfcmd[0] = SFLASH_PREPCMD(7, 0, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfcmd[1] = SFLASH_PREPCMD(0, 0, 32,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_INTHI);
+		dma_buffer->data.sfcmd[2] = SFLASH_PREPCMD(3, 7, 0,
+							MSM_NAND_SFCMD_DATXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGRD);
+		dma_buffer->data.sfcmd[3] = SFLASH_PREPCMD(4, 10, 0,
+							MSM_NAND_SFCMD_CMDXS,
+							nand_sfcmd_mode,
+							MSM_NAND_SFCMD_REGWR);
+		dma_buffer->data.sfexec = 1;
+		dma_buffer->data.sfstat[0] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[1] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[2] = CLEAN_DATA_32;
+		dma_buffer->data.sfstat[3] = CLEAN_DATA_32;
+		dma_buffer->data.addr0 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr1 = (ONENAND_START_ADDRESS_8 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.addr2 = (ONENAND_START_BLOCK_ADDRESS << 16) |
+						(ONENAND_START_ADDRESS_2);
+		dma_buffer->data.addr3 = (ONENAND_WRITE_PROT_STATUS << 16) |
+						(ONENAND_COMMAND);
+		dma_buffer->data.addr4 = (ONENAND_CONTROLLER_STATUS << 16) |
+						(ONENAND_INTERRUPT_STATUS);
+		dma_buffer->data.addr5 = (ONENAND_INTERRUPT_STATUS << 16) |
+						(ONENAND_SYSTEM_CONFIG_1);
+		dma_buffer->data.addr6 = (ONENAND_START_ADDRESS_3 << 16) |
+						(ONENAND_START_ADDRESS_1);
+		dma_buffer->data.data0 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+		dma_buffer->data.data1 = (onenand_startaddr8 << 16) |
+						(onenand_startaddr1);
+		dma_buffer->data.data2 = (onenand_startblock << 16) |
+						(onenand_startaddr2);
+		dma_buffer->data.data3 = (CLEAN_DATA_16 << 16) |
+						(ONENAND_CMD_LOCK);
+		dma_buffer->data.data4 = (CLEAN_DATA_16 << 16) |
+						(CLEAN_DATA_16);
+		dma_buffer->data.data5 = (ONENAND_CLRINTR << 16) |
+				(ONENAND_SYSCFG1_ECCENA(nand_sfcmd_mode));
+		dma_buffer->data.data6 = (ONENAND_STARTADDR3_RES << 16) |
+						(ONENAND_STARTADDR1_RES);
+
+		/*************************************************************/
+		/* Write the necessary address reg in the onenand device     */
+		/*************************************************************/
+
+		/* Enable and configure the SFlash controller */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfbcfg);
+		cmd->dst = MSM_NAND_SFLASHC_BURST_CFG;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[0]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the ADDR0 and ADDR1 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr0);
+		cmd->dst = MSM_NAND_ADDR0;
+		cmd->len = 8;
+		cmd++;
+
+		/* Write the ADDR2 ADDR3 ADDR4 ADDR5 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr2);
+		cmd->dst = MSM_NAND_ADDR2;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the ADDR6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.addr6);
+		cmd->dst = MSM_NAND_ADDR6;
+		cmd->len = 4;
+		cmd++;
+
+		/* Write the GENP0, GENP1, GENP2, GENP3, GENP4 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data0);
+		cmd->dst = MSM_NAND_GENP_REG0;
+		cmd->len = 16;
+		cmd++;
+
+		/* Write the FLASH_DEV_CMD4,5,6 registers */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->dst = MSM_NAND_DEV_CMD4;
+		cmd->len = 12;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[0]);
+		cmd->len = 4;
+		cmd++;
+
+		/*************************************************************/
+		/* Wait for the interrupt from the Onenand device controller */
+		/*************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[1]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[1]);
+		cmd->len = 4;
+		cmd++;
+
+		/*********************************************************/
+		/* Read the necessary status reg from the onenand device */
+		/*********************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[2]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[2]);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the GENP3 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_GENP_REG3;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data3);
+		cmd->len = 4;
+		cmd++;
+
+		/* Read the DEVCMD4 register */
+		cmd->cmd = 0;
+		cmd->src = MSM_NAND_DEV_CMD4;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.data4);
+		cmd->len = 4;
+		cmd++;
+
+		/************************************************************/
+		/* Restore the necessary registers to proper values         */
+		/************************************************************/
+
+		/* Block on cmd ready and write CMD register */
+		cmd->cmd = DST_CRCI_NAND_CMD;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfcmd[3]);
+		cmd->dst = MSM_NAND_SFLASHC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Kick the execute command */
+		cmd->cmd = 0;
+		cmd->src = msm_virt_to_dma(chip, &dma_buffer->data.sfexec);
+		cmd->dst = MSM_NAND_SFLASHC_EXEC_CMD;
+		cmd->len = 4;
+		cmd++;
+
+		/* Block on data ready, and read the status register */
+		cmd->cmd = SRC_CRCI_NAND_DATA;
+		cmd->src = MSM_NAND_SFLASHC_STATUS;
+		cmd->dst = msm_virt_to_dma(chip, &dma_buffer->data.sfstat[3]);
+		cmd->len = 4;
+		cmd++;
+
+
+		BUILD_BUG_ON(20 != ARRAY_SIZE(dma_buffer->cmd));
+		BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+		dma_buffer->cmd[0].cmd |= CMD_OCB;
+		cmd[-1].cmd |= CMD_OCU | CMD_LC;
 
+		dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd)
+				>> 3) | CMD_PTR_LP;
 
-static int
-msm_nand_block_markbad(struct mtd_info *mtd, loff_t ofs)
-{
-	struct mtd_oob_ops ops;
-	int ret;
-	uint8_t *buf;
+		mb();
+		msm_dmov_exec_cmd(chip->dma_channel,
+			DMOV_CMD_PTR_LIST | DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+				&dma_buffer->cmdptr)));
+		mb();
 
-	/* Check for invalid offset */
-	if (ofs > mtd->size)
-		return -EINVAL;
-	if (ofs & (mtd->erasesize - 1)) {
-		pr_err("%s: unsupported block address, 0x%x\n",
-				 __func__, (uint32_t)ofs);
-		return -EINVAL;
-	}
+		write_prot_status = (dma_buffer->data.data3 >> 16) & 0x0000FFFF;
+		interrupt_status = (dma_buffer->data.data4 >> 0) & 0x0000FFFF;
+		controller_status = (dma_buffer->data.data4 >> 16) & 0x0000FFFF;
 
-	/*
-	Write all 0s to the first page
-	This will set the BB marker to 0
-	*/
+#if VERBOSE
+		pr_info("\n%s: sflash status %x %x %x %x\n", __func__,
+					dma_buffer->data.sfstat[0],
+					dma_buffer->data.sfstat[1],
+					dma_buffer->data.sfstat[2],
+					dma_buffer->data.sfstat[3]);
+
+		pr_info("%s: controller_status = %x\n", __func__,
+					controller_status);
+		pr_info("%s: interrupt_status = %x\n", __func__,
+					interrupt_status);
+		pr_info("%s: write_prot_status = %x\n", __func__,
+					write_prot_status);
+#endif
+		/* Check for errors, protection violations etc */
+		if ((controller_status != 0)
+				|| (dma_buffer->data.sfstat[0] & 0x110)
+				|| (dma_buffer->data.sfstat[1] & 0x110)
+				|| (dma_buffer->data.sfstat[2] & 0x110)
+				|| (dma_buffer->data.sfstat[3] & 0x110)) {
+			pr_err("%s: ECC/MPU/OP error\n", __func__);
+			err = -EIO;
+		}
 
-	/* Use the already existing zero page */
-	buf =  page_address(ZERO_PAGE());
+		if (!(write_prot_status & ONENAND_WP_LS)) {
+			pr_err("%s: Unexpected status ofs = 0x%llx,"
+				"wp_status = %x\n",
+				__func__, ofs, write_prot_status);
+			err = -EIO;
+		}
 
-	ops.mode = MTD_OOB_RAW;
-	ops.len = mtd->writesize + mtd->oobsize;
-	ops.retlen = 0;
-	ops.ooblen = 0;
-	ops.datbuf = buf;
-	ops.oobbuf = NULL;
-	ret =  msm_nand_write_oob(mtd, ofs, &ops);
+		if (err)
+			break;
+	}
 
-	return ret;
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+
+#if VERBOSE
+	pr_info("\n%s: ret %d\n", __func__, err);
+	pr_info("===================================================="
+			"=============\n");
+#endif
+	return err;
 }
 
-/**
- * msm_nand_suspend - [MTD Interface] Suspend the msm_nand flash
- * @param mtd		MTD device structure
- */
-static int msm_nand_suspend(struct mtd_info *mtd)
+static int msm_onenand_suspend(struct mtd_info *mtd)
 {
 	return 0;
 }
 
-/**
- * msm_nand_resume - [MTD Interface] Resume the msm_nand flash
- * @param mtd		MTD device structure
- */
-static void msm_nand_resume(struct mtd_info *mtd)
+static void msm_onenand_resume(struct mtd_info *mtd)
 {
 }
 
-/**
- * Export 3 attributes for HTC SSD HW INFO tool
- * >info    :basic HW spec of this NAND chip
- * >vendor  :vendor information
- * >pagesize:page size, either 2048 or 4096
- */
-static int param_get_vendor_name(char *buffer, struct kernel_param *kp)
+int msm_onenand_scan(struct mtd_info *mtd, int maxchips)
 {
-	return sprintf(buffer, "%s", nand_info->maker_name);
-}
-module_param_call(vendor, NULL, param_get_vendor_name, NULL, S_IRUGO);
+	struct msm_nand_chip *chip = mtd->priv;
 
-static int param_get_nand_info(char *buffer, struct kernel_param *kp)
-{
-	int result = 0;
-	result += sprintf(buffer, "<<  NAND INFO  >>\n");
-	result += sprintf(buffer + result, "flash id\t =%X\n",
-				nand_info->flash_id);
-	result += sprintf(buffer + result, "vendor\t\t =%s\n",
-				nand_info->maker_name);
-	result += sprintf(buffer + result, "width\t\t =%d bits\n",
-				nand_info->width);
-	result += sprintf(buffer + result, "size\t\t =%d MB\n",
-				nand_info->size>>20);
-	result += sprintf(buffer + result, "block count\t =%d\n",
-				nand_info->block_count);
-	result += sprintf(buffer + result, "page count\t =%d",
-				nand_info->page_count);
-	return result;
-}
-module_param_call(info, NULL, param_get_nand_info, NULL, S_IRUGO);
+	/* Probe and check whether onenand device is present */
+	if (flash_onenand_probe(chip))
+		return -ENODEV;
 
-static int param_get_page_size(char *buffer, struct kernel_param *kp)
-{
-	return sprintf(buffer, "%d", nand_info->page_size);
+	mtd->size = 0x1000000 << ((onenand_info.device_id & 0xF0) >> 4);
+	mtd->writesize = onenand_info.data_buf_size;
+	mtd->oobsize = mtd->writesize >> 5;
+	mtd->erasesize = mtd->writesize << 6;
+	mtd->oobavail = msm_onenand_oob_64.oobavail;
+	mtd->ecclayout = &msm_onenand_oob_64;
+
+	mtd->type = MTD_NANDFLASH;
+	mtd->flags = MTD_CAP_NANDFLASH;
+	mtd->erase = msm_onenand_erase;
+	mtd->point = NULL;
+	mtd->unpoint = NULL;
+	mtd->read = msm_onenand_read;
+	mtd->write = msm_onenand_write;
+	mtd->read_oob = msm_onenand_read_oob;
+	mtd->write_oob = msm_onenand_write_oob;
+	mtd->lock = msm_onenand_lock;
+	mtd->unlock = msm_onenand_unlock;
+	mtd->suspend = msm_onenand_suspend;
+	mtd->resume = msm_onenand_resume;
+	mtd->block_isbad = msm_onenand_block_isbad;
+	mtd->block_markbad = msm_onenand_block_markbad;
+	mtd->owner = THIS_MODULE;
+
+	pr_info("Found a supported onenand device\n");
+
+	return 0;
 }
-module_param_call(pagesize, NULL, param_get_page_size, NULL, S_IRUGO);
 
 /**
  * msm_nand_scan - [msm_nand Interface] Scan for the msm_nand device
@@ -1461,162 +6678,187 @@ module_param_call(pagesize, NULL, param_get_page_size, NULL, S_IRUGO);
  */
 int msm_nand_scan(struct mtd_info *mtd, int maxchips)
 {
-	unsigned n;
 	struct msm_nand_chip *chip = mtd->priv;
-	uint32_t flash_id;
+	uint32_t flash_id = 0, i, mtd_writesize;
+	uint8_t dev_found = 0;
+	uint8_t wide_bus;
 	uint32_t manid;
 	uint32_t devid;
 	uint32_t devcfg;
-	uint32_t busw16;
 	struct nand_flash_dev *flashdev = NULL;
-	struct nand_manufacturers *flashman = NULL;
+	struct nand_manufacturers  *flashman = NULL;
 
-	if (flash_read_config(chip)) {
-		pr_err("ERRROR: could not save CFG0 & CFG1 state\n");
-		return -ENODEV;
-	}
-	pr_info("msm_nand: NAND_READ_ID = %x\n",
-		flash_rd_reg(chip, MSM_NAND_READ_ID));
-	flash_wr_reg(chip, MSM_NAND_READ_ID, 0x12345678);
-
-	flash_id = flash_read_id(chip);
-	manid = flash_id & 0xff;
-	devid = (flash_id >> 8) & 0xff;
-	devcfg = (flash_id >> 24) & 0xff;
-
-	for (n = 0;  !flashman && nand_manuf_ids[n].id; ++n)
-		if (nand_manuf_ids[n].id == manid)
-			flashman = &nand_manuf_ids[n];
-	for (n = 0; !flashdev && nand_flash_ids[n].id; ++n)
-		if (nand_flash_ids[n].id == devid)
-			flashdev = &nand_flash_ids[n];
-	if (!flashdev || !flashman) {
-		pr_err("ERROR: unknown nand device manuf=%x devid=%x\n",
-		       manid, devid);
-		return -ENOENT;
-	}
-
-	if (!flashdev->pagesize) {
-		mtd->erasesize = (64 * 1024) << ((devcfg >> 4) & 0x3);
-		mtd->writesize = 1024 << (devcfg & 0x3);
-		mtd->oobsize = (8 << ((devcfg >> 2) & 1)) *
-			(mtd->writesize / 512);
-		busw16 = devcfg & (1 << 6) ? CFG1_WIDE_FLASH : 0;
-	} else {
-		mtd->writesize = flashdev->pagesize;
-		mtd->erasesize = flashdev->erasesize;
-		mtd->oobsize = flashdev->pagesize / 32;
-		busw16 = flashdev->options & NAND_BUSWIDTH_16 ?
-			CFG1_WIDE_FLASH : 0;
-	}
-	mtd->size = flashdev->chipsize << 20;
-	pr_info("msm_nand: manuf %s (0x%x) device 0x%x blocksz %x pagesz %x "
-		"size %llx\n", flashman->name, flashman->id, flashdev->id,
-		mtd->erasesize, mtd->writesize, mtd->size);
-
-	if (mtd->writesize == 2048) {
-		chip->page_shift = 11;
-	} else if (mtd->writesize == 4096) {
-		chip->page_shift = 12;
+	/* Probe the Flash device for ONFI compliance */
+	if (!flash_onfi_probe(chip)) {
+		dev_found = 1;
 	} else {
-		pr_err("%s: Unsupported page size (%d)\n", __func__,
-		       mtd->writesize);
-		return -EINVAL;
+		/* Read the Flash ID from the Nand Flash Device */
+		flash_id = flash_read_id(chip);
+		manid = flash_id & 0xFF;
+		devid = (flash_id >> 8) & 0xFF;
+		devcfg = (flash_id >> 24) & 0xFF;
+
+		for (i = 0; !flashman && nand_manuf_ids[i].id; ++i)
+			if (nand_manuf_ids[i].id == manid)
+				flashman = &nand_manuf_ids[i];
+		for (i = 0; !flashdev && nand_flash_ids[i].id; ++i)
+			if (nand_flash_ids[i].id == devid)
+				flashdev = &nand_flash_ids[i];
+		if (!flashdev || !flashman) {
+			pr_err("ERROR: unknown nand device manuf=%x devid=%x\n",
+				manid, devid);
+			return -ENOENT;
+		} else
+			dev_found = 1;
+
+		if (!flashdev->pagesize) {
+			supported_flash.flash_id = flash_id;
+			supported_flash.density = flashdev->chipsize << 20;
+			supported_flash.widebus = devcfg & (1 << 6) ? 1 : 0;
+			supported_flash.pagesize = 1024 << (devcfg & 0x3);
+			supported_flash.blksize = (64 * 1024) <<
+							((devcfg >> 4) & 0x3);
+			supported_flash.oobsize = (8 << ((devcfg >> 2) & 0x3)) *
+				(supported_flash.pagesize >> 9);
+		} else {
+			supported_flash.flash_id = flash_id;
+			supported_flash.density = flashdev->chipsize << 20;
+			supported_flash.widebus = flashdev->options &
+					 NAND_BUSWIDTH_16 ? 1 : 0;
+			supported_flash.pagesize = flashdev->pagesize;
+			supported_flash.blksize = flashdev->erasesize;
+			supported_flash.oobsize = flashdev->pagesize >> 5;
+		}
 	}
 
-	chip->last_sector = (mtd->writesize / 512) - 1;
-	chip->last_sectorsz = mtd->writesize - chip->last_sector * 516;
+	if (dev_found) {
+		(!interleave_enable) ? (i = 1) : (i = 2);
+		wide_bus       = supported_flash.widebus;
+		mtd->size      = supported_flash.density  * i;
+		mtd->writesize = supported_flash.pagesize * i;
+		mtd->oobsize   = supported_flash.oobsize  * i;
+		mtd->erasesize = supported_flash.blksize  * i;
 
-	if (mtd->oobsize == 64) {
-		mtd->ecclayout = &msm_nand_oob_64;
-	} else if (mtd->oobsize == 128) {
-		mtd->ecclayout = &msm_nand_oob_128;
+		if (!interleave_enable)
+			mtd_writesize = mtd->writesize;
+		else
+			mtd_writesize = mtd->writesize >> 1;
+
+		/* Check whether controller and NAND device support 8bit ECC*/
+		if ((flash_rd_reg(chip, MSM_NAND_HW_INFO) == 0x307)
+				&& (supported_flash.ecc_correctability >= 8)) {
+			pr_info("Found supported NAND device for %dbit ECC\n",
+					supported_flash.ecc_correctability);
+			enable_bch_ecc = 1;
+		} else {
+			pr_info("Found a supported NAND device\n");
+		}
+		pr_info("NAND Id  : 0x%x\n", supported_flash.flash_id);
+		pr_info("Buswidth : %d Bits\n", (wide_bus) ? 16 : 8);
+		pr_info("Density  : %lld MByte\n", (mtd->size>>20));
+		pr_info("Pagesize : %d Bytes\n", mtd->writesize);
+		pr_info("Erasesize: %d Bytes\n", mtd->erasesize);
+		pr_info("Oobsize  : %d Bytes\n", mtd->oobsize);
 	} else {
-		pr_err("%s: Unsupported oob size (%d)\n", __func__,
-		       mtd->oobsize);
-		return -EINVAL;
+		pr_err("Unsupported Nand,Id: 0x%x \n", flash_id);
+		return -ENODEV;
 	}
-	mtd->oobavail = mtd->ecclayout->oobavail;
 
-	chip->CFG0 = (chip->last_sector << 6) /* codewords per page */
+	/* Size of each codeword is 532Bytes incase of 8bit BCH ECC*/
+	chip->cw_size = enable_bch_ecc ? 532 : 528;
+	chip->CFG0 = (((mtd_writesize >> 9)-1) << 6) /* 4/8 cw/pg for 2/4k */
 		|  (516 <<  9)  /* 516 user data bytes */
 		|   (10 << 19)  /* 10 parity bytes */
 		|    (5 << 27)  /* 5 address cycles */
-		|    (1 << 30)  /* Read status before data */
+		|    (0 << 30)  /* Do not read status before data */
 		|    (1 << 31)  /* Send read cmd */
-		/* 0 spare bytes for 16 bit nand or 1 spare bytes for 8 bit */
-		| ((busw16 & CFG1_WIDE_FLASH) ? (0 << 23) : (1 << 23));
+		/* 0 spare bytes for 16 bit nand or 1/2 spare bytes for 8 bit */
+		| (wide_bus ? 0 << 23 : (enable_bch_ecc ? 2 << 23 : 1 << 23));
+
 	chip->CFG1 = (0 <<  0)  /* Enable ecc */
 		|    (7 <<  2)  /* 8 recovery cycles */
 		|    (0 <<  5)  /* Allow CS deassertion */
-		|  ((mtd->writesize - (528 * chip->last_sector) + 1) <<  6)
-		                /* Bad block marker location */
+		/* Bad block marker location */
+		|  ((mtd_writesize - (chip->cw_size * (
+					(mtd_writesize >> 9) - 1)) + 1) <<  6)
 		|    (0 << 16)  /* Bad block in user data area */
 		|    (2 << 17)  /* 6 cycle tWB/tRB */
-		| (busw16 & CFG1_WIDE_FLASH); /* preserve wide flag */
+		| ((wide_bus) ? CFG1_WIDE_FLASH : 0); /* Wide flash bit */
 
-	pr_info("msm_nand: save CFG0 = %x CFG1 = %x\n", chip->CFG0, chip->CFG1);
-	pr_info("msm_nand: CFG0: cw/page=%d ud_sz=%d ecc_sz=%d spare_sz=%d "
-		"num_addr_cycles=%d\n", (chip->CFG0 >> 6) & 7,
-		(chip->CFG0 >> 9) & 0x3ff, (chip->CFG0 >> 19) & 15,
-		(chip->CFG0 >> 23) & 15, (chip->CFG0 >> 27) & 7);
+	chip->ecc_buf_cfg = 0x203;
+	chip->CFG0_RAW = 0xA80420C0;
+	chip->CFG1_RAW = 0x5045D;
+
+	if (enable_bch_ecc) {
+		chip->CFG1 |= (1 << 27); /* Enable BCH engine */
+		chip->ecc_bch_cfg = (0 << 0) /* Enable ECC*/
+			|   (0 << 1) /* Enable/Disable SW reset of ECC engine */
+			|   (1 << 4) /* 8bit ecc*/
+			|   ((wide_bus) ? (14 << 8) : (13 << 8))/*parity bytes*/
+			|   (516 << 16) /* 516 user data bytes */
+			|   (1 << 30); /* Turn on ECC engine clocks always */
+		chip->CFG0_RAW = 0xA80428C0; /* CW size is increased to 532B */
+	}
 
-	n = flash_rd_reg(chip, MSM_NAND_DEV_CMD1);
-	pr_info("msm_nand: DEV_CMD1: %x\n", n);
+	/*
+	 * For 4bit RS ECC (default ECC), parity bytes = 10 (for x8 and x16 I/O)
+	 * For 8bit BCH ECC, parity bytes = 13 (x8) or 14 (x16 I/O).
+	 */
+	chip->ecc_parity_bytes = enable_bch_ecc ? (wide_bus ? 14 : 13) : 10;
 
-	n = flash_rd_reg(chip, MSM_NAND_EBI2_ECC_BUF_CFG);
-	pr_info("msm_nand: NAND_EBI2_ECC_BUF_CFG: %x\n", n);
+	pr_info("CFG0 Init  : 0x%08x\n", chip->CFG0);
+	pr_info("CFG1 Init  : 0x%08x\n", chip->CFG1);
+	pr_info("ECCBUFCFG  : 0x%08x\n", chip->ecc_buf_cfg);
 
-#if SUPPORT_WRONG_ECC_CONFIG
-	chip->ecc_buf_cfg = 0x203;
-	chip->saved_ecc_buf_cfg = n;
-#endif
+	if (mtd->oobsize == 64) {
+		mtd->oobavail = msm_nand_oob_64.oobavail;
+		mtd->ecclayout = &msm_nand_oob_64;
+	} else if (mtd->oobsize == 128) {
+		mtd->oobavail = msm_nand_oob_128.oobavail;
+		mtd->ecclayout = &msm_nand_oob_128;
+	} else if (mtd->oobsize == 224) {
+		mtd->oobavail = wide_bus ? msm_nand_oob_224_x16.oobavail :
+			msm_nand_oob_224_x8.oobavail;
+		mtd->ecclayout = wide_bus ? &msm_nand_oob_224_x16 :
+			&msm_nand_oob_224_x8;
+	} else if (mtd->oobsize == 256) {
+		mtd->oobavail = msm_nand_oob_256.oobavail;
+		mtd->ecclayout = &msm_nand_oob_256;
+	} else {
+		pr_err("Unsupported Nand, oobsize: 0x%x \n",
+		       mtd->oobsize);
+		return -ENODEV;
+	}
 
 	/* Fill in remaining MTD driver data */
 	mtd->type = MTD_NANDFLASH;
 	mtd->flags = MTD_CAP_NANDFLASH;
 	/* mtd->ecctype = MTD_ECC_SW; */
 	mtd->erase = msm_nand_erase;
+	mtd->block_isbad = msm_nand_block_isbad;
+	mtd->block_markbad = msm_nand_block_markbad;
 	mtd->point = NULL;
 	mtd->unpoint = NULL;
 	mtd->read = msm_nand_read;
 	mtd->write = msm_nand_write;
-	mtd->read_oob = msm_nand_read_oob;
+	mtd->read_oob  = msm_nand_read_oob;
 	mtd->write_oob = msm_nand_write_oob;
+	if (dual_nand_ctlr_present) {
+		mtd->read_oob = msm_nand_read_oob_dualnandc;
+		mtd->write_oob = msm_nand_write_oob_dualnandc;
+		if (interleave_enable) {
+			mtd->erase = msm_nand_erase_dualnandc;
+			mtd->block_isbad = msm_nand_block_isbad_dualnandc;
+		}
+	}
+
 	/* mtd->sync = msm_nand_sync; */
 	mtd->lock = NULL;
 	/* mtd->unlock = msm_nand_unlock; */
 	mtd->suspend = msm_nand_suspend;
 	mtd->resume = msm_nand_resume;
-	mtd->block_isbad = msm_nand_block_isbad;
-	mtd->block_markbad = msm_nand_block_markbad;
 	mtd->owner = THIS_MODULE;
 
-	/* Information provides to HTC SSD HW Info tool */
-	nand_info = &chip->dev_info;
-	nand_info->flash_id = flash_id;
-	nand_info->maker_id = (flash_id & 0xff);
-	switch (nand_info->maker_id) {
-	case 0xec:
-		strcpy(nand_info->maker_name, "Samsung");
-		break;
-	case 0xad:
-		strcpy(nand_info->maker_name, "Hynix");
-		break;
-	case 0x2c:
-		strcpy(nand_info->maker_name, "Micron");
-		break;
-	default:
-		strcpy(nand_info->maker_name, "Unknown");
-		break;
-	}
-	nand_info->width = (CFG1_WIDE_FLASH? 16: 8);
-	nand_info->size = mtd->size;
-	nand_info->page_size = mtd->writesize;
-	nand_info->page_count = mtd->erasesize/mtd->writesize;
-	nand_info->block_count = mtd->size;
-	do_div(nand_info->block_count, nand_info->page_size * nand_info->page_count);
-
 	/* Unlock whole block */
 	/* msm_nand_unlock_all(mtd); */
 
@@ -1633,92 +6875,199 @@ void msm_nand_release(struct mtd_info *mtd)
 {
 	/* struct msm_nand_chip *this = mtd->priv; */
 
-#ifdef CONFIG_MTD_PARTITIONS
-	/* Deregister partitions */
-	del_mtd_partitions(mtd);
-#endif
 	/* Deregister the device */
-	del_mtd_device(mtd);
+	mtd_device_unregister(mtd);
 }
 EXPORT_SYMBOL_GPL(msm_nand_release);
 
-#ifdef CONFIG_MTD_PARTITIONS
-static const char *part_probes[] = { "cmdlinepart", NULL,  };
-#endif
-
 struct msm_nand_info {
 	struct mtd_info		mtd;
 	struct mtd_partition	*parts;
 	struct msm_nand_chip	msm_nand;
 };
 
+/* duplicating the NC01 XFR contents to NC10 */
+static int msm_nand_nc10_xfr_settings(struct mtd_info *mtd)
+{
+	struct msm_nand_chip *chip = mtd->priv;
+
+	struct {
+		dmov_s cmd[2];
+		unsigned cmdptr;
+	} *dma_buffer;
+	dmov_s *cmd;
+
+	wait_event(chip->wait_queue,
+		(dma_buffer = msm_nand_get_dma_buffer(
+				chip, sizeof(*dma_buffer))));
+
+	cmd = dma_buffer->cmd;
+
+	/* Copying XFR register contents from NC01 --> NC10 */
+	cmd->cmd = 0;
+	cmd->src = NC01(MSM_NAND_XFR_STEP1);
+	cmd->dst = NC10(MSM_NAND_XFR_STEP1);
+	cmd->len = 28;
+	cmd++;
+
+	BUILD_BUG_ON(2 != ARRAY_SIZE(dma_buffer->cmd));
+	BUG_ON(cmd - dma_buffer->cmd > ARRAY_SIZE(dma_buffer->cmd));
+	dma_buffer->cmd[0].cmd |= CMD_OCB;
+	cmd[-1].cmd |= CMD_OCU | CMD_LC;
+	dma_buffer->cmdptr = (msm_virt_to_dma(chip, dma_buffer->cmd) >> 3)
+				| CMD_PTR_LP;
+
+	mb();
+	msm_dmov_exec_cmd(chip->dma_channel, DMOV_CMD_PTR_LIST
+			| DMOV_CMD_ADDR(msm_virt_to_dma(chip,
+			&dma_buffer->cmdptr)));
+	mb();
+	msm_nand_release_dma_buffer(chip, dma_buffer, sizeof(*dma_buffer));
+	return 0;
+}
+
+static int setup_mtd_device(struct platform_device *pdev,
+			     struct msm_nand_info *info)
+{
+	int i, err;
+	struct flash_platform_data *pdata = pdev->dev.platform_data;
+
+	if (pdata) {
+		for (i = 0; i < pdata->nr_parts; i++) {
+			pdata->parts[i].offset = pdata->parts[i].offset
+				* info->mtd.erasesize;
+			pdata->parts[i].size = pdata->parts[i].size
+				* info->mtd.erasesize;
+		}
+		err = mtd_device_register(&info->mtd, pdata->parts,
+				pdata->nr_parts);
+	} else {
+		err = mtd_device_register(&info->mtd, NULL, 0);
+	}
+	return err;
+}
+
 static int __devinit msm_nand_probe(struct platform_device *pdev)
 {
 	struct msm_nand_info *info;
-	struct flash_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res;
 	int err;
-	int i;
+	struct flash_platform_data *plat_data;
+
+	plat_data = pdev->dev.platform_data;
 
-	if (pdev->num_resources != 1) {
-		pr_err("invalid num_resources");
+	res = platform_get_resource_byname(pdev,
+					IORESOURCE_MEM, "msm_nand_phys");
+	if (!res || !res->start) {
+		pr_err("%s: msm_nand_phys resource invalid/absent\n",
+				__func__);
 		return -ENODEV;
 	}
-	if (pdev->resource[0].flags != IORESOURCE_DMA) {
-		pr_err("invalid resource type");
+	msm_nand_phys = res->start;
+	pr_info("%s: phys addr 0x%lx \n", __func__, msm_nand_phys);
+
+	res = platform_get_resource_byname(pdev,
+					IORESOURCE_MEM, "msm_nandc01_phys");
+	if (!res || !res->start)
+		goto no_dual_nand_ctlr_support;
+	msm_nandc01_phys = res->start;
+
+	res = platform_get_resource_byname(pdev,
+					IORESOURCE_MEM, "msm_nandc10_phys");
+	if (!res || !res->start)
+		goto no_dual_nand_ctlr_support;
+	msm_nandc10_phys = res->start;
+
+	res = platform_get_resource_byname(pdev,
+					IORESOURCE_MEM, "msm_nandc11_phys");
+	if (!res || !res->start)
+		goto no_dual_nand_ctlr_support;
+	msm_nandc11_phys = res->start;
+
+	res = platform_get_resource_byname(pdev,
+					IORESOURCE_MEM, "ebi2_reg_base");
+	if (!res || !res->start)
+		goto no_dual_nand_ctlr_support;
+	ebi2_register_base = res->start;
+
+	dual_nand_ctlr_present = 1;
+	if (plat_data != NULL)
+		interleave_enable = plat_data->interleave;
+	else
+		interleave_enable = 0;
+
+	if (!interleave_enable)
+		pr_info("%s: Dual Nand Ctrl in ping-pong mode\n", __func__);
+	else
+		pr_info("%s: Dual Nand Ctrl in interleave mode\n", __func__);
+
+no_dual_nand_ctlr_support:
+	res = platform_get_resource_byname(pdev,
+					IORESOURCE_DMA, "msm_nand_dmac");
+	if (!res || !res->start) {
+		pr_err("%s: invalid msm_nand_dmac resource\n", __func__);
 		return -ENODEV;
 	}
 
 	info = kzalloc(sizeof(struct msm_nand_info), GFP_KERNEL);
-	if (!info)
+	if (!info) {
+		pr_err("%s: No memory for msm_nand_info\n", __func__);
 		return -ENOMEM;
+	}
 
 	info->msm_nand.dev = &pdev->dev;
 
 	init_waitqueue_head(&info->msm_nand.wait_queue);
 
-	info->msm_nand.dma_channel = pdev->resource[0].start;
+	info->msm_nand.dma_channel = res->start;
+	pr_info("%s: dmac 0x%x\n", __func__, info->msm_nand.dma_channel);
+
 	/* this currently fails if dev is passed in */
 	info->msm_nand.dma_buffer =
 		dma_alloc_coherent(/*dev*/ NULL, MSM_NAND_DMA_BUFFER_SIZE,
-				   &info->msm_nand.dma_addr, GFP_KERNEL);
+				&info->msm_nand.dma_addr, GFP_KERNEL);
 	if (info->msm_nand.dma_buffer == NULL) {
+		pr_err("%s: No memory for msm_nand.dma_buffer\n", __func__);
 		err = -ENOMEM;
 		goto out_free_info;
 	}
 
-	pr_info("msm_nand: allocated dma buffer at %p, dma_addr %x\n",
-		info->msm_nand.dma_buffer, info->msm_nand.dma_addr);
+	pr_info("%s: allocated dma buffer at %p, dma_addr %x\n",
+		__func__, info->msm_nand.dma_buffer, info->msm_nand.dma_addr);
 
 	info->mtd.name = dev_name(&pdev->dev);
 	info->mtd.priv = &info->msm_nand;
 	info->mtd.owner = THIS_MODULE;
 
-	if (msm_nand_scan(&info->mtd, 1)) {
-		err = -ENXIO;
-		goto out_free_dma_buffer;
-	}
+	/* config ebi2_cfg register only for ping pong mode!!! */
+	if (!interleave_enable && dual_nand_ctlr_present)
+		flash_wr_reg(&info->msm_nand, EBI2_CFG_REG, 0x4010080);
 
-#ifdef CONFIG_MTD_PARTITIONS
-	err = parse_mtd_partitions(&info->mtd, part_probes, &info->parts, 0);
-	if (err > 0)
-		add_mtd_partitions(&info->mtd, info->parts, err);
-	else if (err <= 0 && pdata && pdata->parts) {
-		for (i = 0; i < pdata->nr_parts; ++i) {
-			pdata->parts[i].offset *= info->mtd.erasesize;
-			pdata->parts[i].size *= info->mtd.erasesize;
+	if (dual_nand_ctlr_present)
+		msm_nand_nc10_xfr_settings(&info->mtd);
+
+	if (msm_nand_scan(&info->mtd, 1))
+		if (msm_onenand_scan(&info->mtd, 1)) {
+			pr_err("%s: No nand device found\n", __func__);
+			err = -ENXIO;
+			goto out_free_dma_buffer;
 		}
-		add_mtd_partitions(&info->mtd, pdata->parts, pdata->nr_parts);
-	} else
-#endif
-		err = add_mtd_device(&info->mtd);
+
+	err = setup_mtd_device(pdev, info);
+	if (err < 0) {
+		pr_err("%s: setup_mtd_device failed with err=%d\n",
+				__func__, err);
+		goto out_free_dma_buffer;
+	}
 
 	dev_set_drvdata(&pdev->dev, info);
 
 	return 0;
 
 out_free_dma_buffer:
-	dma_free_coherent(/*dev*/ NULL, SZ_4K, info->msm_nand.dma_buffer,
-			  info->msm_nand.dma_addr);
+	dma_free_coherent(NULL, MSM_NAND_DMA_BUFFER_SIZE,
+			info->msm_nand.dma_buffer,
+			info->msm_nand.dma_addr);
 out_free_info:
 	kfree(info);
 
@@ -1732,15 +7081,8 @@ static int __devexit msm_nand_remove(struct platform_device *pdev)
 	dev_set_drvdata(&pdev->dev, NULL);
 
 	if (info) {
-#ifdef CONFIG_MTD_PARTITIONS
-		if (info->parts)
-			del_mtd_partitions(&info->mtd);
-		else
-#endif
-			del_mtd_device(&info->mtd);
-
 		msm_nand_release(&info->mtd);
-		dma_free_coherent(/*dev*/ NULL, SZ_4K,
+		dma_free_coherent(NULL, MSM_NAND_DMA_BUFFER_SIZE,
 				  info->msm_nand.dma_buffer,
 				  info->msm_nand.dma_addr);
 		kfree(info);
diff --git a/drivers/mtd/devices/msm_nand.h b/drivers/mtd/devices/msm_nand.h
index 986b392..2729c6b 100644
--- a/drivers/mtd/devices/msm_nand.h
+++ b/drivers/mtd/devices/msm_nand.h
@@ -29,7 +29,7 @@ extern unsigned long ebi2_register_base;
 #define NC10(X) ((X) + msm_nandc10_phys - msm_nand_phys)
 #define NC11(X) ((X) + msm_nandc11_phys - msm_nand_phys)
 
-#define MSM_NAND_REG(off) (MSM_NAND_PHYS + (off))
+#define MSM_NAND_REG(off) (msm_nand_phys + (off))
 
 #define MSM_NAND_FLASH_CMD            MSM_NAND_REG(0x0000)
 #define MSM_NAND_ADDR0                MSM_NAND_REG(0x0004)
diff --git a/drivers/mtd/mtdcore.h b/drivers/mtd/mtdcore.h
index 23ec37c..0ed6126 100644
--- a/drivers/mtd/mtdcore.h
+++ b/drivers/mtd/mtdcore.h
@@ -11,6 +11,7 @@ extern struct mutex mtd_table_mutex;
 extern struct mtd_info *__mtd_next_device(int i);
 
 extern int add_mtd_device(struct mtd_info *mtd);
+extern int del_mtd_device(struct mtd_info *mtd);
 extern int add_mtd_partitions(struct mtd_info *, const struct mtd_partition *,
 			      int);
 extern int del_mtd_partitions(struct mtd_info *);
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 8f3a545..70ed0f0 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -82,17 +82,18 @@ config BATTERY_DS2782
 	  Say Y here to enable support for the DS2782/DS2786 standalone battery
 	  gas-gauge.
 
+config BATTERY_DS2784
+	tristate "DS2784 standalone gas-gauge"
+	depends on I2C
+	help
+	  Say Y here to enable support for the DS2784/DS2786 standalone battery
+	  gas-gauge.
+
 config BATTERY_DS2746
         tristate "DS2746 battery driver "
         help
           Say Y here to enable support for batteries with ds2746 chip.
 
-config BATTERY_DS2784
-  tristate "DS2784 battery driver "
-  select W1
-  help
-    Say Y here to enable support for batteries with ds2784 chip.
-
 config BATTERY_PMU
 	tristate "Apple PMU battery"
 	depends on PPC32 && ADB_PMU
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index a7bf247..b2fd39c 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -17,8 +17,8 @@ obj-$(CONFIG_TEST_POWER)	+= test_power.o
 obj-$(CONFIG_BATTERY_DS2760)	+= ds2760_battery.o
 obj-$(CONFIG_BATTERY_DS2780)	+= ds2780_battery.o
 obj-$(CONFIG_BATTERY_DS2782)	+= ds2782_battery.o
+obj-$(CONFIG_BATTERY_DS2784)	+= ds2784_battery.o
 obj-$(CONFIG_BATTERY_DS2746)    += ds2746_battery.o
-obj-$(CONFIG_BATTERY_DS2784)  += ds2784_battery.o
 obj-$(CONFIG_BATTERY_DS2746)    += ds2746_param.o
 obj-$(CONFIG_BATTERY_PMU)	+= pmu_battery.o
 obj-$(CONFIG_BATTERY_OLPC)	+= olpc_battery.o
diff --git a/drivers/power/w1_ds2784.h b/drivers/power/w1_ds2784.h
old mode 100644
new mode 100755
diff --git a/drivers/w1/w1_family.h b/drivers/w1/w1_family.h
index 706d297..3f6a1da 100644
--- a/drivers/w1/w1_family.h
+++ b/drivers/w1/w1_family.h
@@ -37,7 +37,6 @@
 #define W1_FAMILY_DS2408	0x29
 #define W1_EEPROM_DS2431	0x2D
 #define W1_FAMILY_DS2760	0x30
-#define W1_FAMILY_DS2780	0x32
 #define W1_FAMILY_DS2784	0x32
 
 #define MAXNAMELEN		32
diff --git a/include/linux/bma150.h b/include/linux/bma150.h
index e4b5613..0eee06b 100644
--- a/include/linux/bma150.h
+++ b/include/linux/bma150.h
@@ -1,33 +1,50 @@
-/* Copyright (c) 2009-2011, Code Aurora Forum. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
+/*
+ * Definitions for BMA150 G-sensor chip.
  */
-#ifndef LINUX_BMA150_MODULE_H
-#define LINUX_BMA150_MODULE_H
+#ifndef BMA150_H
+#define BMA150_H
+
+#include <linux/ioctl.h>
 
 #define BMA150_I2C_NAME "bma150"
-#ifdef CONFIG_SPI_QSD
 #define BMA150_G_SENSOR_NAME "bma150_uP_spi"
-#else
-#define BMA150_G_SENSOR_NAME "bma150"
-#endif
 
 #define BMAIO				0xA1
 
+/* BMA150 register address */
+#define CHIP_ID_REG			0x00
+#define VERSION_REG			0x01
+#define X_AXIS_LSB_REG		0x02
+#define X_AXIS_MSB_REG		0x03
+#define Y_AXIS_LSB_REG		0x04
+#define Y_AXIS_MSB_REG		0x05
+#define Z_AXIS_LSB_REG		0x06
+#define Z_AXIS_MSB_REG		0x07
+#define TEMP_RD_REG			0x08
 #define SMB150_STATUS_REG	0x09
 #define SMB150_CTRL_REG		0x0a
 #define SMB150_CONF1_REG	0x0b
+#define LG_THRESHOLD_REG	0x0c
+#define LG_DURATION_REG		0x0d
+#define HG_THRESHOLD_REG	0x0e
+#define HG_DURATION_REG		0x0f
+#define MOTION_THRS_REG		0x10
+#define HYSTERESIS_REG		0x11
+#define CUSTOMER1_REG		0x12
+#define CUSTOMER2_REG		0x13
 #define RANGE_BWIDTH_REG	0x14
 #define SMB150_CONF2_REG	0x15
 
+#define OFFS_GAIN_X_REG		0x16
+#define OFFS_GAIN_Y_REG		0x17
+#define OFFS_GAIN_Z_REG		0x18
+#define OFFS_GAIN_T_REG		0x19
+#define OFFSET_X_REG		0x1a
+#define OFFSET_Y_REG		0x1b
+#define OFFSET_Z_REG		0x1c
+#define OFFSET_T_REG		0x1d
+
+
 /* IOCTLs*/
 #define BMA_IOCTL_INIT                  _IO(BMAIO, 0x31)
 #define BMA_IOCTL_WRITE                 _IOW(BMAIO, 0x32, char[5])
@@ -36,24 +53,40 @@
 #define BMA_IOCTL_SET_MODE	  _IOW(BMAIO, 0x35, short)
 #define BMA_IOCTL_GET_INT	  _IOR(BMAIO, 0x36, short)
 #define BMA_IOCTL_GET_CHIP_LAYOUT	_IOR(BMAIO, 0x37, short)
+#define BMA_IOCTL_GET_CALI_MODE		_IOR(BMAIO, 0x38, short)
+#define BMA_IOCTL_SET_CALI_MODE		_IOW(BMAIO, 0x39, short)
+#define BMA_IOCTL_READ_CALI_VALUE       _IOR(BMAIO, 0x3a, char[3])
+#define BMA_IOCTL_WRITE_CALI_VALUE      _IOW(BMAIO, 0x3b, int)
+#define BMA_IOCTL_GET_UPDATE_USER_CALI_DATA	_IOR(BMAIO, 0x3c, short)
+#define BMA_IOCTL_SET_UPDATE_USER_CALI_DATA	_IOW(BMAIO, 0x3d, short)
+
+/* range and bandwidth */
+/*#define BMA_RANGE_2G			0
+#define BMA_RANGE_4G			1
+#define BMA_RANGE_8G			2*/
+
+#define BMA_BW_25HZ		0
+#define BMA_BW_50HZ		1
+#define BMA_BW_100HZ		2
+#define BMA_BW_190HZ		3
+#define BMA_BW_375HZ		4
+#define BMA_BW_750HZ		5
+#define BMA_BW_1500HZ	6
 
 /* mode settings */
 #define BMA_MODE_NORMAL   	0
 #define BMA_MODE_SLEEP       	1
 
-/**
- * struct bma150_platform_data - data to set up bma150 driver
- *
- * @setup: optional callback to activate the driver.
- * @teardown: optional callback to invalidate the driver.
- *
-**/
+extern unsigned int gs_kvalue;
 
 struct bma150_platform_data {
 	int (*setup)(struct device *);
 	void (*teardown)(struct device *);
-	int (*power_on)(void);
-	void (*power_off)(void);
+	int intr;
+	int microp_new_cmd;
+	int chip_layout;
+	int calibration_mode;
+	int gs_kvalue;
 };
 
-#endif /* LINUX_BMA150_MODULE_H */
+#endif
diff --git a/include/linux/ds2784_battery.h b/include/linux/ds2784_battery.h
index 7ca10f6..773aa16 100644
--- a/include/linux/ds2784_battery.h
+++ b/include/linux/ds2784_battery.h
@@ -13,17 +13,40 @@
  * GNU General Public License for more details.
  *
  */
+#ifndef _DS2784_BATTERY_H_
+#define _DS2784_BATTERY_H_
+#include <linux/notifier.h>
+#include <mach/htc_battery.h>
 
-#ifndef __LINUX_DS2784_BATTERY_H
-#define __LINUX_DS2784_BATTERY_H
+enum ds2784_notify_evt_t{
+	DS2784_CHARGING_CONTROL = 0,
+	DS2784_LEVEL_UPDATE,
+	DS2784_BATTERY_FAULT,
+	DS2784_OVER_TEMP,
+	DS2784_NUM_EVENTS,
+};
 
-#ifdef __KERNEL__
+#ifdef CONFIG_BATTERY_DS2784
+extern int ds2784_register_notifier(struct notifier_block *nb);
+extern int ds2784_unregister_notifier(struct notifier_block *nb);
+extern int ds2784_get_battery_info(struct battery_info_reply *batt_info);
+extern ssize_t htc_battery_show_attr(struct device_attribute *attr,
+			char *buf);
+#else
+static int ds2784_register_notifier(struct notifier_block *nb) { return 0; }
+static int ds2784_unregister_notifier(struct notifier_block *nb) { return 0; }
+static int ds2784_get_battery_info(struct battery_info_reply *batt_info)
+{
+	batt_info->level = 10;
+	return 0;
+}
+extern ssize_t htc_battery_show_attr(struct device_attribute *attr,
+			char *buf){ return 0; }
 
+#endif
 struct ds2784_platform_data {
 	int (*charge)(int on, int fast);
 	void *w1_slave;
 };
 
-#endif /* __KERNEL__ */
-
-#endif /* __LINUX_DS2784_BATTERY_H */
+#endif //endif _DS2784_BATTERY_H_
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
index a381cf1..2541fb8 100644
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -324,9 +324,6 @@ static inline uint32_t mtd_mod_by_ws(uint64_t sz, struct mtd_info *mtd)
 
 struct mtd_partition;
 
-extern int add_mtd_device(struct mtd_info *mtd);
-extern int del_mtd_device (struct mtd_info *mtd);
-
 extern int mtd_device_register(struct mtd_info *master,
 			       const struct mtd_partition *parts,
 			       int nr_parts);
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 4d3f63a..d0b5ccf 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -526,4 +526,5 @@ int __init mdio_bus_init(void);
 void mdio_bus_exit(void);
 
 extern struct bus_type mdio_bus_type;
+
 #endif /* __PHY_H */
diff --git a/include/linux/rfkill.h b/include/linux/rfkill.h
index e02e1a1..f7acc42 100644
--- a/include/linux/rfkill.h
+++ b/include/linux/rfkill.h
@@ -200,11 +200,8 @@ void rfkill_pause_polling(struct rfkill *rfkill);
  * NOTE: not necessary for suspend/resume -- in that case the
  * core stops polling anyway
  */
-#ifdef CONFIG_RFKILL_PM
 void rfkill_resume_polling(struct rfkill *rfkill);
-#else
-static inline void rfkill_resume_polling(struct rfkill *rfkill) { }
-#endif
+
 
 /**
  * rfkill_unregister - Unregister a rfkill structure.
diff --git a/include/linux/synaptics_i2c_rmi.h b/include/linux/synaptics_i2c_rmi.h
index 206ba75..a9a63d6 100644
--- a/include/linux/synaptics_i2c_rmi.h
+++ b/include/linux/synaptics_i2c_rmi.h
@@ -18,6 +18,36 @@
 #define _LINUX_SYNAPTICS_I2C_RMI_H
 
 #define SYNAPTICS_I2C_RMI_NAME "synaptics-rmi-ts"
+#define SYNAPTICS_T1007_NAME "synaptics-t1007"
+#define SYNAPTICS_T1021_NAME "synaptics-t1021"
+#define SYNAPTICS_3K_NAME "synaptics-3k"
+#define SYNAPTICS_3K_INCELL_NAME "synaptics-3k-incell"
+#define SYNAPTICS_3200_NAME "synaptics-3200"
+
+
+#define SYN_CONFIG_SIZE 32 * 16
+#define SYN_MAX_PAGE 3
+#define SYN_BL_PAGE 1
+#define SYN_F01DATA_BASEADDR 0x0013
+#define SYN_PROCESS_ERR -1
+
+#define SYN_AND_REPORT_TYPE_A		0
+#define	SYN_AND_REPORT_TYPE_B		1
+#define SYN_AND_REPORT_TYPE_HTC		2
+
+#define TAP_DX_OUTER		0
+#define TAP_DY_OUTER		1
+#define TAP_TIMEOUT		2
+#define TAP_DX_INTER		3
+#define TAP_DY_INTER		4
+
+#define CUS_REG_SIZE		4
+#define CUS_REG_BASE		0
+#define CUS_BALLISTICS_CTRL	1
+#define CUS_LAND_CTRL		2
+#define CUS_LIFT_CTRL		3
+
+#define SENSOR_ID_CHECKING_EN	1 << 16
 
 enum {
 	SYNAPTICS_FLIP_X = 1UL << 0,
@@ -26,11 +56,28 @@ enum {
 	SYNAPTICS_SNAP_TO_INACTIVE_EDGE = 1UL << 3,
 };
 
+enum {
+	FINGER_1_REPORT = 1 << 0,
+	FINGER_2_REPORT = 1 << 1,
+};
+
+struct synaptics_virtual_key {
+	int keycode;
+	int range_min;
+	int range_max;
+};
+
 struct synaptics_i2c_rmi_platform_data {
 	uint32_t version;	/* Use this entry for panels with */
 				/* (major << 8 | minor) version or above. */
 				/* If non-zero another array entry follows */
 	int (*power)(int on);	/* Only valid in first array entry */
+	struct synaptics_virtual_key *virtual_key;
+	uint8_t virtual_key_num;
+	uint8_t sensitivity;
+	uint8_t finger_support;
+	uint32_t gap_area;
+	uint32_t key_area;
 	uint32_t flags;
 	unsigned long irqflags;
 	uint32_t inactive_left; /* 0x10000 = screen width */
@@ -47,11 +94,63 @@ struct synaptics_i2c_rmi_platform_data {
 	uint32_t snap_bottom_off; /* 0x10000 = screen height */
 	uint32_t fuzz_x; /* 0x10000 = screen width */
 	uint32_t fuzz_y; /* 0x10000 = screen height */
+	int abs_x_min;
+	int abs_x_max;
+	int abs_y_min;
+	int abs_y_max;
 	int fuzz_p;
 	int fuzz_w;
+	uint32_t display_width;
+	uint32_t display_height;
 	int8_t sensitivity_adjust;
 	uint32_t dup_threshold;
 	uint32_t margin_inactive_pixel[4];
+	uint16_t filter_level[4];
+	uint8_t reduce_report_level[5];
+	uint8_t noise_information;
+	uint8_t jumpfq_enable;
+	uint8_t cable_support;
+	uint8_t config[SYN_CONFIG_SIZE];
+	int gpio_irq;
+	int gpio_reset;
+	uint8_t default_config;
+	uint8_t report_type;
+	uint8_t large_obj_check;
+	uint16_t tw_pin_mask;
+	uint32_t sensor_id;
+	uint32_t packrat_number;
+	uint8_t support_htc_event;
+	uint8_t mfg_flag;
+	uint8_t customer_register[CUS_REG_SIZE];
+};
+
+struct page_description {
+	uint8_t addr;
+	uint8_t value;
+};
+
+struct syn_finger_data {
+	int x;
+	int y;
+	int w;
+	int z;
+};
+
+struct function_t {
+	uint8_t function_type;
+	uint8_t interrupt_source;
+	uint16_t data_base;
+	uint16_t control_base;
+	uint16_t command_base;
+	uint16_t query_base;
+};
+enum {
+	QUERY_BASE,
+	COMMAND_BASE,
+	CONTROL_BASE,
+	DATA_BASE,
+	INTR_SOURCE,
+	FUNCTION
 };
 
 #endif /* _LINUX_SYNAPTICS_I2C_RMI_H */
diff --git a/include/linux/usb/msm_hsusb.h b/include/linux/usb/msm_hsusb.h
index 5845cb6..bb0e5ef 100644
--- a/include/linux/usb/msm_hsusb.h
+++ b/include/linux/usb/msm_hsusb.h
@@ -21,6 +21,8 @@
 #include <linux/types.h>
 #include <linux/usb/otg.h>
 #include <linux/wakelock.h>
+#include <mach/board.h>
+#include <mach/msm_xo.h>
 #include <linux/pm_qos_params.h>
 
 /**
@@ -132,25 +134,11 @@ enum usb_chg_type {
 };
 
 /**
- * SPS Pipes direction.
- *
- * USB_TO_PEER_PERIPHERAL	USB (as Producer) to other
- *                          peer peripheral.
- * PEER_PERIPHERAL_TO_USB	Other Peripheral to
- *                          USB (as consumer).
- */
-enum usb_bam_pipe_dir {
-	USB_TO_PEER_PERIPHERAL,
-	PEER_PERIPHERAL_TO_USB,
-};
-
-/**
  * struct msm_otg_platform_data - platform device data
  *              for msm_otg driver.
  * @phy_init_seq: PHY configuration sequence. val, reg pairs
  *              terminated by -1.
- * @vbus_power: VBUS power on/off routine.It should return result
- *		as success(zero value) or failure(non-zero value).
+ * @vbus_power: VBUS power on/off routine.
  * @power_budget: VBUS power budget in mA (0 will be treated as 500mA).
  * @mode: Supported mode (OTG/peripheral/host).
  * @otg_control: OTG switch controlled by user/Id pin
@@ -158,17 +146,17 @@ enum usb_bam_pipe_dir {
  *              OTG switch is controller by user.
  * @pmic_id_irq: IRQ number assigned for PMIC USB ID line.
  * @mhl_enable: indicates MHL connector or not.
- * @disable_reset_on_disconnect: perform USB PHY and LINK reset
- *              on USB cable disconnection.
+ * @ido_3v3_name: the regulator provide 3.075(3.3)V to PHY
+ * @ldo_1v8_name: the regulator provide 1.8V to PHY
+ * @vddcx_name: digital core voltage, provide reference voltage in charger
+ *		detection block in 28nm/45nm PHY
+ * @phy_notify_enabled: even in OTG_PMIC_CONTROL, still force enabled phy
+ *		interrupt and deliver the notification
  * @swfi_latency: miminum latency to allow swfi.
- * @enable_dcd: Enable Data Contact Detection circuit. if not set
- *              wait for 600msec before proceeding to primary
- *              detection.
- * @bus_scale_table: parameters for bus bandwidth requirements
  */
 struct msm_otg_platform_data {
 	int *phy_init_seq;
-	int (*vbus_power)(bool on);
+	void (*vbus_power)(bool on);
 	unsigned power_budget;
 	enum usb_mode_type mode;
 	enum otg_control_type otg_control;
@@ -177,52 +165,18 @@ struct msm_otg_platform_data {
 	void (*setup_gpio)(enum usb_otg_state state);
 	int pmic_id_irq;
 	bool mhl_enable;
-	bool disable_reset_on_disconnect;
+	char *ldo_3v3_name;
+	char *ldo_1v8_name;
+	char *vddcx_name;
 	u32 swfi_latency;
-	bool enable_dcd;
-	struct msm_bus_scale_pdata *bus_scale_table;
+	/* This flag is against the condition that PHY fail into lpm when DCP is attached. */
+	int reset_phy_before_lpm;
+	bool phy_notify_enabled;
+	void (*usb_uart_switch)(int uart);
+	int (*rpc_connect)(int connect);
+	int (*phy_reset)(void);
 };
 
-/* Timeout (in msec) values (min - max) associated with OTG timers */
-
-#define TA_WAIT_VRISE	100	/* ( - 100)  */
-#define TA_WAIT_VFALL	500	/* ( - 1000) */
-
-/*
- * This option is set for embedded hosts or OTG devices in which leakage
- * currents are very minimal.
- */
-#ifdef CONFIG_USB_OTG
-#define TA_WAIT_BCON	30000	/* (1100 - 30000) */
-#else
-#define TA_WAIT_BCON	-1
-#endif
-
-#define TA_AIDL_BDIS	500	/* (200 - ) */
-#define TA_BIDL_ADIS	155	/* (155 - 200) */
-#define TB_SRP_FAIL	6000	/* (5000 - 6000) */
-#define TB_ASE0_BRST	200	/* (155 - ) */
-
-/* TB_SSEND_SRP and TB_SE0_SRP are combined */
-#define TB_SRP_INIT	2000	/* (1500 - ) */
-
-#define TA_TST_MAINT	10100	/* (9900 - 10100) */
-#define TB_TST_SRP	3000	/* ( - 5000) */
-#define TB_TST_CONFIG	300
-
-/* Timeout variables */
-
-#define A_WAIT_VRISE	0
-#define A_WAIT_VFALL	1
-#define A_WAIT_BCON	2
-#define A_AIDL_BDIS	3
-#define A_BIDL_ADIS	4
-#define B_SRP_FAIL	5
-#define B_ASE0_BRST	6
-#define A_TST_MAINT	7
-#define B_TST_SRP	8
-#define B_TST_CONFIG	9
-
 /**
  * struct msm_otg: OTG driver data. Shared by HCD and DCD.
  * @otg: USB OTG Transceiver structure.
@@ -232,7 +186,7 @@ struct msm_otg_platform_data {
  * @pclk: clock struct of iface_clk.
  * @phy_reset_clk: clock struct of phy_clk.
  * @core_clk: clock struct of core_bus_clk.
- * @regs: ioremapped register base address.
+* @regs: ioremapped register base address.
  * @inputs: OTG state machine inputs(Id, SessValid etc).
  * @sm_work: OTG state machine work.
  * @in_lpm: indicates low power mode (LPM) state.
@@ -252,8 +206,6 @@ struct msm_otg_platform_data {
  * @pm_qos_req_dma: miminum DMA latency to vote against idle power
 	collapse when cable is connected.
  * @id_timer: The timer used for polling ID line to detect ACA states.
- * @xo_handle: TCXO buffer handle
- * @bus_perf_client: Bus performance client handle to request BUS bandwidth
  */
 struct msm_otg {
 	struct otg_transceiver otg;
@@ -269,18 +221,6 @@ struct msm_otg {
 #define ID_A		2
 #define ID_B		3
 #define ID_C		4
-#define A_BUS_DROP	5
-#define A_BUS_REQ	6
-#define A_SRP_DET	7
-#define A_VBUS_VLD	8
-#define B_CONN		9
-#define ADP_CHANGE	10
-#define POWER_UP	11
-#define A_CLR_ERR	12
-#define A_BUS_RESUME	13
-#define A_BUS_SUSPEND	14
-#define A_CONN		15
-#define B_BUS_REQ	16
 	unsigned long inputs;
 	struct work_struct sm_work;
 	atomic_t in_lpm;
@@ -290,13 +230,12 @@ struct msm_otg {
 	enum usb_chg_state chg_state;
 	enum usb_chg_type chg_type;
 	u8 dcd_retries;
-	struct wake_lock wlock;
+	struct wake_lock usb_otg_wlock;
+	struct wake_lock cable_detect_wlock;
 	struct notifier_block usbdev_nb;
 	unsigned mA_port;
 	struct timer_list id_timer;
 	unsigned long caps;
-	struct clk *xo_handle;
-	uint32_t bus_perf_client;
 	/*
 	 * Allowing PHY power collpase turns off the HSUSB 3.3v and 1.8v
 	 * analog regulators while going to low power mode.
@@ -319,12 +258,18 @@ struct msm_otg {
 #define PHY_PWR_COLLAPSED		BIT(0)
 #define PHY_RETENTIONED			BIT(1)
 #define PHY_OTG_COMP_DISABLED		BIT(2)
+	struct work_struct notifier_work;
+	enum usb_connect_type connect_type;
+	int connect_type_ready;
+	struct workqueue_struct *usb_wq;
+	struct timer_list ac_detect_timer;
+	int ac_detect_count;
+
+	struct msm_xo_voter *xo_handle; /*handle to vote for PXO buffer*/
 	struct pm_qos_request_list pm_qos_req_dma;
-	int reset_counter;
-	unsigned long b_last_se0_sess;
-	unsigned long tmouts;
-	u8 active_tmout;
-	struct hrtimer timer;
+	int reset_phy_before_lpm;
+
+	void (*vbus_notification_cb)(int online);
 };
 
 struct msm_hsic_host_platform_data {
@@ -333,30 +278,4 @@ struct msm_hsic_host_platform_data {
 	unsigned hub_reset;
 };
 
-struct msm_usb_host_platform_data {
-	unsigned int power_budget;
-	unsigned int dock_connect_irq;
-};
-
-struct usb_bam_pipe_connect {
-	u32 src_phy_addr;
-	int src_pipe_index;
-	u32 dst_phy_addr;
-	int dst_pipe_index;
-	u32 data_fifo_base_offset;
-	u32 data_fifo_size;
-	u32 desc_fifo_base_offset;
-	u32 desc_fifo_size;
-};
-
-struct msm_usb_bam_platform_data {
-	struct usb_bam_pipe_connect *connections;
-	int usb_active_bam;
-	int usb_bam_num_pipes;
-};
-
-enum usb_bam {
-	HSUSB_BAM = 0,
-	HSIC_BAM,
-};
 #endif
diff --git a/net/bluetooth/l2cap.c b/net/bluetooth/l2cap.c
deleted file mode 100644
index 7e462e2..0000000
--- a/net/bluetooth/l2cap.c
+++ /dev/null
@@ -1,4990 +0,0 @@
-/*
-   BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
-   Copyright (C) 2009-2010 Gustavo F. Padovan <gustavo@padovan.org>
-   Copyright (C) 2010 Google Inc.
-
-   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License version 2 as
-   published by the Free Software Foundation;
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
-   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
-   SOFTWARE IS DISCLAIMED.
-*/
-
-/* Bluetooth L2CAP core and sockets. */
-
-#include <linux/module.h>
-
-#include <linux/types.h>
-#include <linux/capability.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/poll.h>
-#include <linux/fcntl.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/socket.h>
-#include <linux/skbuff.h>
-#include <linux/list.h>
-#include <linux/device.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/uaccess.h>
-#include <linux/crc16.h>
-#include <net/sock.h>
-
-#include <asm/system.h>
-#include <asm/unaligned.h>
-
-#include <net/bluetooth/bluetooth.h>
-#include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/l2cap.h>
-
-#define VERSION "2.15"
-
-static int disable_ertm;
-
-static u32 l2cap_feat_mask = L2CAP_FEAT_FIXED_CHAN;
-static u8 l2cap_fixed_chan[8] = { 0x02, };
-
-static const struct proto_ops l2cap_sock_ops;
-
-static struct workqueue_struct *_busy_wq;
-
-static struct bt_sock_list l2cap_sk_list = {
-	.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)
-};
-
-static void l2cap_busy_work(struct work_struct *work);
-
-static void __l2cap_sock_close(struct sock *sk, int reason);
-static void l2cap_sock_close(struct sock *sk);
-static void l2cap_sock_kill(struct sock *sk);
-
-static int l2cap_build_conf_req(struct sock *sk, void *data);
-static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
-				u8 code, u8 ident, u16 dlen, void *data);
-
-static int l2cap_ertm_data_rcv(struct sock *sk, struct sk_buff *skb);
-
-/* ---- L2CAP timers ---- */
-static void l2cap_sock_set_timer(struct sock *sk, long timeout)
-{
-	BT_DBG("sk %p state %d timeout %ld", sk, sk->sk_state, timeout);
-	sk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);
-}
-
-static void l2cap_sock_clear_timer(struct sock *sk)
-{
-	BT_DBG("sock %p state %d", sk, sk->sk_state);
-	sk_stop_timer(sk, &sk->sk_timer);
-}
-
-static void l2cap_sock_timeout(unsigned long arg)
-{
-	struct sock *sk = (struct sock *) arg;
-	int reason;
-
-	BT_DBG("sock %p state %d", sk, sk->sk_state);
-
-	bh_lock_sock(sk);
-
-	if (sock_owned_by_user(sk)) {
-		/* sk is owned by user. Try again later */
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		sock_put(sk);
-		return;
-	}
-
-	if (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)
-		reason = ECONNREFUSED;
-	else if (sk->sk_state == BT_CONNECT &&
-				l2cap_pi(sk)->sec_level != BT_SECURITY_SDP)
-		reason = ECONNREFUSED;
-	else
-		reason = ETIMEDOUT;
-
-	__l2cap_sock_close(sk, reason);
-
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	sock_put(sk);
-}
-
-/* ---- L2CAP channels ---- */
-static struct sock *__l2cap_get_chan_by_dcid(struct l2cap_chan_list *l, u16 cid)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->dcid == cid)
-			break;
-	}
-	return s;
-}
-
-static struct sock *__l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->scid == cid)
-			break;
-	}
-	return s;
-}
-
-/* Find channel with given SCID.
- * Returns locked socket */
-static inline struct sock *l2cap_get_chan_by_scid(struct l2cap_chan_list *l, u16 cid)
-{
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_scid(l, cid);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
-}
-
-static struct sock *__l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
-{
-	struct sock *s;
-	for (s = l->head; s; s = l2cap_pi(s)->next_c) {
-		if (l2cap_pi(s)->ident == ident)
-			break;
-	}
-	return s;
-}
-
-static inline struct sock *l2cap_get_chan_by_ident(struct l2cap_chan_list *l, u8 ident)
-{
-	struct sock *s;
-	read_lock(&l->lock);
-	s = __l2cap_get_chan_by_ident(l, ident);
-	if (s)
-		bh_lock_sock(s);
-	read_unlock(&l->lock);
-	return s;
-}
-
-static u16 l2cap_alloc_cid(struct l2cap_chan_list *l)
-{
-	u16 cid = L2CAP_CID_DYN_START;
-
-	for (; cid < L2CAP_CID_DYN_END; cid++) {
-		if (!__l2cap_get_chan_by_scid(l, cid))
-			return cid;
-	}
-
-	return 0;
-}
-
-static inline void __l2cap_chan_link(struct l2cap_chan_list *l, struct sock *sk)
-{
-	sock_hold(sk);
-
-	if (l->head)
-		l2cap_pi(l->head)->prev_c = sk;
-
-	l2cap_pi(sk)->next_c = l->head;
-	l2cap_pi(sk)->prev_c = NULL;
-	l->head = sk;
-}
-
-static inline void l2cap_chan_unlink(struct l2cap_chan_list *l, struct sock *sk)
-{
-	struct sock *next = l2cap_pi(sk)->next_c, *prev = l2cap_pi(sk)->prev_c;
-
-	write_lock_bh(&l->lock);
-	if (sk == l->head)
-		l->head = next;
-
-	if (next)
-		l2cap_pi(next)->prev_c = prev;
-	if (prev)
-		l2cap_pi(prev)->next_c = next;
-	write_unlock_bh(&l->lock);
-
-	__sock_put(sk);
-}
-
-static void __l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk, struct sock *parent)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-
-	BT_DBG("conn %p, psm 0x%2.2x, dcid 0x%4.4x", conn,
-			l2cap_pi(sk)->psm, l2cap_pi(sk)->dcid);
-
-	conn->disc_reason = 0x13;
-
-	l2cap_pi(sk)->conn = conn;
-
-	if (sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM) {
-		/* Alloc CID for connection-oriented socket */
-		l2cap_pi(sk)->scid = l2cap_alloc_cid(l);
-	} else if (sk->sk_type == SOCK_DGRAM) {
-		/* Connectionless socket */
-		l2cap_pi(sk)->scid = L2CAP_CID_CONN_LESS;
-		l2cap_pi(sk)->dcid = L2CAP_CID_CONN_LESS;
-		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
-	} else {
-		/* Raw socket can send/recv signalling messages only */
-		l2cap_pi(sk)->scid = L2CAP_CID_SIGNALING;
-		l2cap_pi(sk)->dcid = L2CAP_CID_SIGNALING;
-		l2cap_pi(sk)->omtu = L2CAP_DEFAULT_MTU;
-	}
-
-	__l2cap_chan_link(l, sk);
-
-	if (parent)
-		bt_accept_enqueue(parent, sk);
-}
-
-/* Delete channel.
- * Must be called on the locked socket. */
-static void l2cap_chan_del(struct sock *sk, int err)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sock *parent = bt_sk(sk)->parent;
-
-	l2cap_sock_clear_timer(sk);
-
-	BT_DBG("sk %p, conn %p, err %d", sk, conn, err);
-
-	if (conn) {
-		/* Unlink from channel list */
-		l2cap_chan_unlink(&conn->chan_list, sk);
-		l2cap_pi(sk)->conn = NULL;
-		hci_conn_put(conn->hcon);
-	}
-
-	sk->sk_state = BT_CLOSED;
-	sock_set_flag(sk, SOCK_ZAPPED);
-
-	if (err)
-		sk->sk_err = err;
-
-	if (parent) {
-		bt_accept_unlink(sk);
-		parent->sk_data_ready(parent, 0);
-	} else
-		sk->sk_state_change(sk);
-
-	skb_queue_purge(TX_QUEUE(sk));
-
-	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-		struct srej_list *l, *tmp;
-
-		del_timer(&l2cap_pi(sk)->retrans_timer);
-		del_timer(&l2cap_pi(sk)->monitor_timer);
-		del_timer(&l2cap_pi(sk)->ack_timer);
-
-		skb_queue_purge(SREJ_QUEUE(sk));
-		skb_queue_purge(BUSY_QUEUE(sk));
-
-		list_for_each_entry_safe(l, tmp, SREJ_LIST(sk), list) {
-			list_del(&l->list);
-			kfree(l);
-		}
-	}
-}
-
-static inline u8 l2cap_get_auth_type(struct sock *sk)
-{
-	if (sk->sk_type == SOCK_RAW) {
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_HIGH:
-			return HCI_AT_DEDICATED_BONDING_MITM;
-		case BT_SECURITY_MEDIUM:
-			return HCI_AT_DEDICATED_BONDING;
-		default:
-			return HCI_AT_NO_BONDING;
-		}
-	} else if (l2cap_pi(sk)->psm == cpu_to_le16(0x0001)) {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_LOW)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
-
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)
-			return HCI_AT_NO_BONDING_MITM;
-		else
-			return HCI_AT_NO_BONDING;
-	} else {
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_HIGH:
-			return HCI_AT_GENERAL_BONDING_MITM;
-		case BT_SECURITY_MEDIUM:
-			return HCI_AT_GENERAL_BONDING;
-		default:
-			return HCI_AT_NO_BONDING;
-		}
-	}
-}
-
-/* Service level security */
-static inline int l2cap_check_security(struct sock *sk)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	__u8 auth_type;
-
-	auth_type = l2cap_get_auth_type(sk);
-
-	return hci_conn_security(conn->hcon, l2cap_pi(sk)->sec_level,
-								auth_type);
-}
-
-static inline u8 l2cap_get_ident(struct l2cap_conn *conn)
-{
-	u8 id;
-
-	/* Get next available identificator.
-	 *    1 - 128 are used by kernel.
-	 *  129 - 199 are reserved.
-	 *  200 - 254 are used by utilities like l2ping, etc.
-	 */
-
-	spin_lock_bh(&conn->lock);
-
-	if (++conn->tx_ident > 128)
-		conn->tx_ident = 1;
-
-	id = conn->tx_ident;
-
-	spin_unlock_bh(&conn->lock);
-
-	return id;
-}
-
-static inline void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
-{
-	struct sk_buff *skb = l2cap_build_cmd(conn, code, ident, len, data);
-	u8 flags;
-
-	BT_DBG("code 0x%2.2x", code);
-
-	if (!skb)
-		return;
-
-	if (lmp_no_flush_capable(conn->hcon->hdev))
-		flags = ACL_START_NO_FLUSH;
-	else
-		flags = ACL_START;
-
-	bt_cb(skb)->force_active = 1;
-
-	hci_send_acl(conn->hcon, skb, flags);
-}
-
-static inline void l2cap_send_sframe(struct l2cap_pinfo *pi, u16 control)
-{
-	struct sk_buff *skb;
-	struct l2cap_hdr *lh;
-	struct l2cap_conn *conn = pi->conn;
-	struct sock *sk = (struct sock *)pi;
-	int count, hlen = L2CAP_HDR_SIZE + 2;
-
-	if (sk->sk_state != BT_CONNECTED)
-		return;
-
-	if (pi->fcs == L2CAP_FCS_CRC16)
-		hlen += 2;
-
-	BT_DBG("pi %p, control 0x%2.2x", pi, control);
-
-	count = min_t(unsigned int, conn->mtu, hlen);
-	control |= L2CAP_CTRL_FRAME_TYPE;
-
-	if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-		control |= L2CAP_CTRL_FINAL;
-		pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-	}
-
-	if (pi->conn_state & L2CAP_CONN_SEND_PBIT) {
-		control |= L2CAP_CTRL_POLL;
-		pi->conn_state &= ~L2CAP_CONN_SEND_PBIT;
-	}
-
-	skb = bt_skb_alloc(count, GFP_ATOMIC);
-	if (!skb)
-		return;
-
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(hlen - L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(pi->dcid);
-	put_unaligned_le16(control, skb_put(skb, 2));
-
-	if (pi->fcs == L2CAP_FCS_CRC16) {
-		u16 fcs = crc16(0, (u8 *)lh, count - 2);
-		put_unaligned_le16(fcs, skb_put(skb, 2));
-	}
-
-	bt_cb(skb)->force_active = l2cap_pi(sk)->force_active;
-
-	hci_send_acl(pi->conn->hcon, skb, 0);
-}
-
-static inline void l2cap_send_rr_or_rnr(struct l2cap_pinfo *pi, u16 control)
-{
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-		control |= L2CAP_SUPER_RCV_NOT_READY;
-		pi->conn_state |= L2CAP_CONN_RNR_SENT;
-	} else
-		control |= L2CAP_SUPER_RCV_READY;
-
-	control |= pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-
-	l2cap_send_sframe(pi, control);
-}
-
-static inline int __l2cap_no_conn_pending(struct sock *sk)
-{
-	return !(l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND);
-}
-
-static void l2cap_do_start(struct sock *sk)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) {
-		if (!(conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE))
-			return;
-
-		if (l2cap_check_security(sk) && __l2cap_no_conn_pending(sk)) {
-			struct l2cap_conn_req req;
-			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-			req.psm  = l2cap_pi(sk)->psm;
-
-			l2cap_pi(sk)->ident = l2cap_get_ident(conn);
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_REQ, sizeof(req), &req);
-		}
-	} else {
-		struct l2cap_info_req req;
-		req.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
-		conn->info_ident = l2cap_get_ident(conn);
-
-		mod_timer(&conn->info_timer, jiffies +
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
-
-		l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(req), &req);
-	}
-}
-
-static inline int l2cap_mode_supported(__u8 mode, __u32 feat_mask)
-{
-	u32 local_feat_mask = l2cap_feat_mask;
-	if (!disable_ertm)
-		local_feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING;
-
-	switch (mode) {
-	case L2CAP_MODE_ERTM:
-		return L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;
-	case L2CAP_MODE_STREAMING:
-		return L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;
-	default:
-		return 0x00;
-	}
-}
-
-static void l2cap_send_disconn_req(struct l2cap_conn *conn, struct sock *sk, int err)
-{
-	struct l2cap_disconn_req req;
-
-	if (!conn)
-		return;
-
-	skb_queue_purge(TX_QUEUE(sk));
-
-	if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM) {
-		del_timer(&l2cap_pi(sk)->retrans_timer);
-		del_timer(&l2cap_pi(sk)->monitor_timer);
-		del_timer(&l2cap_pi(sk)->ack_timer);
-	}
-
-	req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-	l2cap_send_cmd(conn, l2cap_get_ident(conn),
-			L2CAP_DISCONN_REQ, sizeof(req), &req);
-
-	sk->sk_state = BT_DISCONN;
-	sk->sk_err = err;
-}
-
-/* ---- L2CAP connections ---- */
-static void l2cap_conn_start(struct l2cap_conn *conn)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock_del_list del, *tmp1, *tmp2;
-	struct sock *sk;
-
-	BT_DBG("conn %p", conn);
-
-	INIT_LIST_HEAD(&del.list);
-
-	read_lock(&l->lock);
-
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
-
-		if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-			bh_unlock_sock(sk);
-			continue;
-		}
-
-		if (sk->sk_state == BT_CONNECT) {
-			struct l2cap_conn_req req;
-
-			if (!l2cap_check_security(sk) ||
-					!__l2cap_no_conn_pending(sk)) {
-				bh_unlock_sock(sk);
-				continue;
-			}
-
-			if (!l2cap_mode_supported(l2cap_pi(sk)->mode,
-					conn->feat_mask)
-					&& l2cap_pi(sk)->conf_state &
-					L2CAP_CONF_STATE2_DEVICE) {
-				tmp1 = kzalloc(sizeof(struct sock_del_list),
-						GFP_ATOMIC);
-				tmp1->sk = sk;
-				list_add_tail(&tmp1->list, &del.list);
-				bh_unlock_sock(sk);
-				continue;
-			}
-
-			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-			req.psm  = l2cap_pi(sk)->psm;
-
-			l2cap_pi(sk)->ident = l2cap_get_ident(conn);
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-				L2CAP_CONN_REQ, sizeof(req), &req);
-
-		} else if (sk->sk_state == BT_CONNECT2) {
-			struct l2cap_conn_rsp rsp;
-			char buf[128];
-			rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
-
-			if (l2cap_check_security(sk)) {
-				if (bt_sk(sk)->defer_setup) {
-					struct sock *parent = bt_sk(sk)->parent;
-					rsp.result = cpu_to_le16(L2CAP_CR_PEND);
-					rsp.status = cpu_to_le16(L2CAP_CS_AUTHOR_PEND);
-					if (parent)
-						parent->sk_data_ready(parent, 0);
-
-				} else {
-					sk->sk_state = BT_CONFIG;
-					rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-					rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-				}
-			} else {
-				rsp.result = cpu_to_le16(L2CAP_CR_PEND);
-				rsp.status = cpu_to_le16(L2CAP_CS_AUTHEN_PEND);
-			}
-
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-			if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT ||
-					rsp.result != L2CAP_CR_SUCCESS) {
-				bh_unlock_sock(sk);
-				continue;
-			}
-
-			l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-						l2cap_build_conf_req(sk, buf), buf);
-			l2cap_pi(sk)->num_conf_req++;
-		}
-
-		bh_unlock_sock(sk);
-	}
-
-	read_unlock(&l->lock);
-
-	list_for_each_entry_safe(tmp1, tmp2, &del.list, list) {
-		bh_lock_sock(tmp1->sk);
-		__l2cap_sock_close(tmp1->sk, ECONNRESET);
-		bh_unlock_sock(tmp1->sk);
-		list_del(&tmp1->list);
-		kfree(tmp1);
-	}
-}
-
-static void l2cap_conn_ready(struct l2cap_conn *conn)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock *sk;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
-
-		if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-			l2cap_sock_clear_timer(sk);
-			sk->sk_state = BT_CONNECTED;
-			sk->sk_state_change(sk);
-		} else if (sk->sk_state == BT_CONNECT)
-			l2cap_do_start(sk);
-
-		bh_unlock_sock(sk);
-	}
-
-	read_unlock(&l->lock);
-}
-
-/* Notify sockets that we cannot guaranty reliability anymore */
-static void l2cap_conn_unreliable(struct l2cap_conn *conn, int err)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sock *sk;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (l2cap_pi(sk)->force_reliable)
-			sk->sk_err = err;
-	}
-
-	read_unlock(&l->lock);
-}
-
-static void l2cap_info_timeout(unsigned long arg)
-{
-	struct l2cap_conn *conn = (void *) arg;
-
-	conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-	conn->info_ident = 0;
-
-	l2cap_conn_start(conn);
-}
-
-static struct l2cap_conn *l2cap_conn_add(struct hci_conn *hcon, u8 status)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-
-	if (conn || status)
-		return conn;
-
-	conn = kzalloc(sizeof(struct l2cap_conn), GFP_ATOMIC);
-	if (!conn)
-		return NULL;
-
-	hcon->l2cap_data = conn;
-	conn->hcon = hcon;
-
-	BT_DBG("hcon %p conn %p", hcon, conn);
-
-	conn->mtu = hcon->hdev->acl_mtu;
-	conn->src = &hcon->hdev->bdaddr;
-	conn->dst = &hcon->dst;
-
-	conn->feat_mask = 0;
-
-	spin_lock_init(&conn->lock);
-	rwlock_init(&conn->chan_list.lock);
-
-	setup_timer(&conn->info_timer, l2cap_info_timeout,
-						(unsigned long) conn);
-
-	conn->disc_reason = 0x13;
-
-	return conn;
-}
-
-static void l2cap_conn_del(struct hci_conn *hcon, int err)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
-
-	if (!conn)
-		return;
-
-	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
-
-	kfree_skb(conn->rx_skb);
-
-	/* Kill channels */
-	while ((sk = conn->chan_list.head)) {
-		bh_lock_sock(sk);
-		l2cap_chan_del(sk, err);
-		bh_unlock_sock(sk);
-		l2cap_sock_kill(sk);
-	}
-
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
-		del_timer_sync(&conn->info_timer);
-
-	hcon->l2cap_data = NULL;
-	kfree(conn);
-}
-
-static inline void l2cap_chan_add(struct l2cap_conn *conn, struct sock *sk, struct sock *parent)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	write_lock_bh(&l->lock);
-	__l2cap_chan_add(conn, sk, parent);
-	write_unlock_bh(&l->lock);
-}
-
-/* ---- Socket interface ---- */
-static struct sock *__l2cap_get_sock_by_addr(__le16 psm, bdaddr_t *src)
-{
-	struct sock *sk;
-	struct hlist_node *node;
-	sk_for_each(sk, node, &l2cap_sk_list.head)
-		if (l2cap_pi(sk)->sport == psm && !bacmp(&bt_sk(sk)->src, src))
-			goto found;
-	sk = NULL;
-found:
-	return sk;
-}
-
-/* Find socket with psm and source bdaddr.
- * Returns closest match.
- */
-static struct sock *l2cap_get_sock_by_psm(int state, __le16 psm, bdaddr_t *src)
-{
-	struct sock *sk = NULL, *sk1 = NULL;
-	struct hlist_node *node;
-
-	read_lock(&l2cap_sk_list.lock);
-
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (state && sk->sk_state != state)
-			continue;
-
-		if (l2cap_pi(sk)->psm == psm) {
-			/* Exact match. */
-			if (!bacmp(&bt_sk(sk)->src, src))
-				break;
-
-			/* Closest match */
-			if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))
-				sk1 = sk;
-		}
-	}
-
-	read_unlock(&l2cap_sk_list.lock);
-
-	return node ? sk : sk1;
-}
-
-static void l2cap_sock_destruct(struct sock *sk)
-{
-	BT_DBG("sk %p", sk);
-
-	skb_queue_purge(&sk->sk_receive_queue);
-	skb_queue_purge(&sk->sk_write_queue);
-}
-
-static void l2cap_sock_cleanup_listen(struct sock *parent)
-{
-	struct sock *sk;
-
-	BT_DBG("parent %p", parent);
-
-	/* Close not yet accepted channels */
-	while ((sk = bt_accept_dequeue(parent, NULL)))
-		l2cap_sock_close(sk);
-
-	parent->sk_state = BT_CLOSED;
-	sock_set_flag(parent, SOCK_ZAPPED);
-}
-
-/* Kill socket (only if zapped and orphan)
- * Must be called on unlocked socket.
- */
-static void l2cap_sock_kill(struct sock *sk)
-{
-	if (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)
-		return;
-
-	BT_DBG("sk %p state %d", sk, sk->sk_state);
-
-	/* Kill poor orphan */
-	bt_sock_unlink(&l2cap_sk_list, sk);
-	sock_set_flag(sk, SOCK_DEAD);
-	sock_put(sk);
-}
-
-static void __l2cap_sock_close(struct sock *sk, int reason)
-{
-	BT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);
-
-	switch (sk->sk_state) {
-	case BT_LISTEN:
-		l2cap_sock_cleanup_listen(sk);
-		break;
-
-	case BT_CONNECTED:
-	case BT_CONFIG:
-		if (sk->sk_type == SOCK_SEQPACKET ||
-				sk->sk_type == SOCK_STREAM) {
-			struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-
-			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-			l2cap_send_disconn_req(conn, sk, reason);
-		} else
-			l2cap_chan_del(sk, reason);
-		break;
-
-	case BT_CONNECT2:
-		if (sk->sk_type == SOCK_SEQPACKET ||
-				sk->sk_type == SOCK_STREAM) {
-			struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-			struct l2cap_conn_rsp rsp;
-			__u16 result;
-
-			if (bt_sk(sk)->defer_setup)
-				result = L2CAP_CR_SEC_BLOCK;
-			else
-				result = L2CAP_CR_BAD_PSM;
-			sk->sk_state = BT_DISCONN;
-
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-		} else
-			l2cap_chan_del(sk, reason);
-		break;
-
-	case BT_CONNECT:
-	case BT_DISCONN:
-		l2cap_chan_del(sk, reason);
-		break;
-
-	default:
-		sock_set_flag(sk, SOCK_ZAPPED);
-		break;
-	}
-}
-
-/* Must be called on unlocked socket. */
-static void l2cap_sock_close(struct sock *sk)
-{
-	l2cap_sock_clear_timer(sk);
-	lock_sock(sk);
-	__l2cap_sock_close(sk, ECONNRESET);
-	release_sock(sk);
-	l2cap_sock_kill(sk);
-}
-
-static void l2cap_sock_init(struct sock *sk, struct sock *parent)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-	BT_DBG("sk %p", sk);
-
-	if (parent) {
-		sk->sk_type = parent->sk_type;
-		bt_sk(sk)->defer_setup = bt_sk(parent)->defer_setup;
-
-		pi->imtu = l2cap_pi(parent)->imtu;
-		pi->omtu = l2cap_pi(parent)->omtu;
-		pi->conf_state = l2cap_pi(parent)->conf_state;
-		pi->mode = l2cap_pi(parent)->mode;
-		pi->fcs  = l2cap_pi(parent)->fcs;
-		pi->max_tx = l2cap_pi(parent)->max_tx;
-		pi->tx_win = l2cap_pi(parent)->tx_win;
-		pi->sec_level = l2cap_pi(parent)->sec_level;
-		pi->role_switch = l2cap_pi(parent)->role_switch;
-		pi->force_reliable = l2cap_pi(parent)->force_reliable;
-		pi->flushable = l2cap_pi(parent)->flushable;
-		pi->force_active = l2cap_pi(parent)->force_active;
-	} else {
-		pi->imtu = L2CAP_DEFAULT_MTU;
-		pi->omtu = 0;
-		if (!disable_ertm && sk->sk_type == SOCK_STREAM) {
-			pi->mode = L2CAP_MODE_ERTM;
-			pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
-		} else {
-			pi->mode = L2CAP_MODE_BASIC;
-		}
-		pi->max_tx = L2CAP_DEFAULT_MAX_TX;
-		pi->fcs  = L2CAP_FCS_CRC16;
-		pi->tx_win = L2CAP_DEFAULT_TX_WINDOW;
-		pi->sec_level = BT_SECURITY_LOW;
-		pi->role_switch = 0;
-		pi->force_reliable = 0;
-		pi->flushable = 0;
-		pi->force_active = 1;
-	}
-
-	/* Default config options */
-	pi->conf_len = 0;
-	pi->flush_to = L2CAP_DEFAULT_FLUSH_TO;
-	skb_queue_head_init(TX_QUEUE(sk));
-	skb_queue_head_init(SREJ_QUEUE(sk));
-	skb_queue_head_init(BUSY_QUEUE(sk));
-	INIT_LIST_HEAD(SREJ_LIST(sk));
-}
-
-static struct proto l2cap_proto = {
-	.name		= "L2CAP",
-	.owner		= THIS_MODULE,
-	.obj_size	= sizeof(struct l2cap_pinfo)
-};
-
-static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
-{
-	struct sock *sk;
-
-	sk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto);
-	if (!sk)
-		return NULL;
-
-	sock_init_data(sock, sk);
-	INIT_LIST_HEAD(&bt_sk(sk)->accept_q);
-
-	sk->sk_destruct = l2cap_sock_destruct;
-	sk->sk_sndtimeo = msecs_to_jiffies(L2CAP_CONN_TIMEOUT);
-
-	sock_reset_flag(sk, SOCK_ZAPPED);
-
-	sk->sk_protocol = proto;
-	sk->sk_state = BT_OPEN;
-
-	setup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);
-
-	bt_sock_link(&l2cap_sk_list, sk);
-	return sk;
-}
-
-static int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,
-			     int kern)
-{
-	struct sock *sk;
-
-	BT_DBG("sock %p", sock);
-
-	sock->state = SS_UNCONNECTED;
-
-	if (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&
-			sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)
-		return -ESOCKTNOSUPPORT;
-
-	if (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))
-		return -EPERM;
-
-	sock->ops = &l2cap_sock_ops;
-
-	sk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC);
-	if (!sk)
-		return -ENOMEM;
-
-	l2cap_sock_init(sk, NULL);
-	return 0;
-}
-
-static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
-{
-	struct sock *sk = sock->sk;
-	struct sockaddr_l2 la;
-	int len, err = 0;
-
-	BT_DBG("sk %p", sk);
-
-	if (!addr || addr->sa_family != AF_BLUETOOTH)
-		return -EINVAL;
-
-	memset(&la, 0, sizeof(la));
-	len = min_t(unsigned int, sizeof(la), alen);
-	memcpy(&la, addr, len);
-
-	if (la.l2_cid)
-		return -EINVAL;
-
-	lock_sock(sk);
-
-	if (sk->sk_state != BT_OPEN) {
-		err = -EBADFD;
-		goto done;
-	}
-
-	if (la.l2_psm) {
-		__u16 psm = __le16_to_cpu(la.l2_psm);
-
-		/* PSM must be odd and lsb of upper byte must be 0 */
-		if ((psm & 0x0101) != 0x0001) {
-			err = -EINVAL;
-			goto done;
-		}
-
-		/* Restrict usage of well-known PSMs */
-		if (psm < 0x1001 && !capable(CAP_NET_BIND_SERVICE)) {
-			err = -EACCES;
-			goto done;
-		}
-	}
-
-	write_lock_bh(&l2cap_sk_list.lock);
-
-	if (la.l2_psm && __l2cap_get_sock_by_addr(la.l2_psm, &la.l2_bdaddr)) {
-		err = -EADDRINUSE;
-	} else {
-		/* Save source address */
-		bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
-		l2cap_pi(sk)->psm   = la.l2_psm;
-		l2cap_pi(sk)->sport = la.l2_psm;
-		sk->sk_state = BT_BOUND;
-
-		if (__le16_to_cpu(la.l2_psm) == 0x0001 ||
-					__le16_to_cpu(la.l2_psm) == 0x0003)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_SDP;
-	}
-
-	write_unlock_bh(&l2cap_sk_list.lock);
-
-done:
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_do_connect(struct sock *sk)
-{
-	bdaddr_t *src = &bt_sk(sk)->src;
-	bdaddr_t *dst = &bt_sk(sk)->dst;
-	struct l2cap_conn *conn;
-	struct hci_conn *hcon;
-	struct hci_dev *hdev;
-	__u8 auth_type;
-	int err;
-
-	BT_DBG("%s -> %s psm 0x%2.2x", batostr(src), batostr(dst),
-							l2cap_pi(sk)->psm);
-
-	hdev = hci_get_route(dst, src);
-	if (!hdev)
-		return -EHOSTUNREACH;
-
-	hci_dev_lock_bh(hdev);
-
-	err = -ENOMEM;
-
-	auth_type = l2cap_get_auth_type(sk);
-
-	hcon = hci_connect(hdev, ACL_LINK, 0, dst,
-					l2cap_pi(sk)->sec_level, auth_type);
-	if (!hcon)
-		goto done;
-
-	conn = l2cap_conn_add(hcon, 0);
-	if (!conn) {
-		hci_conn_put(hcon);
-		goto done;
-	}
-
-	err = 0;
-
-	/* Update source addr of the socket */
-	bacpy(src, conn->src);
-
-	l2cap_chan_add(conn, sk, NULL);
-
-	sk->sk_state = BT_CONNECT;
-	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-
-	if (hcon->state == BT_CONNECTED) {
-		if (sk->sk_type != SOCK_SEQPACKET &&
-				sk->sk_type != SOCK_STREAM) {
-			l2cap_sock_clear_timer(sk);
-			if (l2cap_check_security(sk))
-				sk->sk_state = BT_CONNECTED;
-		} else
-			l2cap_do_start(sk);
-	}
-
-done:
-	hci_dev_unlock_bh(hdev);
-	hci_dev_put(hdev);
-	return err;
-}
-
-static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)
-{
-	struct sock *sk = sock->sk;
-	struct sockaddr_l2 la;
-	int len, err = 0;
-
-	BT_DBG("sk %p", sk);
-
-	if (!addr || alen < sizeof(addr->sa_family) ||
-	    addr->sa_family != AF_BLUETOOTH)
-		return -EINVAL;
-
-	memset(&la, 0, sizeof(la));
-	len = min_t(unsigned int, sizeof(la), alen);
-	memcpy(&la, addr, len);
-
-	if (la.l2_cid)
-		return -EINVAL;
-
-	lock_sock(sk);
-
-	if ((sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)
-			&& !la.l2_psm) {
-		err = -EINVAL;
-		goto done;
-	}
-
-	switch (l2cap_pi(sk)->mode) {
-	case L2CAP_MODE_BASIC:
-		break;
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		if (!disable_ertm)
-			break;
-		/* fall through */
-	default:
-		err = -ENOTSUPP;
-		goto done;
-	}
-
-	switch (sk->sk_state) {
-	case BT_CONNECT:
-	case BT_CONNECT2:
-	case BT_CONFIG:
-		/* Already connecting */
-		goto wait;
-
-	case BT_CONNECTED:
-		/* Already connected */
-		err = -EISCONN;
-		goto done;
-
-	case BT_OPEN:
-	case BT_BOUND:
-		/* Can connect */
-		break;
-
-	default:
-		err = -EBADFD;
-		goto done;
-	}
-
-	/* PSM must be odd and lsb of upper byte must be 0 */
-	if ((__le16_to_cpu(la.l2_psm) & 0x0101) != 0x0001 &&
-		sk->sk_type != SOCK_RAW) {
-		err = -EINVAL;
-		goto done;
-	}
-
-	/* Set destination address and psm */
-	bacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);
-	l2cap_pi(sk)->psm = la.l2_psm;
-
-	err = l2cap_do_connect(sk);
-	if (err)
-		goto done;
-
-wait:
-	err = bt_sock_wait_state(sk, BT_CONNECTED,
-			sock_sndtimeo(sk, flags & O_NONBLOCK));
-done:
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_listen(struct socket *sock, int backlog)
-{
-	struct sock *sk = sock->sk;
-	int err = 0;
-
-	BT_DBG("sk %p backlog %d", sk, backlog);
-
-	lock_sock(sk);
-
-	if ((sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM)
-			|| sk->sk_state != BT_BOUND) {
-		err = -EBADFD;
-		goto done;
-	}
-
-	switch (l2cap_pi(sk)->mode) {
-	case L2CAP_MODE_BASIC:
-		break;
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		if (!disable_ertm)
-			break;
-		/* fall through */
-	default:
-		err = -ENOTSUPP;
-		goto done;
-	}
-
-	if (!l2cap_pi(sk)->psm) {
-		bdaddr_t *src = &bt_sk(sk)->src;
-		u16 psm;
-
-		err = -EINVAL;
-
-		write_lock_bh(&l2cap_sk_list.lock);
-
-		for (psm = 0x1001; psm < 0x1100; psm += 2)
-			if (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {
-				l2cap_pi(sk)->psm   = cpu_to_le16(psm);
-				l2cap_pi(sk)->sport = cpu_to_le16(psm);
-				err = 0;
-				break;
-			}
-
-		write_unlock_bh(&l2cap_sk_list.lock);
-
-		if (err < 0)
-			goto done;
-	}
-
-	sk->sk_max_ack_backlog = backlog;
-	sk->sk_ack_backlog = 0;
-	sk->sk_state = BT_LISTEN;
-
-done:
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_accept(struct socket *sock, struct socket *newsock, int flags)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	struct sock *sk = sock->sk, *nsk;
-	long timeo;
-	int err = 0;
-
-	lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
-
-	if (sk->sk_state != BT_LISTEN) {
-		err = -EBADFD;
-		goto done;
-	}
-
-	timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
-
-	BT_DBG("sk %p timeo %ld", sk, timeo);
-
-	/* Wait for an incoming connection. (wake-one). */
-	add_wait_queue_exclusive(sk_sleep(sk), &wait);
-	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (!timeo) {
-			err = -EAGAIN;
-			break;
-		}
-
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
-
-		if (sk->sk_state != BT_LISTEN) {
-			err = -EBADFD;
-			break;
-		}
-
-		if (signal_pending(current)) {
-			err = sock_intr_errno(timeo);
-			break;
-		}
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(sk_sleep(sk), &wait);
-
-	if (err)
-		goto done;
-
-	newsock->state = SS_CONNECTED;
-
-	BT_DBG("new socket %p", nsk);
-
-done:
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
-{
-	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
-	struct sock *sk = sock->sk;
-
-	BT_DBG("sock %p, sk %p", sock, sk);
-
-	addr->sa_family = AF_BLUETOOTH;
-	*len = sizeof(struct sockaddr_l2);
-
-	if (peer) {
-		la->l2_psm = l2cap_pi(sk)->psm;
-		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
-		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	} else {
-		la->l2_psm = l2cap_pi(sk)->sport;
-		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
-		la->l2_cid = cpu_to_le16(l2cap_pi(sk)->scid);
-	}
-
-	return 0;
-}
-
-static int __l2cap_wait_ack(struct sock *sk)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	int err = 0;
-	int timeo = HZ/5;
-
-	add_wait_queue(sk_sleep(sk), &wait);
-	while ((l2cap_pi(sk)->unacked_frames > 0 && l2cap_pi(sk)->conn)) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (!timeo)
-			timeo = HZ/5;
-
-		if (signal_pending(current)) {
-			err = sock_intr_errno(timeo);
-			break;
-		}
-
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
-
-		err = sock_error(sk);
-		if (err)
-			break;
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(sk_sleep(sk), &wait);
-	return err;
-}
-
-static void l2cap_monitor_timeout(unsigned long arg)
-{
-	struct sock *sk = (void *) arg;
-
-	BT_DBG("sk %p", sk);
-
-	bh_lock_sock(sk);
-	if (l2cap_pi(sk)->retry_count >= l2cap_pi(sk)->remote_max_tx) {
-		l2cap_send_disconn_req(l2cap_pi(sk)->conn, sk, ECONNABORTED);
-		bh_unlock_sock(sk);
-		return;
-	}
-
-	l2cap_pi(sk)->retry_count++;
-	__mod_monitor_timer();
-
-	l2cap_send_rr_or_rnr(l2cap_pi(sk), L2CAP_CTRL_POLL);
-	bh_unlock_sock(sk);
-}
-
-static void l2cap_retrans_timeout(unsigned long arg)
-{
-	struct sock *sk = (void *) arg;
-
-	BT_DBG("sk %p", sk);
-
-	bh_lock_sock(sk);
-	l2cap_pi(sk)->retry_count = 1;
-	__mod_monitor_timer();
-
-	l2cap_pi(sk)->conn_state |= L2CAP_CONN_WAIT_F;
-
-	l2cap_send_rr_or_rnr(l2cap_pi(sk), L2CAP_CTRL_POLL);
-	bh_unlock_sock(sk);
-}
-
-static void l2cap_drop_acked_frames(struct sock *sk)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_peek(TX_QUEUE(sk))) &&
-			l2cap_pi(sk)->unacked_frames) {
-		if (bt_cb(skb)->tx_seq == l2cap_pi(sk)->expected_ack_seq)
-			break;
-
-		skb = skb_dequeue(TX_QUEUE(sk));
-		kfree_skb(skb);
-
-		l2cap_pi(sk)->unacked_frames--;
-	}
-
-	if (!l2cap_pi(sk)->unacked_frames)
-		del_timer(&l2cap_pi(sk)->retrans_timer);
-}
-
-static inline void l2cap_do_send(struct sock *sk, struct sk_buff *skb)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct hci_conn *hcon = pi->conn->hcon;
-	u16 flags;
-
-	BT_DBG("sk %p, skb %p len %d", sk, skb, skb->len);
-
-	if (lmp_no_flush_capable(hcon->hdev) && !l2cap_pi(sk)->flushable)
-		flags = ACL_START_NO_FLUSH;
-	else
-		flags = ACL_START;
-
-	bt_cb(skb)->force_active = pi->force_active;
-	hci_send_acl(hcon, skb, flags);
-}
-
-static void l2cap_streaming_send(struct sock *sk)
-{
-	struct sk_buff *skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u16 control, fcs;
-
-	while ((skb = skb_dequeue(TX_QUEUE(sk)))) {
-		control = get_unaligned_le16(skb->data + L2CAP_HDR_SIZE);
-		control |= pi->next_tx_seq << L2CAP_CTRL_TXSEQ_SHIFT;
-		put_unaligned_le16(control, skb->data + L2CAP_HDR_SIZE);
-
-		if (pi->fcs == L2CAP_FCS_CRC16) {
-			fcs = crc16(0, (u8 *)skb->data, skb->len - 2);
-			put_unaligned_le16(fcs, skb->data + skb->len - 2);
-		}
-
-		l2cap_do_send(sk, skb);
-
-		pi->next_tx_seq = (pi->next_tx_seq + 1) % 64;
-	}
-}
-
-static void l2cap_retransmit_one_frame(struct sock *sk, u8 tx_seq)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *skb, *tx_skb;
-	u16 control, fcs;
-
-	skb = skb_peek(TX_QUEUE(sk));
-	if (!skb)
-		return;
-
-	do {
-		if (bt_cb(skb)->tx_seq == tx_seq)
-			break;
-
-		if (skb_queue_is_last(TX_QUEUE(sk), skb))
-			return;
-
-	} while ((skb = skb_queue_next(TX_QUEUE(sk), skb)));
-
-	if (pi->remote_max_tx &&
-			bt_cb(skb)->retries == pi->remote_max_tx) {
-		l2cap_send_disconn_req(pi->conn, sk, ECONNABORTED);
-		return;
-	}
-
-	tx_skb = skb_clone(skb, GFP_ATOMIC);
-	bt_cb(skb)->retries++;
-	control = get_unaligned_le16(tx_skb->data + L2CAP_HDR_SIZE);
-
-	if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-		control |= L2CAP_CTRL_FINAL;
-		pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-	}
-
-	control |= (pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT)
-			| (tx_seq << L2CAP_CTRL_TXSEQ_SHIFT);
-
-	put_unaligned_le16(control, tx_skb->data + L2CAP_HDR_SIZE);
-
-	if (pi->fcs == L2CAP_FCS_CRC16) {
-		fcs = crc16(0, (u8 *)tx_skb->data, tx_skb->len - 2);
-		put_unaligned_le16(fcs, tx_skb->data + tx_skb->len - 2);
-	}
-
-	l2cap_do_send(sk, tx_skb);
-}
-
-static int l2cap_ertm_send(struct sock *sk)
-{
-	struct sk_buff *skb, *tx_skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u16 control, fcs;
-	int nsent = 0;
-
-	if (sk->sk_state != BT_CONNECTED)
-		return -ENOTCONN;
-
-	while ((skb = sk->sk_send_head) && (!l2cap_tx_window_full(sk))) {
-
-		if (pi->remote_max_tx &&
-				bt_cb(skb)->retries == pi->remote_max_tx) {
-			l2cap_send_disconn_req(pi->conn, sk, ECONNABORTED);
-			break;
-		}
-
-		tx_skb = skb_clone(skb, GFP_ATOMIC);
-
-		bt_cb(skb)->retries++;
-
-		control = get_unaligned_le16(tx_skb->data + L2CAP_HDR_SIZE);
-		control &= L2CAP_CTRL_SAR;
-
-		if (pi->conn_state & L2CAP_CONN_SEND_FBIT) {
-			control |= L2CAP_CTRL_FINAL;
-			pi->conn_state &= ~L2CAP_CONN_SEND_FBIT;
-		}
-		control |= (pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT)
-				| (pi->next_tx_seq << L2CAP_CTRL_TXSEQ_SHIFT);
-		put_unaligned_le16(control, tx_skb->data + L2CAP_HDR_SIZE);
-
-
-		if (pi->fcs == L2CAP_FCS_CRC16) {
-			fcs = crc16(0, (u8 *)skb->data, tx_skb->len - 2);
-			put_unaligned_le16(fcs, skb->data + tx_skb->len - 2);
-		}
-
-		l2cap_do_send(sk, tx_skb);
-
-		__mod_retrans_timer();
-
-		bt_cb(skb)->tx_seq = pi->next_tx_seq;
-		pi->next_tx_seq = (pi->next_tx_seq + 1) % 64;
-
-		pi->unacked_frames++;
-		pi->frames_sent++;
-
-		if (skb_queue_is_last(TX_QUEUE(sk), skb))
-			sk->sk_send_head = NULL;
-		else
-			sk->sk_send_head = skb_queue_next(TX_QUEUE(sk), skb);
-
-		nsent++;
-	}
-
-	return nsent;
-}
-
-static int l2cap_retransmit_frames(struct sock *sk)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int ret;
-
-	if (!skb_queue_empty(TX_QUEUE(sk)))
-		sk->sk_send_head = TX_QUEUE(sk)->next;
-
-	pi->next_tx_seq = pi->expected_ack_seq;
-	ret = l2cap_ertm_send(sk);
-	return ret;
-}
-
-static void l2cap_send_ack(struct l2cap_pinfo *pi)
-{
-	struct sock *sk = (struct sock *)pi;
-	u16 control = 0;
-
-	control |= pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-		control |= L2CAP_SUPER_RCV_NOT_READY;
-		pi->conn_state |= L2CAP_CONN_RNR_SENT;
-		l2cap_send_sframe(pi, control);
-		return;
-	}
-
-	if (l2cap_ertm_send(sk) > 0)
-		return;
-
-	control |= L2CAP_SUPER_RCV_READY;
-	l2cap_send_sframe(pi, control);
-}
-
-static void l2cap_send_srejtail(struct sock *sk)
-{
-	struct srej_list *tail;
-	u16 control;
-
-	control = L2CAP_SUPER_SELECT_REJECT;
-	control |= L2CAP_CTRL_FINAL;
-
-	tail = list_entry(SREJ_LIST(sk)->prev, struct srej_list, list);
-	control |= tail->tx_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-
-	l2cap_send_sframe(l2cap_pi(sk), control);
-}
-
-static inline int l2cap_skbuff_fromiovec(struct sock *sk, struct msghdr *msg, int len, int count, struct sk_buff *skb)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sk_buff **frag;
-	int err, sent = 0;
-
-	if (memcpy_fromiovec(skb_put(skb, count), msg->msg_iov, count))
-		return -EFAULT;
-
-	sent += count;
-	len  -= count;
-
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		count = min_t(unsigned int, conn->mtu, len);
-
-		*frag = bt_skb_send_alloc(sk, count, msg->msg_flags & MSG_DONTWAIT, &err);
-		if (!*frag)
-			return err;
-		if (memcpy_fromiovec(skb_put(*frag, count), msg->msg_iov, count))
-			return -EFAULT;
-
-		sent += count;
-		len  -= count;
-
-		frag = &(*frag)->next;
-	}
-
-	return sent;
-}
-
-static struct sk_buff *l2cap_create_connless_pdu(struct sock *sk, struct msghdr *msg, size_t len)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sk_buff *skb;
-	int err, count, hlen = L2CAP_HDR_SIZE + 2;
-	struct l2cap_hdr *lh;
-
-	BT_DBG("sk %p len %d", sk, (int)len);
-
-	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
-	if (!skb)
-		return ERR_PTR(err);
-
-	/* Create L2CAP header */
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
-	put_unaligned_le16(l2cap_pi(sk)->psm, skb_put(skb, 2));
-
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);
-	if (unlikely(err < 0)) {
-		kfree_skb(skb);
-		return ERR_PTR(err);
-	}
-	return skb;
-}
-
-static struct sk_buff *l2cap_create_basic_pdu(struct sock *sk, struct msghdr *msg, size_t len)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sk_buff *skb;
-	int err, count, hlen = L2CAP_HDR_SIZE;
-	struct l2cap_hdr *lh;
-
-	BT_DBG("sk %p len %d", sk, (int)len);
-
-	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
-	if (!skb)
-		return ERR_PTR(err);
-
-	/* Create L2CAP header */
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
-
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);
-	if (unlikely(err < 0)) {
-		kfree_skb(skb);
-		return ERR_PTR(err);
-	}
-	return skb;
-}
-
-static struct sk_buff *l2cap_create_iframe_pdu(struct sock *sk, struct msghdr *msg, size_t len, u16 control, u16 sdulen)
-{
-	struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-	struct sk_buff *skb;
-	int err, count, hlen = L2CAP_HDR_SIZE + 2;
-	struct l2cap_hdr *lh;
-
-	BT_DBG("sk %p len %d", sk, (int)len);
-
-	if (!conn)
-		return ERR_PTR(-ENOTCONN);
-
-	if (sdulen)
-		hlen += 2;
-
-	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16)
-		hlen += 2;
-
-	count = min_t(unsigned int, (conn->mtu - hlen), len);
-	skb = bt_skb_send_alloc(sk, count + hlen,
-			msg->msg_flags & MSG_DONTWAIT, &err);
-	if (!skb)
-		return ERR_PTR(err);
-
-	/* Create L2CAP header */
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
-	put_unaligned_le16(control, skb_put(skb, 2));
-	if (sdulen)
-		put_unaligned_le16(sdulen, skb_put(skb, 2));
-
-	err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);
-	if (unlikely(err < 0)) {
-		kfree_skb(skb);
-		return ERR_PTR(err);
-	}
-
-	if (l2cap_pi(sk)->fcs == L2CAP_FCS_CRC16)
-		put_unaligned_le16(0, skb_put(skb, 2));
-
-	bt_cb(skb)->retries = 0;
-	return skb;
-}
-
-static inline int l2cap_sar_segment_sdu(struct sock *sk, struct msghdr *msg, size_t len)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *skb;
-	struct sk_buff_head sar_queue;
-	u16 control;
-	size_t size = 0;
-
-	skb_queue_head_init(&sar_queue);
-	control = L2CAP_SDU_START;
-	skb = l2cap_create_iframe_pdu(sk, msg, pi->remote_mps, control, len);
-	if (IS_ERR(skb))
-		return PTR_ERR(skb);
-
-	__skb_queue_tail(&sar_queue, skb);
-	len -= pi->remote_mps;
-	size += pi->remote_mps;
-
-	while (len > 0) {
-		size_t buflen;
-
-		if (len > pi->remote_mps) {
-			control = L2CAP_SDU_CONTINUE;
-			buflen = pi->remote_mps;
-		} else {
-			control = L2CAP_SDU_END;
-			buflen = len;
-		}
-
-		skb = l2cap_create_iframe_pdu(sk, msg, buflen, control, 0);
-		if (IS_ERR(skb)) {
-			skb_queue_purge(&sar_queue);
-			return PTR_ERR(skb);
-		}
-
-		__skb_queue_tail(&sar_queue, skb);
-		len -= buflen;
-		size += buflen;
-	}
-	skb_queue_splice_tail(&sar_queue, TX_QUEUE(sk));
-	if (sk->sk_send_head == NULL)
-		sk->sk_send_head = sar_queue.next;
-
-	return size;
-}
-
-static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)
-{
-	struct sock *sk = sock->sk;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *skb;
-	u16 control;
-	int err;
-
-	BT_DBG("sock %p, sk %p", sock, sk);
-
-	err = sock_error(sk);
-	if (err)
-		return err;
-
-	if (msg->msg_flags & MSG_OOB)
-		return -EOPNOTSUPP;
-
-	lock_sock(sk);
-
-	if (sk->sk_state != BT_CONNECTED) {
-		err = -ENOTCONN;
-		goto done;
-	}
-
-	/* Connectionless channel */
-	if (sk->sk_type == SOCK_DGRAM) {
-		skb = l2cap_create_connless_pdu(sk, msg, len);
-		if (IS_ERR(skb)) {
-			err = PTR_ERR(skb);
-		} else {
-			l2cap_do_send(sk, skb);
-			err = len;
-		}
-		goto done;
-	}
-
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		/* Check outgoing MTU */
-		if (len > pi->omtu) {
-			err = -EMSGSIZE;
-			goto done;
-		}
-
-		/* Create a basic PDU */
-		skb = l2cap_create_basic_pdu(sk, msg, len);
-		if (IS_ERR(skb)) {
-			err = PTR_ERR(skb);
-			goto done;
-		}
-
-		l2cap_do_send(sk, skb);
-		err = len;
-		break;
-
-	case L2CAP_MODE_ERTM:
-	case L2CAP_MODE_STREAMING:
-		/* Entire SDU fits into one PDU */
-		if (len <= pi->remote_mps) {
-			control = L2CAP_SDU_UNSEGMENTED;
-			skb = l2cap_create_iframe_pdu(sk, msg, len, control, 0);
-			if (IS_ERR(skb)) {
-				err = PTR_ERR(skb);
-				goto done;
-			}
-			__skb_queue_tail(TX_QUEUE(sk), skb);
-
-			if (sk->sk_send_head == NULL)
-				sk->sk_send_head = skb;
-
-		} else {
-		/* Segment SDU into multiples PDUs */
-			err = l2cap_sar_segment_sdu(sk, msg, len);
-			if (err < 0)
-				goto done;
-		}
-
-		if (pi->mode == L2CAP_MODE_STREAMING) {
-			l2cap_streaming_send(sk);
-		} else {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-					(pi->conn_state & L2CAP_CONN_WAIT_F)) {
-				err = len;
-				break;
-			}
-			err = l2cap_ertm_send(sk);
-		}
-
-		if (err >= 0)
-			err = len;
-		break;
-
-	default:
-		BT_DBG("bad state %1.1x", pi->mode);
-		err = -EBADFD;
-	}
-
-done:
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags)
-{
-	struct sock *sk = sock->sk;
-
-	lock_sock(sk);
-
-	if (sk->sk_state == BT_CONNECT2 && bt_sk(sk)->defer_setup) {
-		struct l2cap_conn_rsp rsp;
-		struct l2cap_conn *conn = l2cap_pi(sk)->conn;
-		u8 buf[128];
-
-		sk->sk_state = BT_CONFIG;
-
-		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-		rsp.result = cpu_to_le16(L2CAP_CR_SUCCESS);
-		rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-		l2cap_send_cmd(l2cap_pi(sk)->conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) {
-			release_sock(sk);
-			return 0;
-		}
-
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-				l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-
-		release_sock(sk);
-		return 0;
-	}
-
-	release_sock(sk);
-
-	if (sock->type == SOCK_STREAM)
-		return bt_sock_stream_recvmsg(iocb, sock, msg, len, flags);
-
-	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
-}
-
-static int l2cap_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, unsigned int optlen)
-{
-	struct sock *sk = sock->sk;
-	struct l2cap_options opts;
-	int len, err = 0;
-	u32 opt;
-
-	BT_DBG("sk %p", sk);
-
-	lock_sock(sk);
-
-	switch (optname) {
-	case L2CAP_OPTIONS:
-		if (sk->sk_state == BT_CONNECTED) {
-			err = -EINVAL;
-			break;
-		}
-
-		opts.imtu     = l2cap_pi(sk)->imtu;
-		opts.omtu     = l2cap_pi(sk)->omtu;
-		opts.flush_to = l2cap_pi(sk)->flush_to;
-		opts.mode     = l2cap_pi(sk)->mode;
-		opts.fcs      = l2cap_pi(sk)->fcs;
-		opts.max_tx   = l2cap_pi(sk)->max_tx;
-		opts.txwin_size = (__u16)l2cap_pi(sk)->tx_win;
-
-		len = min_t(unsigned int, sizeof(opts), optlen);
-		if (copy_from_user((char *) &opts, optval, len)) {
-			err = -EFAULT;
-			break;
-		}
-
-		if (opts.txwin_size > L2CAP_DEFAULT_TX_WINDOW) {
-			err = -EINVAL;
-			break;
-		}
-
-		l2cap_pi(sk)->mode = opts.mode;
-		switch (l2cap_pi(sk)->mode) {
-		case L2CAP_MODE_BASIC:
-			l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_STATE2_DEVICE;
-			break;
-		case L2CAP_MODE_ERTM:
-		case L2CAP_MODE_STREAMING:
-			if (!disable_ertm)
-				break;
-			/* fall through */
-		default:
-			err = -EINVAL;
-			break;
-		}
-
-		l2cap_pi(sk)->imtu = opts.imtu;
-		l2cap_pi(sk)->omtu = opts.omtu;
-		l2cap_pi(sk)->fcs  = opts.fcs;
-		l2cap_pi(sk)->max_tx = opts.max_tx;
-		l2cap_pi(sk)->tx_win = (__u8)opts.txwin_size;
-		break;
-
-	case L2CAP_LM:
-		if (get_user(opt, (u32 __user *) optval)) {
-			err = -EFAULT;
-			break;
-		}
-
-		if (opt & L2CAP_LM_AUTH)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_LOW;
-		if (opt & L2CAP_LM_ENCRYPT)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_MEDIUM;
-		if (opt & L2CAP_LM_SECURE)
-			l2cap_pi(sk)->sec_level = BT_SECURITY_HIGH;
-
-		l2cap_pi(sk)->role_switch    = (opt & L2CAP_LM_MASTER);
-		l2cap_pi(sk)->force_reliable = (opt & L2CAP_LM_RELIABLE);
-		l2cap_pi(sk)->flushable = (opt & L2CAP_LM_FLUSHABLE);
-		break;
-
-	default:
-		err = -ENOPROTOOPT;
-		break;
-	}
-
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
-{
-	struct sock *sk = sock->sk;
-	struct bt_security sec;
-	struct bt_power pwr;
-	int len, err = 0;
-	u32 opt;
-
-	BT_DBG("sk %p", sk);
-
-	if (level == SOL_L2CAP)
-		return l2cap_sock_setsockopt_old(sock, optname, optval, optlen);
-
-	if (level != SOL_BLUETOOTH)
-		return -ENOPROTOOPT;
-
-	lock_sock(sk);
-
-	switch (optname) {
-	case BT_SECURITY:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
-			err = -EINVAL;
-			break;
-		}
-
-		sec.level = BT_SECURITY_LOW;
-
-		len = min_t(unsigned int, sizeof(sec), optlen);
-		if (copy_from_user((char *) &sec, optval, len)) {
-			err = -EFAULT;
-			break;
-		}
-
-		if (sec.level < BT_SECURITY_LOW ||
-					sec.level > BT_SECURITY_HIGH) {
-			err = -EINVAL;
-			break;
-		}
-
-		l2cap_pi(sk)->sec_level = sec.level;
-		break;
-
-	case BT_DEFER_SETUP:
-		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
-			err = -EINVAL;
-			break;
-		}
-
-		if (get_user(opt, (u32 __user *) optval)) {
-			err = -EFAULT;
-			break;
-		}
-
-		bt_sk(sk)->defer_setup = opt;
-		break;
-
-	case BT_POWER:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
-			err = -EINVAL;
-			break;
-		}
-
-		pwr.force_active = 1;
-
-		len = min_t(unsigned int, sizeof(pwr), optlen);
-		if (copy_from_user((char *) &pwr, optval, len)) {
-			err = -EFAULT;
-			break;
-		}
-		l2cap_pi(sk)->force_active = pwr.force_active;
-		break;
-
-	default:
-		err = -ENOPROTOOPT;
-		break;
-	}
-
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)
-{
-	struct sock *sk = sock->sk;
-	struct l2cap_options opts;
-	struct l2cap_conninfo cinfo;
-	int len, err = 0;
-	u32 opt;
-
-	BT_DBG("sk %p", sk);
-
-	if (get_user(len, optlen))
-		return -EFAULT;
-
-	lock_sock(sk);
-
-	switch (optname) {
-	case L2CAP_OPTIONS:
-		opts.imtu     = l2cap_pi(sk)->imtu;
-		opts.omtu     = l2cap_pi(sk)->omtu;
-		opts.flush_to = l2cap_pi(sk)->flush_to;
-		opts.mode     = l2cap_pi(sk)->mode;
-		opts.fcs      = l2cap_pi(sk)->fcs;
-		opts.max_tx   = l2cap_pi(sk)->max_tx;
-		opts.txwin_size = (__u16)l2cap_pi(sk)->tx_win;
-
-		len = min_t(unsigned int, len, sizeof(opts));
-		if (copy_to_user(optval, (char *) &opts, len))
-			err = -EFAULT;
-
-		break;
-
-	case L2CAP_LM:
-		switch (l2cap_pi(sk)->sec_level) {
-		case BT_SECURITY_LOW:
-			opt = L2CAP_LM_AUTH;
-			break;
-		case BT_SECURITY_MEDIUM:
-			opt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT;
-			break;
-		case BT_SECURITY_HIGH:
-			opt = L2CAP_LM_AUTH | L2CAP_LM_ENCRYPT |
-							L2CAP_LM_SECURE;
-			break;
-		default:
-			opt = 0;
-			break;
-		}
-
-		if (l2cap_pi(sk)->role_switch)
-			opt |= L2CAP_LM_MASTER;
-
-		if (l2cap_pi(sk)->force_reliable)
-			opt |= L2CAP_LM_RELIABLE;
-
-		if (l2cap_pi(sk)->flushable)
-			opt |= L2CAP_LM_FLUSHABLE;
-
-		if (put_user(opt, (u32 __user *) optval))
-			err = -EFAULT;
-		break;
-
-	case L2CAP_CONNINFO:
-		if (sk->sk_state != BT_CONNECTED &&
-					!(sk->sk_state == BT_CONNECT2 &&
-						bt_sk(sk)->defer_setup)) {
-			err = -ENOTCONN;
-			break;
-		}
-
-		cinfo.hci_handle = l2cap_pi(sk)->conn->hcon->handle;
-		memcpy(cinfo.dev_class, l2cap_pi(sk)->conn->hcon->dev_class, 3);
-
-		len = min_t(unsigned int, len, sizeof(cinfo));
-		if (copy_to_user(optval, (char *) &cinfo, len))
-			err = -EFAULT;
-
-		break;
-
-	default:
-		err = -ENOPROTOOPT;
-		break;
-	}
-
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
-{
-	struct sock *sk = sock->sk;
-	struct bt_security sec;
-	struct bt_power pwr;
-	int len, err = 0;
-
-	BT_DBG("sk %p", sk);
-
-	if (level == SOL_L2CAP)
-		return l2cap_sock_getsockopt_old(sock, optname, optval, optlen);
-
-	if (level != SOL_BLUETOOTH)
-		return -ENOPROTOOPT;
-
-	if (get_user(len, optlen))
-		return -EFAULT;
-
-	lock_sock(sk);
-
-	switch (optname) {
-	case BT_SECURITY:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
-			err = -EINVAL;
-			break;
-		}
-
-		sec.level = l2cap_pi(sk)->sec_level;
-
-		len = min_t(unsigned int, len, sizeof(sec));
-		if (copy_to_user(optval, (char *) &sec, len))
-			err = -EFAULT;
-
-		break;
-
-	case BT_DEFER_SETUP:
-		if (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {
-			err = -EINVAL;
-			break;
-		}
-
-		if (put_user(bt_sk(sk)->defer_setup, (u32 __user *) optval))
-			err = -EFAULT;
-
-		break;
-
-	case BT_POWER:
-		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
-				&& sk->sk_type != SOCK_RAW) {
-			err = -EINVAL;
-			break;
-		}
-
-		pwr.force_active = l2cap_pi(sk)->force_active;
-
-		len = min_t(unsigned int, len, sizeof(pwr));
-		if (copy_to_user(optval, (char *) &pwr, len))
-			err = -EFAULT;
-
-		break;
-	default:
-		err = -ENOPROTOOPT;
-		break;
-	}
-
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_shutdown(struct socket *sock, int how)
-{
-	struct sock *sk = sock->sk;
-	int err = 0;
-
-	BT_DBG("sock %p, sk %p", sock, sk);
-
-	if (!sk)
-		return 0;
-
-	lock_sock(sk);
-	if (!sk->sk_shutdown) {
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM)
-			err = __l2cap_wait_ack(sk);
-
-		sk->sk_shutdown = SHUTDOWN_MASK;
-		l2cap_sock_clear_timer(sk);
-		__l2cap_sock_close(sk, 0);
-
-		if (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime)
-			err = bt_sock_wait_state(sk, BT_CLOSED,
-							sk->sk_lingertime);
-	}
-
-	if (!err && sk->sk_err)
-		err = -sk->sk_err;
-
-	release_sock(sk);
-	return err;
-}
-
-static int l2cap_sock_release(struct socket *sock)
-{
-	struct sock *sk = sock->sk;
-	int err;
-
-	BT_DBG("sock %p, sk %p", sock, sk);
-
-	if (!sk)
-		return 0;
-
-	err = l2cap_sock_shutdown(sock, 2);
-
-	sock_orphan(sk);
-	l2cap_sock_kill(sk);
-	return err;
-}
-
-static void l2cap_chan_ready(struct sock *sk)
-{
-	struct sock *parent = bt_sk(sk)->parent;
-
-	BT_DBG("sk %p, parent %p", sk, parent);
-
-	l2cap_pi(sk)->conf_state = 0;
-	l2cap_sock_clear_timer(sk);
-
-	if (!parent) {
-		/* Outgoing channel.
-		 * Wake up socket sleeping on connect.
-		 */
-		sk->sk_state = BT_CONNECTED;
-		sk->sk_state_change(sk);
-	} else {
-		/* Incoming channel.
-		 * Wake up socket sleeping on accept.
-		 */
-		parent->sk_data_ready(parent, 0);
-	}
-}
-
-/* Copy frame to all raw sockets on that connection */
-static void l2cap_raw_recv(struct l2cap_conn *conn, struct sk_buff *skb)
-{
-	struct l2cap_chan_list *l = &conn->chan_list;
-	struct sk_buff *nskb;
-	struct sock *sk;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		if (sk->sk_type != SOCK_RAW)
-			continue;
-
-		/* Don't send frame to the socket it came from */
-		if (skb->sk == sk)
-			continue;
-		nskb = skb_clone(skb, GFP_ATOMIC);
-		if (!nskb)
-			continue;
-
-		if (sock_queue_rcv_skb(sk, nskb))
-			kfree_skb(nskb);
-	}
-	read_unlock(&l->lock);
-}
-
-/* ---- L2CAP signalling commands ---- */
-static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,
-				u8 code, u8 ident, u16 dlen, void *data)
-{
-	struct sk_buff *skb, **frag;
-	struct l2cap_cmd_hdr *cmd;
-	struct l2cap_hdr *lh;
-	int len, count;
-
-	BT_DBG("conn %p, code 0x%2.2x, ident 0x%2.2x, len %d",
-			conn, code, ident, dlen);
-
-	len = L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE + dlen;
-	count = min_t(unsigned int, conn->mtu, len);
-
-	skb = bt_skb_alloc(count, GFP_ATOMIC);
-	if (!skb)
-		return NULL;
-
-	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
-	lh->cid = cpu_to_le16(L2CAP_CID_SIGNALING);
-
-	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
-	cmd->code  = code;
-	cmd->ident = ident;
-	cmd->len   = cpu_to_le16(dlen);
-
-	if (dlen) {
-		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
-		memcpy(skb_put(skb, count), data, count);
-		data += count;
-	}
-
-	len -= skb->len;
-
-	/* Continuation fragments (no L2CAP header) */
-	frag = &skb_shinfo(skb)->frag_list;
-	while (len) {
-		count = min_t(unsigned int, conn->mtu, len);
-
-		*frag = bt_skb_alloc(count, GFP_ATOMIC);
-		if (!*frag)
-			goto fail;
-
-		memcpy(skb_put(*frag, count), data, count);
-
-		len  -= count;
-		data += count;
-
-		frag = &(*frag)->next;
-	}
-
-	return skb;
-
-fail:
-	kfree_skb(skb);
-	return NULL;
-}
-
-static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen, unsigned long *val)
-{
-	struct l2cap_conf_opt *opt = *ptr;
-	int len;
-
-	len = L2CAP_CONF_OPT_SIZE + opt->len;
-	*ptr += len;
-
-	*type = opt->type;
-	*olen = opt->len;
-
-	switch (opt->len) {
-	case 1:
-		*val = *((u8 *) opt->val);
-		break;
-
-	case 2:
-		*val = get_unaligned_le16(opt->val);
-		break;
-
-	case 4:
-		*val = get_unaligned_le32(opt->val);
-		break;
-
-	default:
-		*val = (unsigned long) opt->val;
-		break;
-	}
-
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", *type, opt->len, *val);
-	return len;
-}
-
-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
-{
-	struct l2cap_conf_opt *opt = *ptr;
-
-	BT_DBG("type 0x%2.2x len %d val 0x%lx", type, len, val);
-
-	opt->type = type;
-	opt->len  = len;
-
-	switch (len) {
-	case 1:
-		*((u8 *) opt->val)  = val;
-		break;
-
-	case 2:
-		put_unaligned_le16(val, opt->val);
-		break;
-
-	case 4:
-		put_unaligned_le32(val, opt->val);
-		break;
-
-	default:
-		memcpy(opt->val, (void *) val, len);
-		break;
-	}
-
-	*ptr += L2CAP_CONF_OPT_SIZE + len;
-}
-
-static void l2cap_ack_timeout(unsigned long arg)
-{
-	struct sock *sk = (void *) arg;
-
-	bh_lock_sock(sk);
-	l2cap_send_ack(l2cap_pi(sk));
-	bh_unlock_sock(sk);
-}
-
-static inline void l2cap_ertm_init(struct sock *sk)
-{
-	l2cap_pi(sk)->expected_ack_seq = 0;
-	l2cap_pi(sk)->unacked_frames = 0;
-	l2cap_pi(sk)->buffer_seq = 0;
-	l2cap_pi(sk)->num_acked = 0;
-	l2cap_pi(sk)->frames_sent = 0;
-
-	setup_timer(&l2cap_pi(sk)->retrans_timer,
-			l2cap_retrans_timeout, (unsigned long) sk);
-	setup_timer(&l2cap_pi(sk)->monitor_timer,
-			l2cap_monitor_timeout, (unsigned long) sk);
-	setup_timer(&l2cap_pi(sk)->ack_timer,
-			l2cap_ack_timeout, (unsigned long) sk);
-
-	__skb_queue_head_init(SREJ_QUEUE(sk));
-	__skb_queue_head_init(BUSY_QUEUE(sk));
-
-	INIT_WORK(&l2cap_pi(sk)->busy_work, l2cap_busy_work);
-
-	sk->sk_backlog_rcv = l2cap_ertm_data_rcv;
-}
-
-static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
-{
-	switch (mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (l2cap_mode_supported(mode, remote_feat_mask))
-			return mode;
-		/* fall through */
-	default:
-		return L2CAP_MODE_BASIC;
-	}
-}
-
-static int l2cap_build_conf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	struct l2cap_conf_rfc rfc = { .mode = pi->mode };
-	void *ptr = req->data;
-
-	BT_DBG("sk %p", sk);
-
-	if (pi->num_conf_req || pi->num_conf_rsp)
-		goto done;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (pi->conf_state & L2CAP_CONF_STATE2_DEVICE)
-			break;
-
-		/* fall through */
-	default:
-		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
-		break;
-	}
-
-done:
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		if (pi->imtu != L2CAP_DEFAULT_MTU)
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_ERTM) &&
-				!(pi->conn->feat_mask & L2CAP_FEAT_STREAMING))
-			break;
-
-		rfc.mode            = L2CAP_MODE_BASIC;
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = 0;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-		break;
-
-	case L2CAP_MODE_ERTM:
-		rfc.mode            = L2CAP_MODE_ERTM;
-		rfc.txwin_size      = pi->tx_win;
-		rfc.max_transmit    = pi->max_tx;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->conn->mtu - 10)
-			rfc.max_pdu_size = cpu_to_le16(pi->conn->mtu - 10);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
-
-		if (pi->fcs == L2CAP_FCS_NONE ||
-				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
-			pi->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
-		}
-		break;
-
-	case L2CAP_MODE_STREAMING:
-		rfc.mode            = L2CAP_MODE_STREAMING;
-		rfc.txwin_size      = 0;
-		rfc.max_transmit    = 0;
-		rfc.retrans_timeout = 0;
-		rfc.monitor_timeout = 0;
-		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);
-		if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->conn->mtu - 10)
-			rfc.max_pdu_size = cpu_to_le16(pi->conn->mtu - 10);
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc),
-							(unsigned long) &rfc);
-
-		if (!(pi->conn->feat_mask & L2CAP_FEAT_FCS))
-			break;
-
-		if (pi->fcs == L2CAP_FCS_NONE ||
-				pi->conf_state & L2CAP_CONF_NO_FCS_RECV) {
-			pi->fcs = L2CAP_FCS_NONE;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FCS, 1, pi->fcs);
-		}
-		break;
-	}
-
-	/* FIXME: Need actual value of the flush timeout */
-	//if (flush_to != L2CAP_DEFAULT_FLUSH_TO)
-	//   l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, pi->flush_to);
-
-	req->dcid  = cpu_to_le16(pi->dcid);
-	req->flags = cpu_to_le16(0);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_conf_req(struct sock *sk, void *data)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-	void *req = pi->conf_req;
-	int len = pi->conf_len;
-	int type, hint, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
-	u16 mtu = L2CAP_DEFAULT_MTU;
-	u16 result = L2CAP_CONF_SUCCESS;
-
-	BT_DBG("sk %p", sk);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
-
-		hint  = type & L2CAP_CONF_HINT;
-		type &= L2CAP_CONF_MASK;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			pi->flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *) val, olen);
-			break;
-
-		case L2CAP_CONF_FCS:
-			if (val == L2CAP_FCS_NONE)
-				pi->conf_state |= L2CAP_CONF_NO_FCS_RECV;
-
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			result = L2CAP_CONF_UNKNOWN;
-			*((u8 *) ptr++) = type;
-			break;
-		}
-	}
-
-	if (pi->num_conf_rsp || pi->num_conf_req > 1)
-		goto done;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_STREAMING:
-	case L2CAP_MODE_ERTM:
-		if (!(pi->conf_state & L2CAP_CONF_STATE2_DEVICE)) {
-			pi->mode = l2cap_select_mode(rfc.mode,
-					pi->conn->feat_mask);
-			break;
-		}
-
-		if (pi->mode != rfc.mode)
-			return -ECONNREFUSED;
-
-		break;
-	}
-
-done:
-	if (pi->mode != rfc.mode) {
-		result = L2CAP_CONF_UNACCEPT;
-		rfc.mode = pi->mode;
-
-		if (pi->num_conf_rsp == 1)
-			return -ECONNREFUSED;
-
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-	}
-
-
-	if (result == L2CAP_CONF_SUCCESS) {
-		/* Configure output options and let the other side know
-		 * which ones we don't like. */
-
-		if (mtu < L2CAP_DEFAULT_MIN_MTU)
-			result = L2CAP_CONF_UNACCEPT;
-		else {
-			pi->omtu = mtu;
-			pi->conf_state |= L2CAP_CONF_MTU_DONE;
-		}
-		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
-
-		switch (rfc.mode) {
-		case L2CAP_MODE_BASIC:
-			pi->fcs = L2CAP_FCS_NONE;
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-			break;
-
-		case L2CAP_MODE_ERTM:
-			pi->remote_tx_win = rfc.txwin_size;
-			pi->remote_max_tx = rfc.max_transmit;
-
-			if (le16_to_cpu(rfc.max_pdu_size) > pi->conn->mtu - 10)
-				rfc.max_pdu_size = cpu_to_le16(pi->conn->mtu - 10);
-
-			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
-
-			rfc.retrans_timeout =
-				le16_to_cpu(L2CAP_DEFAULT_RETRANS_TO);
-			rfc.monitor_timeout =
-				le16_to_cpu(L2CAP_DEFAULT_MONITOR_TO);
-
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-
-			break;
-
-		case L2CAP_MODE_STREAMING:
-			if (le16_to_cpu(rfc.max_pdu_size) > pi->conn->mtu - 10)
-				rfc.max_pdu_size = cpu_to_le16(pi->conn->mtu - 10);
-
-			pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);
-
-			pi->conf_state |= L2CAP_CONF_MODE_DONE;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-
-			break;
-
-		default:
-			result = L2CAP_CONF_UNACCEPT;
-
-			memset(&rfc, 0, sizeof(rfc));
-			rfc.mode = pi->mode;
-		}
-
-		if (result == L2CAP_CONF_SUCCESS)
-			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
-	}
-	rsp->scid   = cpu_to_le16(pi->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct l2cap_conf_req *req = data;
-	void *ptr = req->data;
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-
-	BT_DBG("sk %p, rsp %p, len %d, req %p", sk, rsp, len, data);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			if (val < L2CAP_DEFAULT_MIN_MTU) {
-				*result = L2CAP_CONF_UNACCEPT;
-				pi->imtu = L2CAP_DEFAULT_MIN_MTU;
-			} else
-				pi->imtu = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			pi->flush_to = val;
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
-							2, pi->flush_to);
-			break;
-
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-
-			if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&
-							rfc.mode != pi->mode)
-				return -ECONNREFUSED;
-
-			pi->fcs = 0;
-
-			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
-					sizeof(rfc), (unsigned long) &rfc);
-			break;
-		}
-	}
-
-	if (pi->mode == L2CAP_MODE_BASIC && pi->mode != rfc.mode)
-		return -ECONNREFUSED;
-
-	pi->mode = rfc.mode;
-
-	if (*result == L2CAP_CONF_SUCCESS) {
-		switch (rfc.mode) {
-		case L2CAP_MODE_ERTM:
-			pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-			pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-			break;
-		case L2CAP_MODE_STREAMING:
-			pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-		}
-	}
-
-	req->dcid   = cpu_to_le16(pi->dcid);
-	req->flags  = cpu_to_le16(0x0000);
-
-	return ptr - data;
-}
-
-static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)
-{
-	struct l2cap_conf_rsp *rsp = data;
-	void *ptr = rsp->data;
-
-	BT_DBG("sk %p", sk);
-
-	rsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-	rsp->result = cpu_to_le16(result);
-	rsp->flags  = cpu_to_le16(flags);
-
-	return ptr - data;
-}
-
-static void l2cap_conf_rfc_get(struct sock *sk, void *rsp, int len)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int type, olen;
-	unsigned long val;
-	struct l2cap_conf_rfc rfc;
-
-	BT_DBG("sk %p, rsp %p, len %d", sk, rsp, len);
-
-	if ((pi->mode != L2CAP_MODE_ERTM) && (pi->mode != L2CAP_MODE_STREAMING))
-		return;
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
-
-		switch (type) {
-		case L2CAP_CONF_RFC:
-			if (olen == sizeof(rfc))
-				memcpy(&rfc, (void *)val, olen);
-			goto done;
-		}
-	}
-
-done:
-	switch (rfc.mode) {
-	case L2CAP_MODE_ERTM:
-		pi->retrans_timeout = le16_to_cpu(rfc.retrans_timeout);
-		pi->monitor_timeout = le16_to_cpu(rfc.monitor_timeout);
-		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-		break;
-	case L2CAP_MODE_STREAMING:
-		pi->mps    = le16_to_cpu(rfc.max_pdu_size);
-	}
-}
-
-static inline int l2cap_command_rej(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_cmd_rej *rej = (struct l2cap_cmd_rej *) data;
-
-	if (rej->reason != 0x0000)
-		return 0;
-
-	if ((conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT) &&
-					cmd->ident == conn->info_ident) {
-		del_timer(&conn->info_timer);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
-
-		l2cap_conn_start(conn);
-	}
-
-	return 0;
-}
-
-static inline int l2cap_connect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_chan_list *list = &conn->chan_list;
-	struct l2cap_conn_req *req = (struct l2cap_conn_req *) data;
-	struct l2cap_conn_rsp rsp;
-	struct sock *parent, *sk = NULL;
-	int result, status = L2CAP_CS_NO_INFO;
-
-	u16 dcid = 0, scid = __le16_to_cpu(req->scid);
-	__le16 psm = req->psm;
-
-	BT_DBG("psm 0x%2.2x scid 0x%4.4x", psm, scid);
-
-	/* Check if we have socket listening on psm */
-	parent = l2cap_get_sock_by_psm(BT_LISTEN, psm, conn->src);
-	if (!parent) {
-		result = L2CAP_CR_BAD_PSM;
-		goto sendresp;
-	}
-
-	bh_lock_sock(parent);
-
-	/* Check if the ACL is secure enough (if not SDP) */
-	if (psm != cpu_to_le16(0x0001) &&
-				!hci_conn_check_link_mode(conn->hcon)) {
-		conn->disc_reason = 0x05;
-		result = L2CAP_CR_SEC_BLOCK;
-		goto response;
-	}
-
-	result = L2CAP_CR_NO_MEM;
-
-	/* Check for backlog size */
-	if (sk_acceptq_is_full(parent)) {
-		BT_DBG("backlog full %d", parent->sk_ack_backlog);
-		goto response;
-	}
-
-	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
-	if (!sk)
-		goto response;
-
-	write_lock_bh(&list->lock);
-
-	/* Check if we already have channel with that dcid */
-	if (__l2cap_get_chan_by_dcid(list, scid)) {
-		write_unlock_bh(&list->lock);
-		sock_set_flag(sk, SOCK_ZAPPED);
-		l2cap_sock_kill(sk);
-		goto response;
-	}
-
-	hci_conn_hold(conn->hcon);
-
-	l2cap_sock_init(sk, parent);
-	bacpy(&bt_sk(sk)->src, conn->src);
-	bacpy(&bt_sk(sk)->dst, conn->dst);
-	l2cap_pi(sk)->psm  = psm;
-	l2cap_pi(sk)->dcid = scid;
-
-	__l2cap_chan_add(conn, sk, parent);
-	dcid = l2cap_pi(sk)->scid;
-
-	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
-
-	l2cap_pi(sk)->ident = cmd->ident;
-
-	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_DONE) {
-		if (l2cap_check_security(sk)) {
-			if (bt_sk(sk)->defer_setup) {
-				sk->sk_state = BT_CONNECT2;
-				result = L2CAP_CR_PEND;
-				status = L2CAP_CS_AUTHOR_PEND;
-				parent->sk_data_ready(parent, 0);
-			} else {
-				sk->sk_state = BT_CONFIG;
-				result = L2CAP_CR_SUCCESS;
-				status = L2CAP_CS_NO_INFO;
-			}
-		} else {
-			sk->sk_state = BT_CONNECT2;
-			result = L2CAP_CR_PEND;
-			status = L2CAP_CS_AUTHEN_PEND;
-		}
-	} else {
-		sk->sk_state = BT_CONNECT2;
-		result = L2CAP_CR_PEND;
-		status = L2CAP_CS_NO_INFO;
-	}
-
-	write_unlock_bh(&list->lock);
-
-response:
-	bh_unlock_sock(parent);
-
-sendresp:
-	rsp.scid   = cpu_to_le16(scid);
-	rsp.dcid   = cpu_to_le16(dcid);
-	rsp.result = cpu_to_le16(result);
-	rsp.status = cpu_to_le16(status);
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-
-	if (result == L2CAP_CR_PEND && status == L2CAP_CS_NO_INFO) {
-		struct l2cap_info_req info;
-		info.type = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_SENT;
-		conn->info_ident = l2cap_get_ident(conn);
-
-		mod_timer(&conn->info_timer, jiffies +
-					msecs_to_jiffies(L2CAP_INFO_TIMEOUT));
-
-		l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(info), &info);
-	}
-
-	if (sk && !(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT) &&
-				result == L2CAP_CR_SUCCESS) {
-		u8 buf[128];
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-	}
-
-	return 0;
-}
-
-static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;
-	u16 scid, dcid, result, status;
-	struct sock *sk;
-	u8 req[128];
-
-	scid   = __le16_to_cpu(rsp->scid);
-	dcid   = __le16_to_cpu(rsp->dcid);
-	result = __le16_to_cpu(rsp->result);
-	status = __le16_to_cpu(rsp->status);
-
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x", dcid, scid, result, status);
-
-	if (scid) {
-		sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-		if (!sk)
-			return -EFAULT;
-	} else {
-		sk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);
-		if (!sk)
-			return -EFAULT;
-	}
-
-	switch (result) {
-	case L2CAP_CR_SUCCESS:
-		sk->sk_state = BT_CONFIG;
-		l2cap_pi(sk)->ident = 0;
-		l2cap_pi(sk)->dcid = dcid;
-		l2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)
-			break;
-
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, req), req);
-		l2cap_pi(sk)->num_conf_req++;
-		break;
-
-	case L2CAP_CR_PEND:
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-		break;
-
-	default:
-		/* don't delete l2cap channel if sk is owned by user */
-		if (sock_owned_by_user(sk)) {
-			sk->sk_state = BT_DISCONN;
-			l2cap_sock_clear_timer(sk);
-			l2cap_sock_set_timer(sk, HZ / 5);
-			break;
-		}
-
-		l2cap_chan_del(sk, ECONNREFUSED);
-		break;
-	}
-
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline void set_default_fcs(struct l2cap_pinfo *pi)
-{
-	/* FCS is enabled only in ERTM or streaming mode, if one or both
-	 * sides request it.
-	 */
-	if (pi->mode != L2CAP_MODE_ERTM && pi->mode != L2CAP_MODE_STREAMING)
-		pi->fcs = L2CAP_FCS_NONE;
-	else if (!(pi->conf_state & L2CAP_CONF_NO_FCS_RECV))
-		pi->fcs = L2CAP_FCS_CRC16;
-}
-
-static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u16 cmd_len, u8 *data)
-{
-	struct l2cap_conf_req *req = (struct l2cap_conf_req *) data;
-	u16 dcid, flags;
-	u8 rsp[64];
-	struct sock *sk;
-	int len;
-
-	dcid  = __le16_to_cpu(req->dcid);
-	flags = __le16_to_cpu(req->flags);
-
-	BT_DBG("dcid 0x%4.4x flags 0x%2.2x", dcid, flags);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
-	if (!sk)
-		return -ENOENT;
-
-	if (sk->sk_state != BT_CONFIG) {
-		struct l2cap_cmd_rej rej;
-
-		rej.reason = cpu_to_le16(0x0002);
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_COMMAND_REJ,
-				sizeof(rej), &rej);
-		goto unlock;
-	}
-
-	/* Reject if config buffer is too small. */
-	len = cmd_len - sizeof(*req);
-	if (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rsp,
-					L2CAP_CONF_REJECT, flags), rsp);
-		goto unlock;
-	}
-
-	/* Store config. */
-	memcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);
-	l2cap_pi(sk)->conf_len += len;
-
-	if (flags & 0x0001) {
-		/* Incomplete config. Send empty response. */
-		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rsp,
-					L2CAP_CONF_SUCCESS, 0x0001), rsp);
-		goto unlock;
-	}
-
-	/* Complete config. */
-	len = l2cap_parse_conf_req(sk, rsp);
-	if (len < 0) {
-		l2cap_send_disconn_req(conn, sk, ECONNRESET);
-		goto unlock;
-	}
-
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
-	l2cap_pi(sk)->num_conf_rsp++;
-
-	/* Reset config buffer. */
-	l2cap_pi(sk)->conf_len = 0;
-
-	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE))
-		goto unlock;
-
-	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
-		set_default_fcs(l2cap_pi(sk));
-
-		sk->sk_state = BT_CONNECTED;
-
-		l2cap_pi(sk)->next_tx_seq = 0;
-		l2cap_pi(sk)->expected_tx_seq = 0;
-		__skb_queue_head_init(TX_QUEUE(sk));
-		if (l2cap_pi(sk)->mode == L2CAP_MODE_ERTM)
-			l2cap_ertm_init(sk);
-
-		l2cap_chan_ready(sk);
-		goto unlock;
-	}
-
-	if (!(l2cap_pi(sk)->conf_state & L2CAP_CONF_REQ_SENT)) {
-		u8 buf[64];
-		l2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;
-		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
-					l2cap_build_conf_req(sk, buf), buf);
-		l2cap_pi(sk)->num_conf_req++;
-	}
-
-unlock:
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;
-	u16 scid, flags, result;
-	struct sock *sk;
-	int len = cmd->len - sizeof(*rsp);
-
-	scid   = __le16_to_cpu(rsp->scid);
-	flags  = __le16_to_cpu(rsp->flags);
-	result = __le16_to_cpu(rsp->result);
-
-	BT_DBG("scid 0x%4.4x flags 0x%2.2x result 0x%2.2x",
-			scid, flags, result);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-	if (!sk)
-		return 0;
-
-	switch (result) {
-	case L2CAP_CONF_SUCCESS:
-		l2cap_conf_rfc_get(sk, rsp->data, len);
-		break;
-
-	case L2CAP_CONF_UNACCEPT:
-		if (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
-			char req[64];
-
-			if (len > sizeof(req) - sizeof(struct l2cap_conf_req)) {
-				l2cap_send_disconn_req(conn, sk, ECONNRESET);
-				goto done;
-			}
-
-			/* throw out any old stored conf requests */
-			result = L2CAP_CONF_SUCCESS;
-			len = l2cap_parse_conf_rsp(sk, rsp->data,
-							len, req, &result);
-			if (len < 0) {
-				l2cap_send_disconn_req(conn, sk, ECONNRESET);
-				goto done;
-			}
-
-			l2cap_send_cmd(conn, l2cap_get_ident(conn),
-						L2CAP_CONF_REQ, len, req);
-			l2cap_pi(sk)->num_conf_req++;
-			if (result != L2CAP_CONF_SUCCESS)
-				goto done;
-			break;
-		}
-
-	default:
-		sk->sk_err = ECONNRESET;
-		l2cap_sock_set_timer(sk, HZ * 5);
-		l2cap_send_disconn_req(conn, sk, ECONNRESET);
-		goto done;
-	}
-
-	if (flags & 0x01)
-		goto done;
-
-	l2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;
-
-	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {
-		set_default_fcs(l2cap_pi(sk));
-
-		sk->sk_state = BT_CONNECTED;
-		l2cap_pi(sk)->next_tx_seq = 0;
-		l2cap_pi(sk)->expected_tx_seq = 0;
-		__skb_queue_head_init(TX_QUEUE(sk));
-		if (l2cap_pi(sk)->mode ==  L2CAP_MODE_ERTM)
-			l2cap_ertm_init(sk);
-
-		l2cap_chan_ready(sk);
-	}
-
-done:
-	bh_unlock_sock(sk);
-	return 0;
-}
-
-static inline int l2cap_disconnect_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_disconn_req *req = (struct l2cap_disconn_req *) data;
-	struct l2cap_disconn_rsp rsp;
-	u16 dcid, scid;
-	struct sock *sk;
-
-	scid = __le16_to_cpu(req->scid);
-	dcid = __le16_to_cpu(req->dcid);
-
-	BT_DBG("scid 0x%4.4x dcid 0x%4.4x", scid, dcid);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid);
-	if (!sk)
-		return 0;
-
-	rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
-	rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
-
-	sk->sk_shutdown = SHUTDOWN_MASK;
-
-	/* don't delete l2cap channel if sk is owned by user */
-	if (sock_owned_by_user(sk)) {
-		sk->sk_state = BT_DISCONN;
-		l2cap_sock_clear_timer(sk);
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		return 0;
-	}
-
-	l2cap_chan_del(sk, ECONNRESET);
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	return 0;
-}
-
-static inline int l2cap_disconnect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_disconn_rsp *rsp = (struct l2cap_disconn_rsp *) data;
-	u16 dcid, scid;
-	struct sock *sk;
-
-	scid = __le16_to_cpu(rsp->scid);
-	dcid = __le16_to_cpu(rsp->dcid);
-
-	BT_DBG("dcid 0x%4.4x scid 0x%4.4x", dcid, scid);
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, scid);
-	if (!sk)
-		return 0;
-
-	/* don't delete l2cap channel if sk is owned by user */
-	if (sock_owned_by_user(sk)) {
-		sk->sk_state = BT_DISCONN;
-		l2cap_sock_clear_timer(sk);
-		l2cap_sock_set_timer(sk, HZ / 5);
-		bh_unlock_sock(sk);
-		return 0;
-	}
-
-	l2cap_chan_del(sk, 0);
-	bh_unlock_sock(sk);
-
-	l2cap_sock_kill(sk);
-	return 0;
-}
-
-static inline int l2cap_information_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_info_req *req = (struct l2cap_info_req *) data;
-	u16 type;
-
-	type = __le16_to_cpu(req->type);
-
-	BT_DBG("type 0x%4.4x", type);
-
-	if (type == L2CAP_IT_FEAT_MASK) {
-		u8 buf[8];
-		u32 feat_mask = l2cap_feat_mask;
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FEAT_MASK);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		if (!disable_ertm)
-			feat_mask |= L2CAP_FEAT_ERTM | L2CAP_FEAT_STREAMING
-							 | L2CAP_FEAT_FCS;
-		put_unaligned_le32(feat_mask, rsp->data);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		u8 buf[12];
-		struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) buf;
-		rsp->type   = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
-		rsp->result = cpu_to_le16(L2CAP_IR_SUCCESS);
-		memcpy(buf + 4, l2cap_fixed_chan, 8);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(buf), buf);
-	} else {
-		struct l2cap_info_rsp rsp;
-		rsp.type   = cpu_to_le16(type);
-		rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
-		l2cap_send_cmd(conn, cmd->ident,
-					L2CAP_INFO_RSP, sizeof(rsp), &rsp);
-	}
-
-	return 0;
-}
-
-static inline int l2cap_information_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)
-{
-	struct l2cap_info_rsp *rsp = (struct l2cap_info_rsp *) data;
-	u16 type, result;
-
-	type   = __le16_to_cpu(rsp->type);
-	result = __le16_to_cpu(rsp->result);
-
-	BT_DBG("type 0x%4.4x result 0x%2.2x", type, result);
-
-	del_timer(&conn->info_timer);
-
-	if (result != L2CAP_IR_SUCCESS) {
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
-
-		l2cap_conn_start(conn);
-
-		return 0;
-	}
-
-	if (type == L2CAP_IT_FEAT_MASK) {
-		conn->feat_mask = get_unaligned_le32(rsp->data);
-
-		if (conn->feat_mask & L2CAP_FEAT_FIXED_CHAN) {
-			struct l2cap_info_req req;
-			req.type = cpu_to_le16(L2CAP_IT_FIXED_CHAN);
-
-			conn->info_ident = l2cap_get_ident(conn);
-
-			l2cap_send_cmd(conn, conn->info_ident,
-					L2CAP_INFO_REQ, sizeof(req), &req);
-		} else {
-			conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-			conn->info_ident = 0;
-
-			l2cap_conn_start(conn);
-		}
-	} else if (type == L2CAP_IT_FIXED_CHAN) {
-		conn->info_state |= L2CAP_INFO_FEAT_MASK_REQ_DONE;
-		conn->info_ident = 0;
-
-		l2cap_conn_start(conn);
-	}
-
-	return 0;
-}
-
-static inline void l2cap_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb)
-{
-	u8 *data = skb->data;
-	int len = skb->len;
-	struct l2cap_cmd_hdr cmd;
-	int err = 0;
-
-	l2cap_raw_recv(conn, skb);
-
-	while (len >= L2CAP_CMD_HDR_SIZE) {
-		u16 cmd_len;
-		memcpy(&cmd, data, L2CAP_CMD_HDR_SIZE);
-		data += L2CAP_CMD_HDR_SIZE;
-		len  -= L2CAP_CMD_HDR_SIZE;
-
-		cmd_len = le16_to_cpu(cmd.len);
-
-		BT_DBG("code 0x%2.2x len %d id 0x%2.2x", cmd.code, cmd_len, cmd.ident);
-
-		if (cmd_len > len || !cmd.ident) {
-			BT_DBG("corrupted command");
-			break;
-		}
-
-		switch (cmd.code) {
-		case L2CAP_COMMAND_REJ:
-			l2cap_command_rej(conn, &cmd, data);
-			break;
-
-		case L2CAP_CONN_REQ:
-			err = l2cap_connect_req(conn, &cmd, data);
-			break;
-
-		case L2CAP_CONN_RSP:
-			err = l2cap_connect_rsp(conn, &cmd, data);
-			break;
-
-		case L2CAP_CONF_REQ:
-			err = l2cap_config_req(conn, &cmd, cmd_len, data);
-			break;
-
-		case L2CAP_CONF_RSP:
-			err = l2cap_config_rsp(conn, &cmd, data);
-			break;
-
-		case L2CAP_DISCONN_REQ:
-			err = l2cap_disconnect_req(conn, &cmd, data);
-			break;
-
-		case L2CAP_DISCONN_RSP:
-			err = l2cap_disconnect_rsp(conn, &cmd, data);
-			break;
-
-		case L2CAP_ECHO_REQ:
-			l2cap_send_cmd(conn, cmd.ident, L2CAP_ECHO_RSP, cmd_len, data);
-			break;
-
-		case L2CAP_ECHO_RSP:
-			break;
-
-		case L2CAP_INFO_REQ:
-			err = l2cap_information_req(conn, &cmd, data);
-			break;
-
-		case L2CAP_INFO_RSP:
-			err = l2cap_information_rsp(conn, &cmd, data);
-			break;
-
-		default:
-			BT_ERR("Unknown signaling command 0x%2.2x", cmd.code);
-			err = -EINVAL;
-			break;
-		}
-
-		if (err) {
-			struct l2cap_cmd_rej rej;
-			BT_DBG("error %d", err);
-
-			/* FIXME: Map err to a valid reason */
-			rej.reason = cpu_to_le16(0);
-			l2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);
-		}
-
-		data += cmd_len;
-		len  -= cmd_len;
-	}
-
-	kfree_skb(skb);
-}
-
-static int l2cap_check_fcs(struct l2cap_pinfo *pi,  struct sk_buff *skb)
-{
-	u16 our_fcs, rcv_fcs;
-	int hdr_size = L2CAP_HDR_SIZE + 2;
-
-	if (pi->fcs == L2CAP_FCS_CRC16) {
-		skb_trim(skb, skb->len - 2);
-		rcv_fcs = get_unaligned_le16(skb->data + skb->len);
-		our_fcs = crc16(0, skb->data - hdr_size, skb->len + hdr_size);
-
-		if (our_fcs != rcv_fcs)
-			return -EBADMSG;
-	}
-	return 0;
-}
-
-static inline void l2cap_send_i_or_rr_or_rnr(struct sock *sk)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u16 control = 0;
-
-	pi->frames_sent = 0;
-
-	control |= pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-		control |= L2CAP_SUPER_RCV_NOT_READY;
-		l2cap_send_sframe(pi, control);
-		pi->conn_state |= L2CAP_CONN_RNR_SENT;
-	}
-
-	if (pi->conn_state & L2CAP_CONN_REMOTE_BUSY)
-		l2cap_retransmit_frames(sk);
-
-	l2cap_ertm_send(sk);
-
-	if (!(pi->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
-			pi->frames_sent == 0) {
-		control |= L2CAP_SUPER_RCV_READY;
-		l2cap_send_sframe(pi, control);
-	}
-}
-
-static int l2cap_add_to_srej_queue(struct sock *sk, struct sk_buff *skb, u8 tx_seq, u8 sar)
-{
-	struct sk_buff *next_skb;
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int tx_seq_offset, next_tx_seq_offset;
-
-	bt_cb(skb)->tx_seq = tx_seq;
-	bt_cb(skb)->sar = sar;
-
-	next_skb = skb_peek(SREJ_QUEUE(sk));
-	if (!next_skb) {
-		__skb_queue_tail(SREJ_QUEUE(sk), skb);
-		return 0;
-	}
-
-	tx_seq_offset = (tx_seq - pi->buffer_seq) % 64;
-	if (tx_seq_offset < 0)
-		tx_seq_offset += 64;
-
-	do {
-		if (bt_cb(next_skb)->tx_seq == tx_seq)
-			return -EINVAL;
-
-		next_tx_seq_offset = (bt_cb(next_skb)->tx_seq -
-						pi->buffer_seq) % 64;
-		if (next_tx_seq_offset < 0)
-			next_tx_seq_offset += 64;
-
-		if (next_tx_seq_offset > tx_seq_offset) {
-			__skb_queue_before(SREJ_QUEUE(sk), next_skb, skb);
-			return 0;
-		}
-
-		if (skb_queue_is_last(SREJ_QUEUE(sk), next_skb))
-			break;
-
-	} while ((next_skb = skb_queue_next(SREJ_QUEUE(sk), next_skb)));
-
-	__skb_queue_tail(SREJ_QUEUE(sk), skb);
-
-	return 0;
-}
-
-static int l2cap_ertm_reassembly_sdu(struct sock *sk, struct sk_buff *skb, u16 control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *_skb;
-	int err;
-
-	switch (control & L2CAP_CTRL_SAR) {
-	case L2CAP_SDU_UNSEGMENTED:
-		if (pi->conn_state & L2CAP_CONN_SAR_SDU)
-			goto drop;
-
-		err = sock_queue_rcv_skb(sk, skb);
-		if (!err)
-			return err;
-
-		break;
-
-	case L2CAP_SDU_START:
-		if (pi->conn_state & L2CAP_CONN_SAR_SDU)
-			goto drop;
-
-		pi->sdu_len = get_unaligned_le16(skb->data);
-
-		if (pi->sdu_len > pi->imtu)
-			goto disconnect;
-
-		pi->sdu = bt_skb_alloc(pi->sdu_len, GFP_ATOMIC);
-		if (!pi->sdu)
-			return -ENOMEM;
-
-		/* pull sdu_len bytes only after alloc, because of Local Busy
-		 * condition we have to be sure that this will be executed
-		 * only once, i.e., when alloc does not fail */
-		skb_pull(skb, 2);
-
-		memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);
-
-		pi->conn_state |= L2CAP_CONN_SAR_SDU;
-		pi->partial_sdu_len = skb->len;
-		break;
-
-	case L2CAP_SDU_CONTINUE:
-		if (!(pi->conn_state & L2CAP_CONN_SAR_SDU))
-			goto disconnect;
-
-		if (!pi->sdu)
-			goto disconnect;
-
-		pi->partial_sdu_len += skb->len;
-		if (pi->partial_sdu_len > pi->sdu_len)
-			goto drop;
-
-		memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);
-
-		break;
-
-	case L2CAP_SDU_END:
-		if (!(pi->conn_state & L2CAP_CONN_SAR_SDU))
-			goto disconnect;
-
-		if (!pi->sdu)
-			goto disconnect;
-
-		if (!(pi->conn_state & L2CAP_CONN_SAR_RETRY)) {
-			pi->partial_sdu_len += skb->len;
-
-			if (pi->partial_sdu_len > pi->imtu)
-				goto drop;
-
-			if (pi->partial_sdu_len != pi->sdu_len)
-				goto drop;
-
-			memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);
-		}
-
-		_skb = skb_clone(pi->sdu, GFP_ATOMIC);
-		if (!_skb) {
-			pi->conn_state |= L2CAP_CONN_SAR_RETRY;
-			return -ENOMEM;
-		}
-
-		err = sock_queue_rcv_skb(sk, _skb);
-		if (err < 0) {
-			kfree_skb(_skb);
-			pi->conn_state |= L2CAP_CONN_SAR_RETRY;
-			return err;
-		}
-
-		pi->conn_state &= ~L2CAP_CONN_SAR_RETRY;
-		pi->conn_state &= ~L2CAP_CONN_SAR_SDU;
-
-		kfree_skb(pi->sdu);
-		break;
-	}
-
-	kfree_skb(skb);
-	return 0;
-
-drop:
-	kfree_skb(pi->sdu);
-	pi->sdu = NULL;
-
-disconnect:
-	l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-	kfree_skb(skb);
-	return 0;
-}
-
-static int l2cap_try_push_rx_skb(struct sock *sk)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *skb;
-	u16 control;
-	int err;
-
-	while ((skb = skb_dequeue(BUSY_QUEUE(sk)))) {
-		control = bt_cb(skb)->sar << L2CAP_CTRL_SAR_SHIFT;
-		err = l2cap_ertm_reassembly_sdu(sk, skb, control);
-		if (err < 0) {
-			skb_queue_head(BUSY_QUEUE(sk), skb);
-			return -EBUSY;
-		}
-
-		pi->buffer_seq = (pi->buffer_seq + 1) % 64;
-	}
-
-	if (!(pi->conn_state & L2CAP_CONN_RNR_SENT))
-		goto done;
-
-	control = pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-	control |= L2CAP_SUPER_RCV_READY | L2CAP_CTRL_POLL;
-	l2cap_send_sframe(pi, control);
-	l2cap_pi(sk)->retry_count = 1;
-
-	del_timer(&pi->retrans_timer);
-	__mod_monitor_timer();
-
-	l2cap_pi(sk)->conn_state |= L2CAP_CONN_WAIT_F;
-
-done:
-	pi->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
-	pi->conn_state &= ~L2CAP_CONN_RNR_SENT;
-
-	BT_DBG("sk %p, Exit local busy", sk);
-
-	return 0;
-}
-
-static void l2cap_busy_work(struct work_struct *work)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	struct l2cap_pinfo *pi =
-		container_of(work, struct l2cap_pinfo, busy_work);
-	struct sock *sk = (struct sock *)pi;
-	int n_tries = 0, timeo = HZ/5, err;
-	struct sk_buff *skb;
-
-	lock_sock(sk);
-
-	add_wait_queue(sk_sleep(sk), &wait);
-	while ((skb = skb_peek(BUSY_QUEUE(sk)))) {
-		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (n_tries++ > L2CAP_LOCAL_BUSY_TRIES) {
-			err = -EBUSY;
-			l2cap_send_disconn_req(pi->conn, sk, EBUSY);
-			break;
-		}
-
-		if (!timeo)
-			timeo = HZ/5;
-
-		if (signal_pending(current)) {
-			err = sock_intr_errno(timeo);
-			break;
-		}
-
-		release_sock(sk);
-		timeo = schedule_timeout(timeo);
-		lock_sock(sk);
-
-		err = sock_error(sk);
-		if (err)
-			break;
-
-		if (l2cap_try_push_rx_skb(sk) == 0)
-			break;
-	}
-
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(sk_sleep(sk), &wait);
-
-	release_sock(sk);
-}
-
-static int l2cap_push_rx_skb(struct sock *sk, struct sk_buff *skb, u16 control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int sctrl, err;
-
-	if (pi->conn_state & L2CAP_CONN_LOCAL_BUSY) {
-		bt_cb(skb)->sar = control >> L2CAP_CTRL_SAR_SHIFT;
-		__skb_queue_tail(BUSY_QUEUE(sk), skb);
-		return l2cap_try_push_rx_skb(sk);
-
-
-	}
-
-	err = l2cap_ertm_reassembly_sdu(sk, skb, control);
-	if (err >= 0) {
-		pi->buffer_seq = (pi->buffer_seq + 1) % 64;
-		return err;
-	}
-
-	/* Busy Condition */
-	BT_DBG("sk %p, Enter local busy", sk);
-
-	pi->conn_state |= L2CAP_CONN_LOCAL_BUSY;
-	bt_cb(skb)->sar = control >> L2CAP_CTRL_SAR_SHIFT;
-	__skb_queue_tail(BUSY_QUEUE(sk), skb);
-
-	sctrl = pi->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-	sctrl |= L2CAP_SUPER_RCV_NOT_READY;
-	l2cap_send_sframe(pi, sctrl);
-
-	pi->conn_state |= L2CAP_CONN_RNR_SENT;
-
-	del_timer(&pi->ack_timer);
-
-	queue_work(_busy_wq, &pi->busy_work);
-
-	return err;
-}
-
-static int l2cap_streaming_reassembly_sdu(struct sock *sk, struct sk_buff *skb, u16 control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct sk_buff *_skb;
-	int err = -EINVAL;
-
-	/*
-	 * TODO: We have to notify the userland if some data is lost with the
-	 * Streaming Mode.
-	 */
-
-	switch (control & L2CAP_CTRL_SAR) {
-	case L2CAP_SDU_UNSEGMENTED:
-		if (pi->conn_state & L2CAP_CONN_SAR_SDU) {
-			kfree_skb(pi->sdu);
-			break;
-		}
-
-		err = sock_queue_rcv_skb(sk, skb);
-		if (!err)
-			return 0;
-
-		break;
-
-	case L2CAP_SDU_START:
-		if (pi->conn_state & L2CAP_CONN_SAR_SDU) {
-			kfree_skb(pi->sdu);
-			break;
-		}
-
-		pi->sdu_len = get_unaligned_le16(skb->data);
-		skb_pull(skb, 2);
-
-		if (pi->sdu_len > pi->imtu) {
-			err = -EMSGSIZE;
-			break;
-		}
-
-		pi->sdu = bt_skb_alloc(pi->sdu_len, GFP_ATOMIC);
-		if (!pi->sdu) {
-			err = -ENOMEM;
-			break;
-		}
-
-		memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);
-
-		pi->conn_state |= L2CAP_CONN_SAR_SDU;
-		pi->partial_sdu_len = skb->len;
-		err = 0;
-		break;
-
-	case L2CAP_SDU_CONTINUE:
-		if (!(pi->conn_state & L2CAP_CONN_SAR_SDU))
-			break;
-
-		memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);
-
-		pi->partial_sdu_len += skb->len;
-		if (pi->partial_sdu_len > pi->sdu_len)
-			kfree_skb(pi->sdu);
-		else
-			err = 0;
-
-		break;
-
-	case L2CAP_SDU_END:
-		if (!(pi->conn_state & L2CAP_CONN_SAR_SDU))
-			break;
-
-		memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);
-
-		pi->conn_state &= ~L2CAP_CONN_SAR_SDU;
-		pi->partial_sdu_len += skb->len;
-
-		if (pi->partial_sdu_len > pi->imtu)
-			goto drop;
-
-		if (pi->partial_sdu_len == pi->sdu_len) {
-			_skb = skb_clone(pi->sdu, GFP_ATOMIC);
-			err = sock_queue_rcv_skb(sk, _skb);
-			if (err < 0)
-				kfree_skb(_skb);
-		}
-		err = 0;
-
-drop:
-		kfree_skb(pi->sdu);
-		break;
-	}
-
-	kfree_skb(skb);
-	return err;
-}
-
-static void l2cap_check_srej_gap(struct sock *sk, u8 tx_seq)
-{
-	struct sk_buff *skb;
-	u16 control;
-
-	while ((skb = skb_peek(SREJ_QUEUE(sk)))) {
-		if (bt_cb(skb)->tx_seq != tx_seq)
-			break;
-
-		skb = skb_dequeue(SREJ_QUEUE(sk));
-		control = bt_cb(skb)->sar << L2CAP_CTRL_SAR_SHIFT;
-		l2cap_ertm_reassembly_sdu(sk, skb, control);
-		l2cap_pi(sk)->buffer_seq_srej =
-			(l2cap_pi(sk)->buffer_seq_srej + 1) % 64;
-		tx_seq = (tx_seq + 1) % 64;
-	}
-}
-
-static void l2cap_resend_srejframe(struct sock *sk, u8 tx_seq)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct srej_list *l, *tmp;
-	u16 control;
-
-	list_for_each_entry_safe(l, tmp, SREJ_LIST(sk), list) {
-		if (l->tx_seq == tx_seq) {
-			list_del(&l->list);
-			kfree(l);
-			return;
-		}
-		control = L2CAP_SUPER_SELECT_REJECT;
-		control |= l->tx_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-		l2cap_send_sframe(pi, control);
-		list_del(&l->list);
-		list_add_tail(&l->list, SREJ_LIST(sk));
-	}
-}
-
-static void l2cap_send_srejframe(struct sock *sk, u8 tx_seq)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	struct srej_list *new;
-	u16 control;
-
-	while (tx_seq != pi->expected_tx_seq) {
-		control = L2CAP_SUPER_SELECT_REJECT;
-		control |= pi->expected_tx_seq << L2CAP_CTRL_REQSEQ_SHIFT;
-		l2cap_send_sframe(pi, control);
-
-		new = kzalloc(sizeof(struct srej_list), GFP_ATOMIC);
-		new->tx_seq = pi->expected_tx_seq;
-		pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;
-		list_add_tail(&new->list, SREJ_LIST(sk));
-	}
-	pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;
-}
-
-static inline int l2cap_data_channel_iframe(struct sock *sk, u16 rx_control, struct sk_buff *skb)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u8 tx_seq = __get_txseq(rx_control);
-	u8 req_seq = __get_reqseq(rx_control);
-	u8 sar = rx_control >> L2CAP_CTRL_SAR_SHIFT;
-	int tx_seq_offset, expected_tx_seq_offset;
-	int num_to_ack = (pi->tx_win/6) + 1;
-	int err = 0;
-
-	BT_DBG("sk %p len %d tx_seq %d rx_control 0x%4.4x", sk, skb->len, tx_seq,
-								rx_control);
-
-	if (L2CAP_CTRL_FINAL & rx_control &&
-			l2cap_pi(sk)->conn_state & L2CAP_CONN_WAIT_F) {
-		del_timer(&pi->monitor_timer);
-		if (pi->unacked_frames > 0)
-			__mod_retrans_timer();
-		pi->conn_state &= ~L2CAP_CONN_WAIT_F;
-	}
-
-	pi->expected_ack_seq = req_seq;
-	l2cap_drop_acked_frames(sk);
-
-	if (tx_seq == pi->expected_tx_seq)
-		goto expected;
-
-	tx_seq_offset = (tx_seq - pi->buffer_seq) % 64;
-	if (tx_seq_offset < 0)
-		tx_seq_offset += 64;
-
-	/* invalid tx_seq */
-	if (tx_seq_offset >= pi->tx_win) {
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		goto drop;
-	}
-
-	if (pi->conn_state == L2CAP_CONN_LOCAL_BUSY)
-		goto drop;
-
-	if (pi->conn_state & L2CAP_CONN_SREJ_SENT) {
-		struct srej_list *first;
-
-		first = list_first_entry(SREJ_LIST(sk),
-				struct srej_list, list);
-		if (tx_seq == first->tx_seq) {
-			l2cap_add_to_srej_queue(sk, skb, tx_seq, sar);
-			l2cap_check_srej_gap(sk, tx_seq);
-
-			list_del(&first->list);
-			kfree(first);
-
-			if (list_empty(SREJ_LIST(sk))) {
-				pi->buffer_seq = pi->buffer_seq_srej;
-				pi->conn_state &= ~L2CAP_CONN_SREJ_SENT;
-				l2cap_send_ack(pi);
-				BT_DBG("sk %p, Exit SREJ_SENT", sk);
-			}
-		} else {
-			struct srej_list *l;
-
-			/* duplicated tx_seq */
-			if (l2cap_add_to_srej_queue(sk, skb, tx_seq, sar) < 0)
-				goto drop;
-
-			list_for_each_entry(l, SREJ_LIST(sk), list) {
-				if (l->tx_seq == tx_seq) {
-					l2cap_resend_srejframe(sk, tx_seq);
-					return 0;
-				}
-			}
-			l2cap_send_srejframe(sk, tx_seq);
-		}
-	} else {
-		expected_tx_seq_offset =
-			(pi->expected_tx_seq - pi->buffer_seq) % 64;
-		if (expected_tx_seq_offset < 0)
-			expected_tx_seq_offset += 64;
-
-		/* duplicated tx_seq */
-		if (tx_seq_offset < expected_tx_seq_offset)
-			goto drop;
-
-		pi->conn_state |= L2CAP_CONN_SREJ_SENT;
-
-		BT_DBG("sk %p, Enter SREJ", sk);
-
-		INIT_LIST_HEAD(SREJ_LIST(sk));
-		pi->buffer_seq_srej = pi->buffer_seq;
-
-		__skb_queue_head_init(SREJ_QUEUE(sk));
-		__skb_queue_head_init(BUSY_QUEUE(sk));
-		l2cap_add_to_srej_queue(sk, skb, tx_seq, sar);
-
-		pi->conn_state |= L2CAP_CONN_SEND_PBIT;
-
-		l2cap_send_srejframe(sk, tx_seq);
-
-		del_timer(&pi->ack_timer);
-	}
-	return 0;
-
-expected:
-	pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;
-
-	if (pi->conn_state & L2CAP_CONN_SREJ_SENT) {
-		bt_cb(skb)->tx_seq = tx_seq;
-		bt_cb(skb)->sar = sar;
-		__skb_queue_tail(SREJ_QUEUE(sk), skb);
-		return 0;
-	}
-
-	err = l2cap_push_rx_skb(sk, skb, rx_control);
-	if (err < 0)
-		return 0;
-
-	if (rx_control & L2CAP_CTRL_FINAL) {
-		if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-			pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-		else
-			l2cap_retransmit_frames(sk);
-	}
-
-	__mod_ack_timer();
-
-	pi->num_acked = (pi->num_acked + 1) % num_to_ack;
-	if (pi->num_acked == num_to_ack - 1)
-		l2cap_send_ack(pi);
-
-	return 0;
-
-drop:
-	kfree_skb(skb);
-	return 0;
-}
-
-static inline void l2cap_data_channel_rrframe(struct sock *sk, u16 rx_control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-	BT_DBG("sk %p, req_seq %d ctrl 0x%4.4x", sk, __get_reqseq(rx_control),
-						rx_control);
-
-	pi->expected_ack_seq = __get_reqseq(rx_control);
-	l2cap_drop_acked_frames(sk);
-
-	if (rx_control & L2CAP_CTRL_POLL) {
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-		if (pi->conn_state & L2CAP_CONN_SREJ_SENT) {
-			if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-					(pi->unacked_frames > 0))
-				__mod_retrans_timer();
-
-			pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-			l2cap_send_srejtail(sk);
-		} else {
-			l2cap_send_i_or_rr_or_rnr(sk);
-		}
-
-	} else if (rx_control & L2CAP_CTRL_FINAL) {
-		pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-		if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-			pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-		else
-			l2cap_retransmit_frames(sk);
-
-	} else {
-		if ((pi->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
-				(pi->unacked_frames > 0))
-			__mod_retrans_timer();
-
-		pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-		if (pi->conn_state & L2CAP_CONN_SREJ_SENT)
-			l2cap_send_ack(pi);
-		else
-			l2cap_ertm_send(sk);
-	}
-}
-
-static inline void l2cap_data_channel_rejframe(struct sock *sk, u16 rx_control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u8 tx_seq = __get_reqseq(rx_control);
-
-	BT_DBG("sk %p, req_seq %d ctrl 0x%4.4x", sk, tx_seq, rx_control);
-
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-	pi->expected_ack_seq = tx_seq;
-	l2cap_drop_acked_frames(sk);
-
-	if (rx_control & L2CAP_CTRL_FINAL) {
-		if (pi->conn_state & L2CAP_CONN_REJ_ACT)
-			pi->conn_state &= ~L2CAP_CONN_REJ_ACT;
-		else
-			l2cap_retransmit_frames(sk);
-	} else {
-		l2cap_retransmit_frames(sk);
-
-		if (pi->conn_state & L2CAP_CONN_WAIT_F)
-			pi->conn_state |= L2CAP_CONN_REJ_ACT;
-	}
-}
-static inline void l2cap_data_channel_srejframe(struct sock *sk, u16 rx_control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u8 tx_seq = __get_reqseq(rx_control);
-
-	BT_DBG("sk %p, req_seq %d ctrl 0x%4.4x", sk, tx_seq, rx_control);
-
-	pi->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
-
-	if (rx_control & L2CAP_CTRL_POLL) {
-		pi->expected_ack_seq = tx_seq;
-		l2cap_drop_acked_frames(sk);
-
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-		l2cap_retransmit_one_frame(sk, tx_seq);
-
-		l2cap_ertm_send(sk);
-
-		if (pi->conn_state & L2CAP_CONN_WAIT_F) {
-			pi->srej_save_reqseq = tx_seq;
-			pi->conn_state |= L2CAP_CONN_SREJ_ACT;
-		}
-	} else if (rx_control & L2CAP_CTRL_FINAL) {
-		if ((pi->conn_state & L2CAP_CONN_SREJ_ACT) &&
-				pi->srej_save_reqseq == tx_seq)
-			pi->conn_state &= ~L2CAP_CONN_SREJ_ACT;
-		else
-			l2cap_retransmit_one_frame(sk, tx_seq);
-	} else {
-		l2cap_retransmit_one_frame(sk, tx_seq);
-		if (pi->conn_state & L2CAP_CONN_WAIT_F) {
-			pi->srej_save_reqseq = tx_seq;
-			pi->conn_state |= L2CAP_CONN_SREJ_ACT;
-		}
-	}
-}
-
-static inline void l2cap_data_channel_rnrframe(struct sock *sk, u16 rx_control)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u8 tx_seq = __get_reqseq(rx_control);
-
-	BT_DBG("sk %p, req_seq %d ctrl 0x%4.4x", sk, tx_seq, rx_control);
-
-	pi->conn_state |= L2CAP_CONN_REMOTE_BUSY;
-	pi->expected_ack_seq = tx_seq;
-	l2cap_drop_acked_frames(sk);
-
-	if (rx_control & L2CAP_CTRL_POLL)
-		pi->conn_state |= L2CAP_CONN_SEND_FBIT;
-
-	if (!(pi->conn_state & L2CAP_CONN_SREJ_SENT)) {
-		del_timer(&pi->retrans_timer);
-		if (rx_control & L2CAP_CTRL_POLL)
-			l2cap_send_rr_or_rnr(pi, L2CAP_CTRL_FINAL);
-		return;
-	}
-
-	if (rx_control & L2CAP_CTRL_POLL)
-		l2cap_send_srejtail(sk);
-	else
-		l2cap_send_sframe(pi, L2CAP_SUPER_RCV_READY);
-}
-
-static inline int l2cap_data_channel_sframe(struct sock *sk, u16 rx_control, struct sk_buff *skb)
-{
-	BT_DBG("sk %p rx_control 0x%4.4x len %d", sk, rx_control, skb->len);
-
-	if (L2CAP_CTRL_FINAL & rx_control &&
-			l2cap_pi(sk)->conn_state & L2CAP_CONN_WAIT_F) {
-		del_timer(&l2cap_pi(sk)->monitor_timer);
-		if (l2cap_pi(sk)->unacked_frames > 0)
-			__mod_retrans_timer();
-		l2cap_pi(sk)->conn_state &= ~L2CAP_CONN_WAIT_F;
-	}
-
-	switch (rx_control & L2CAP_CTRL_SUPERVISE) {
-	case L2CAP_SUPER_RCV_READY:
-		l2cap_data_channel_rrframe(sk, rx_control);
-		break;
-
-	case L2CAP_SUPER_REJECT:
-		l2cap_data_channel_rejframe(sk, rx_control);
-		break;
-
-	case L2CAP_SUPER_SELECT_REJECT:
-		l2cap_data_channel_srejframe(sk, rx_control);
-		break;
-
-	case L2CAP_SUPER_RCV_NOT_READY:
-		l2cap_data_channel_rnrframe(sk, rx_control);
-		break;
-	}
-
-	kfree_skb(skb);
-	return 0;
-}
-
-static int l2cap_ertm_data_rcv(struct sock *sk, struct sk_buff *skb)
-{
-	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	u16 control;
-	u8 req_seq;
-	int len, next_tx_seq_offset, req_seq_offset;
-
-	control = get_unaligned_le16(skb->data);
-	skb_pull(skb, 2);
-	len = skb->len;
-
-	/*
-	 * We can just drop the corrupted I-frame here.
-	 * Receiver will miss it and start proper recovery
-	 * procedures and ask retransmission.
-	 */
-	if (l2cap_check_fcs(pi, skb))
-		goto drop;
-
-	if (__is_sar_start(control) && __is_iframe(control))
-		len -= 2;
-
-	if (pi->fcs == L2CAP_FCS_CRC16)
-		len -= 2;
-
-	if (len > pi->mps) {
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		goto drop;
-	}
-
-	req_seq = __get_reqseq(control);
-	req_seq_offset = (req_seq - pi->expected_ack_seq) % 64;
-	if (req_seq_offset < 0)
-		req_seq_offset += 64;
-
-	next_tx_seq_offset =
-		(pi->next_tx_seq - pi->expected_ack_seq) % 64;
-	if (next_tx_seq_offset < 0)
-		next_tx_seq_offset += 64;
-
-	/* check for invalid req-seq */
-	if (req_seq_offset > next_tx_seq_offset) {
-		l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-		goto drop;
-	}
-
-	if (__is_iframe(control)) {
-		if (len < 0) {
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-			goto drop;
-		}
-
-		l2cap_data_channel_iframe(sk, control, skb);
-	} else {
-		if (len != 0) {
-			BT_ERR("%d", len);
-			l2cap_send_disconn_req(pi->conn, sk, ECONNRESET);
-			goto drop;
-		}
-
-		l2cap_data_channel_sframe(sk, control, skb);
-	}
-
-	return 0;
-
-drop:
-	kfree_skb(skb);
-	return 0;
-}
-
-static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)
-{
-	struct sock *sk;
-	struct l2cap_pinfo *pi;
-	u16 control;
-	u8 tx_seq;
-	int len;
-
-	sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);
-	if (!sk) {
-		BT_DBG("unknown cid 0x%4.4x", cid);
-		goto drop;
-	}
-
-	pi = l2cap_pi(sk);
-
-	BT_DBG("sk %p, len %d", sk, skb->len);
-
-	if (sk->sk_state != BT_CONNECTED)
-		goto drop;
-
-	switch (pi->mode) {
-	case L2CAP_MODE_BASIC:
-		/* If socket recv buffers overflows we drop data here
-		 * which is *bad* because L2CAP has to be reliable.
-		 * But we don't have any other choice. L2CAP doesn't
-		 * provide flow control mechanism. */
-
-		if (pi->imtu < skb->len)
-			goto drop;
-
-		if (!sock_queue_rcv_skb(sk, skb))
-			goto done;
-		break;
-
-	case L2CAP_MODE_ERTM:
-		if (!sock_owned_by_user(sk)) {
-			l2cap_ertm_data_rcv(sk, skb);
-		} else {
-			if (sk_add_backlog(sk, skb))
-				goto drop;
-		}
-
-		goto done;
-
-	case L2CAP_MODE_STREAMING:
-		control = get_unaligned_le16(skb->data);
-		skb_pull(skb, 2);
-		len = skb->len;
-
-		if (l2cap_check_fcs(pi, skb))
-			goto drop;
-
-		if (__is_sar_start(control))
-			len -= 2;
-
-		if (pi->fcs == L2CAP_FCS_CRC16)
-			len -= 2;
-
-		if (len > pi->mps || len < 0 || __is_sframe(control))
-			goto drop;
-
-		tx_seq = __get_txseq(control);
-
-		if (pi->expected_tx_seq == tx_seq)
-			pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;
-		else
-			pi->expected_tx_seq = (tx_seq + 1) % 64;
-
-		l2cap_streaming_reassembly_sdu(sk, skb, control);
-
-		goto done;
-
-	default:
-		BT_DBG("sk %p: bad mode 0x%2.2x", sk, pi->mode);
-		break;
-	}
-
-drop:
-	kfree_skb(skb);
-
-done:
-	if (sk)
-		bh_unlock_sock(sk);
-
-	return 0;
-}
-
-static inline int l2cap_conless_channel(struct l2cap_conn *conn, __le16 psm, struct sk_buff *skb)
-{
-	struct sock *sk;
-
-	sk = l2cap_get_sock_by_psm(0, psm, conn->src);
-	if (!sk)
-		goto drop;
-
-	bh_lock_sock(sk);
-
-	BT_DBG("sk %p, len %d", sk, skb->len);
-
-	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)
-		goto drop;
-
-	if (l2cap_pi(sk)->imtu < skb->len)
-		goto drop;
-
-	if (!sock_queue_rcv_skb(sk, skb))
-		goto done;
-
-drop:
-	kfree_skb(skb);
-
-done:
-	if (sk)
-		bh_unlock_sock(sk);
-	return 0;
-}
-
-static void l2cap_recv_frame(struct l2cap_conn *conn, struct sk_buff *skb)
-{
-	struct l2cap_hdr *lh = (void *) skb->data;
-	u16 cid, len;
-	__le16 psm;
-
-	skb_pull(skb, L2CAP_HDR_SIZE);
-	cid = __le16_to_cpu(lh->cid);
-	len = __le16_to_cpu(lh->len);
-
-	if (len != skb->len) {
-		kfree_skb(skb);
-		return;
-	}
-
-	BT_DBG("len %d, cid 0x%4.4x", len, cid);
-
-	switch (cid) {
-	case L2CAP_CID_SIGNALING:
-		l2cap_sig_channel(conn, skb);
-		break;
-
-	case L2CAP_CID_CONN_LESS:
-		psm = get_unaligned_le16(skb->data);
-		skb_pull(skb, 2);
-		l2cap_conless_channel(conn, psm, skb);
-		break;
-
-	default:
-		l2cap_data_channel(conn, cid, skb);
-		break;
-	}
-}
-
-/* ---- L2CAP interface with lower layer (HCI) ---- */
-
-static int l2cap_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type)
-{
-	int exact = 0, lm1 = 0, lm2 = 0;
-	register struct sock *sk;
-	struct hlist_node *node;
-
-	if (type != ACL_LINK)
-		return -EINVAL;
-
-	BT_DBG("hdev %s, bdaddr %s", hdev->name, batostr(bdaddr));
-
-	/* Find listening sockets and check their link_mode */
-	read_lock(&l2cap_sk_list.lock);
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		if (sk->sk_state != BT_LISTEN)
-			continue;
-
-		if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr)) {
-			lm1 |= HCI_LM_ACCEPT;
-			if (l2cap_pi(sk)->role_switch)
-				lm1 |= HCI_LM_MASTER;
-			exact++;
-		} else if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {
-			lm2 |= HCI_LM_ACCEPT;
-			if (l2cap_pi(sk)->role_switch)
-				lm2 |= HCI_LM_MASTER;
-		}
-	}
-	read_unlock(&l2cap_sk_list.lock);
-
-	return exact ? lm1 : lm2;
-}
-
-static int l2cap_connect_cfm(struct hci_conn *hcon, u8 status)
-{
-	struct l2cap_conn *conn;
-
-	BT_DBG("hcon %p bdaddr %s status %d", hcon, batostr(&hcon->dst), status);
-
-	if (hcon->type != ACL_LINK)
-		return -EINVAL;
-
-	if (!status) {
-		conn = l2cap_conn_add(hcon, status);
-		if (conn)
-			l2cap_conn_ready(conn);
-	} else
-		l2cap_conn_del(hcon, bt_err(status));
-
-	return 0;
-}
-
-static int l2cap_disconn_ind(struct hci_conn *hcon)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-
-	BT_DBG("hcon %p", hcon);
-
-	if (hcon->type != ACL_LINK || !conn)
-		return 0x13;
-
-	return conn->disc_reason;
-}
-
-static int l2cap_disconn_cfm(struct hci_conn *hcon, u8 reason)
-{
-	BT_DBG("hcon %p reason %d", hcon, reason);
-
-	if (hcon->type != ACL_LINK)
-		return -EINVAL;
-
-	l2cap_conn_del(hcon, bt_err(reason));
-
-	return 0;
-}
-
-static inline void l2cap_check_encryption(struct sock *sk, u8 encrypt)
-{
-	if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM)
-		return;
-
-	if (encrypt == 0x00) {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM) {
-			l2cap_sock_clear_timer(sk);
-			l2cap_sock_set_timer(sk, HZ * 5);
-		} else if (l2cap_pi(sk)->sec_level == BT_SECURITY_HIGH)
-			__l2cap_sock_close(sk, ECONNREFUSED);
-	} else {
-		if (l2cap_pi(sk)->sec_level == BT_SECURITY_MEDIUM)
-			l2cap_sock_clear_timer(sk);
-	}
-}
-
-static int l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)
-{
-	struct l2cap_chan_list *l;
-	struct l2cap_conn *conn = hcon->l2cap_data;
-	struct sock *sk;
-
-	if (!conn)
-		return 0;
-
-	l = &conn->chan_list;
-
-	BT_DBG("conn %p", conn);
-
-	read_lock(&l->lock);
-
-	for (sk = l->head; sk; sk = l2cap_pi(sk)->next_c) {
-		bh_lock_sock(sk);
-
-		if (l2cap_pi(sk)->conf_state & L2CAP_CONF_CONNECT_PEND) {
-			bh_unlock_sock(sk);
-			continue;
-		}
-
-		if (!status && (sk->sk_state == BT_CONNECTED ||
-						sk->sk_state == BT_CONFIG)) {
-			l2cap_check_encryption(sk, encrypt);
-			bh_unlock_sock(sk);
-			continue;
-		}
-
-		if (sk->sk_state == BT_CONNECT) {
-			if (!status) {
-				struct l2cap_conn_req req;
-				req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
-				req.psm  = l2cap_pi(sk)->psm;
-
-				l2cap_pi(sk)->ident = l2cap_get_ident(conn);
-				l2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;
-
-				l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_REQ, sizeof(req), &req);
-			} else {
-				l2cap_sock_clear_timer(sk);
-				l2cap_sock_set_timer(sk, HZ / 10);
-			}
-		} else if (sk->sk_state == BT_CONNECT2) {
-			struct l2cap_conn_rsp rsp;
-			__u16 result;
-
-			if (!status) {
-				sk->sk_state = BT_CONFIG;
-				result = L2CAP_CR_SUCCESS;
-			} else {
-				sk->sk_state = BT_DISCONN;
-				l2cap_sock_set_timer(sk, HZ / 10);
-				result = L2CAP_CR_SEC_BLOCK;
-			}
-
-			rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
-			rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
-			rsp.result = cpu_to_le16(result);
-			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
-			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
-					L2CAP_CONN_RSP, sizeof(rsp), &rsp);
-		}
-
-		bh_unlock_sock(sk);
-	}
-
-	read_unlock(&l->lock);
-
-	return 0;
-}
-
-static int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb, u16 flags)
-{
-	struct l2cap_conn *conn = hcon->l2cap_data;
-
-	if (!conn && !(conn = l2cap_conn_add(hcon, 0)))
-		goto drop;
-
-	BT_DBG("conn %p len %d flags 0x%x", conn, skb->len, flags);
-
-	if (!(flags & ACL_CONT)) {
-		struct l2cap_hdr *hdr;
-		struct sock *sk;
-		u16 cid;
-		int len;
-
-		if (conn->rx_len) {
-			BT_ERR("Unexpected start frame (len %d)", skb->len);
-			kfree_skb(conn->rx_skb);
-			conn->rx_skb = NULL;
-			conn->rx_len = 0;
-			l2cap_conn_unreliable(conn, ECOMM);
-		}
-
-		/* Start fragment always begin with Basic L2CAP header */
-		if (skb->len < L2CAP_HDR_SIZE) {
-			BT_ERR("Frame is too short (len %d)", skb->len);
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
-		hdr = (struct l2cap_hdr *) skb->data;
-		len = __le16_to_cpu(hdr->len) + L2CAP_HDR_SIZE;
-		cid = __le16_to_cpu(hdr->cid);
-
-		if (len == skb->len) {
-			/* Complete frame received */
-			l2cap_recv_frame(conn, skb);
-			return 0;
-		}
-
-		BT_DBG("Start: total len %d, frag len %d", len, skb->len);
-
-		if (skb->len > len) {
-			BT_ERR("Frame is too long (len %d, expected len %d)",
-				skb->len, len);
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
-		sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);
-
-		if (sk && l2cap_pi(sk)->imtu < len - L2CAP_HDR_SIZE) {
-			BT_ERR("Frame exceeding recv MTU (len %d, MTU %d)",
-					len, l2cap_pi(sk)->imtu);
-			bh_unlock_sock(sk);
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
-		if (sk)
-			bh_unlock_sock(sk);
-
-		/* Allocate skb for the complete frame (with header) */
-		conn->rx_skb = bt_skb_alloc(len, GFP_ATOMIC);
-		if (!conn->rx_skb)
-			goto drop;
-
-		skb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),
-								skb->len);
-		conn->rx_len = len - skb->len;
-	} else {
-		BT_DBG("Cont: frag len %d (expecting %d)", skb->len, conn->rx_len);
-
-		if (!conn->rx_len) {
-			BT_ERR("Unexpected continuation frame (len %d)", skb->len);
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
-		if (skb->len > conn->rx_len) {
-			BT_ERR("Fragment is too long (len %d, expected %d)",
-					skb->len, conn->rx_len);
-			kfree_skb(conn->rx_skb);
-			conn->rx_skb = NULL;
-			conn->rx_len = 0;
-			l2cap_conn_unreliable(conn, ECOMM);
-			goto drop;
-		}
-
-		skb_copy_from_linear_data(skb, skb_put(conn->rx_skb, skb->len),
-								skb->len);
-		conn->rx_len -= skb->len;
-
-		if (!conn->rx_len) {
-			/* Complete frame received */
-			l2cap_recv_frame(conn, conn->rx_skb);
-			conn->rx_skb = NULL;
-		}
-	}
-
-drop:
-	kfree_skb(skb);
-	return 0;
-}
-
-static int l2cap_debugfs_show(struct seq_file *f, void *p)
-{
-	struct sock *sk;
-	struct hlist_node *node;
-
-	read_lock_bh(&l2cap_sk_list.lock);
-
-	sk_for_each(sk, node, &l2cap_sk_list.head) {
-		struct l2cap_pinfo *pi = l2cap_pi(sk);
-
-		seq_printf(f, "%s %s %d %d 0x%4.4x 0x%4.4x %d %d %d\n",
-					batostr(&bt_sk(sk)->src),
-					batostr(&bt_sk(sk)->dst),
-					sk->sk_state, __le16_to_cpu(pi->psm),
-					pi->scid, pi->dcid,
-					pi->imtu, pi->omtu, pi->sec_level);
-	}
-
-	read_unlock_bh(&l2cap_sk_list.lock);
-
-	return 0;
-}
-
-static int l2cap_debugfs_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, l2cap_debugfs_show, inode->i_private);
-}
-
-static const struct file_operations l2cap_debugfs_fops = {
-	.open		= l2cap_debugfs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static struct dentry *l2cap_debugfs;
-
-static const struct proto_ops l2cap_sock_ops = {
-	.family		= PF_BLUETOOTH,
-	.owner		= THIS_MODULE,
-	.release	= l2cap_sock_release,
-	.bind		= l2cap_sock_bind,
-	.connect	= l2cap_sock_connect,
-	.listen		= l2cap_sock_listen,
-	.accept		= l2cap_sock_accept,
-	.getname	= l2cap_sock_getname,
-	.sendmsg	= l2cap_sock_sendmsg,
-	.recvmsg	= l2cap_sock_recvmsg,
-	.poll		= bt_sock_poll,
-	.ioctl		= bt_sock_ioctl,
-	.mmap		= sock_no_mmap,
-	.socketpair	= sock_no_socketpair,
-	.shutdown	= l2cap_sock_shutdown,
-	.setsockopt	= l2cap_sock_setsockopt,
-	.getsockopt	= l2cap_sock_getsockopt
-};
-
-static const struct net_proto_family l2cap_sock_family_ops = {
-	.family	= PF_BLUETOOTH,
-	.owner	= THIS_MODULE,
-	.create	= l2cap_sock_create,
-};
-
-static struct hci_proto l2cap_hci_proto = {
-	.name		= "L2CAP",
-	.id		= HCI_PROTO_L2CAP,
-	.connect_ind	= l2cap_connect_ind,
-	.connect_cfm	= l2cap_connect_cfm,
-	.disconn_ind	= l2cap_disconn_ind,
-	.disconn_cfm	= l2cap_disconn_cfm,
-	.security_cfm	= l2cap_security_cfm,
-	.recv_acldata	= l2cap_recv_acldata
-};
-
-static int __init l2cap_init(void)
-{
-	int err;
-
-	err = proto_register(&l2cap_proto, 0);
-	if (err < 0)
-		return err;
-
-	_busy_wq = create_singlethread_workqueue("l2cap");
-	if (!_busy_wq) {
-		proto_unregister(&l2cap_proto);
-		return -ENOMEM;
-	}
-
-	err = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);
-	if (err < 0) {
-		BT_ERR("L2CAP socket registration failed");
-		goto error;
-	}
-
-	err = hci_register_proto(&l2cap_hci_proto);
-	if (err < 0) {
-		BT_ERR("L2CAP protocol registration failed");
-		bt_sock_unregister(BTPROTO_L2CAP);
-		goto error;
-	}
-
-	if (bt_debugfs) {
-		l2cap_debugfs = debugfs_create_file("l2cap", 0444,
-					bt_debugfs, NULL, &l2cap_debugfs_fops);
-		if (!l2cap_debugfs)
-			BT_ERR("Failed to create L2CAP debug file");
-	}
-
-	BT_INFO("L2CAP ver %s", VERSION);
-	BT_INFO("L2CAP socket layer initialized");
-
-	return 0;
-
-error:
-	destroy_workqueue(_busy_wq);
-	proto_unregister(&l2cap_proto);
-	return err;
-}
-
-static void __exit l2cap_exit(void)
-{
-	debugfs_remove(l2cap_debugfs);
-
-	flush_workqueue(_busy_wq);
-	destroy_workqueue(_busy_wq);
-
-	if (bt_sock_unregister(BTPROTO_L2CAP) < 0)
-		BT_ERR("L2CAP socket unregistration failed");
-
-	if (hci_unregister_proto(&l2cap_hci_proto) < 0)
-		BT_ERR("L2CAP protocol unregistration failed");
-
-	proto_unregister(&l2cap_proto);
-}
-
-void l2cap_load(void)
-{
-	/* Dummy function to trigger automatic L2CAP module loading by
-	 * other modules that use L2CAP sockets but don't use any other
-	 * symbols from it. */
-}
-EXPORT_SYMBOL(l2cap_load);
-
-module_init(l2cap_init);
-module_exit(l2cap_exit);
-
-module_param(disable_ertm, bool, 0644);
-MODULE_PARM_DESC(disable_ertm, "Disable enhanced retransmission mode");
-
-MODULE_AUTHOR("Marcel Holtmann <marcel@holtmann.org>");
-MODULE_DESCRIPTION("Bluetooth L2CAP ver " VERSION);
-MODULE_VERSION(VERSION);
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("bt-proto-0");
